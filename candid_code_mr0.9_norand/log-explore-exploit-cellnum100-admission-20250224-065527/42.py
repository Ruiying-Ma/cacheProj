# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

from collections import defaultdict
import time

# Put tunable constant parameters below
FREQUENCY_THRESHOLD = 5
RECENCY_THRESHOLD = 300  # in seconds

# Put the metadata specifically maintained by the policy below. The policy maintains a distributed ledger that records all cache admission decisions, object access frequencies, and timestamps. Each cache node acts as a blockchain node, and the ledger is updated through a consensus protocol.

ledger = {
    'access_frequency': defaultdict(int),
    'last_access_timestamp': defaultdict(int),
    'admission_decisions': defaultdict(list)
}

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy uses the distributed ledger to check the object's access frequency and recency. If the object has been frequently accessed or recently accessed by multiple nodes, it is admitted into the cache. The decision is made through a consensus protocol among the nodes.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = False
    
    # Check access frequency
    access_frequency = ledger['access_frequency'][obj.key]
    
    # Check recency
    current_time = cache_snapshot.access_count
    last_access_time = ledger['last_access_timestamp'][obj.key]
    recency = current_time - last_access_time
    
    if access_frequency >= FREQUENCY_THRESHOLD or recency <= RECENCY_THRESHOLD:
        should_admit = True
    
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the policy updates the distributed ledger with the object's admission timestamp and increments its access frequency. The update is propagated to all nodes through the consensus protocol to ensure consistency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    ledger['access_frequency'][obj.key] += 1
    ledger['last_access_timestamp'][obj.key] = current_time
    ledger['admission_decisions'][obj.key].append((current_time, True))

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the policy updates the distributed ledger with the access attempt timestamp and notes the decision. This information is used to refine future admission decisions and is shared with all nodes via the consensus protocol.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    ledger['admission_decisions'][obj.key].append((current_time, False))

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    When a cache hit occurs, the policy updates the distributed ledger by incrementing the object's access frequency and updating the last access timestamp. This information is synchronized across all nodes to maintain an accurate and consistent record.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    ledger['access_frequency'][obj.key] += 1
    ledger['last_access_timestamp'][obj.key] = current_time