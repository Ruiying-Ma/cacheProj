# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
THRESHOLD_MULTIPLIER = 0.5  # This multiplier is used to calculate the dynamic threshold

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including a shard identifier for each object, a counter for the number of accesses per shard, and a timestamp of the last access for each shard.
shard_access_count = {}
shard_last_access_timestamp = {}

def get_shard_id(obj):
    # Define a method to get the shard identifier for an object. This can be based on the object's key.
    return obj.key[0]  # Example: Use the first character of the key as the shard identifier

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy admits an object into the cache if the shard it belongs to has a lower access count compared to a dynamically calculated threshold based on overall cache usage and throughput analysis.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = None
    
    # Calculate the dynamic threshold
    dynamic_threshold = THRESHOLD_MULTIPLIER * (cache_snapshot.hit_count + cache_snapshot.miss_count)
    
    # Get the shard identifier for the object
    shard_id = get_shard_id(obj)
    
    # Get the access count for the shard
    shard_access = shard_access_count.get(shard_id, 0)
    
    # Determine if the object should be admitted
    if shard_access < dynamic_threshold:
        should_admit = True
    else:
        should_admit = False
    
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the policy increments the access counter for the corresponding shard and updates the last access timestamp for that shard.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    shard_id = get_shard_id(obj)
    
    # Increment the access counter for the shard
    shard_access_count[shard_id] = shard_access_count.get(shard_id, 0) + 1
    
    # Update the last access timestamp for the shard
    shard_last_access_timestamp[shard_id] = cache_snapshot.access_count

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the policy increments the access counter for the corresponding shard but does not update the last access timestamp.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    shard_id = get_shard_id(obj)
    
    # Increment the access counter for the shard
    shard_access_count[shard_id] = shard_access_count.get(shard_id, 0) + 1

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy increments the access counter for the corresponding shard and updates the last access timestamp for that shard.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    shard_id = get_shard_id(obj)
    
    # Increment the access counter for the shard
    shard_access_count[shard_id] = shard_access_count.get(shard_id, 0) + 1
    
    # Update the last access timestamp for the shard
    shard_last_access_timestamp[shard_id] = cache_snapshot.access_count