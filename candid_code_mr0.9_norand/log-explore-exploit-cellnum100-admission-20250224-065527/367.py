# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
FREQUENCY_THRESHOLD = 5
SIZE_THRESHOLD_RATIO = 0.1
SYSTEM_LOAD_THRESHOLD = 0.7

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including object access frequency, object size, and a timestamp of the last access. It also keeps track of the current system load and resource utilization.
access_frequency = {}
last_access_timestamp = {}
system_load = 0

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy admits an object into the cache if it is frequently accessed, has a smaller size relative to the cache capacity, and the system load is below a certain threshold. Objects that are critical for real-time processing are prioritized.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = False
    
    # Check if the object is frequently accessed
    freq = access_frequency.get(obj.key, 0)
    if freq >= FREQUENCY_THRESHOLD:
        # Check if the object size is small relative to the cache capacity
        if obj.size <= cache_snapshot.capacity * SIZE_THRESHOLD_RATIO:
            # Check if the system load is below the threshold
            if system_load < SYSTEM_LOAD_THRESHOLD:
                should_admit = True
    
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the policy updates the access frequency count, records the current timestamp, and adjusts the system load and resource utilization metrics to reflect the new state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    # Update access frequency count
    access_frequency[obj.key] = access_frequency.get(obj.key, 0) + 1
    
    # Record the current timestamp
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    
    # Adjust system load and resource utilization metrics
    global system_load
    system_load = cache_snapshot.size / cache_snapshot.capacity

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the policy updates the access frequency count and records the current timestamp to monitor future access patterns. It also checks and updates the system load and resource utilization metrics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    # Update access frequency count
    access_frequency[obj.key] = access_frequency.get(obj.key, 0) + 1
    
    # Record the current timestamp
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    
    # Check and update system load and resource utilization metrics
    global system_load
    system_load = cache_snapshot.size / cache_snapshot.capacity

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    When a cache hit occurs, the policy increments the access frequency count, updates the last access timestamp, and recalculates the system load and resource utilization to ensure optimal performance and resource scaling.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Increment the access frequency count
    access_frequency[obj.key] = access_frequency.get(obj.key, 0) + 1
    
    # Update the last access timestamp
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    
    # Recalculate the system load and resource utilization
    global system_load
    system_load = cache_snapshot.size / cache_snapshot.capacity