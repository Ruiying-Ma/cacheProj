# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
REPLICATION_FACTOR_THRESHOLD = 3
CONSISTENCY_SCORE_THRESHOLD = 0.7
FAILURE_DETECTION_COUNT_THRESHOLD = 2
RESOURCE_ALLOCATION_PRIORITY_THRESHOLD = 0.5
ADMISSION_PROBABILITY = 0.5
GHOST_LRU_CAPACITY = 100

# Put the metadata specifically maintained by the policy below. The policy maintains a ghost LRU queue with a limited capacity, replication factor, consistency score, failure detection count, and resource allocation priority for each object.
ghost_lru_queue = []
metadata = {}

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    An object is admitted if it is in the ghost LRU queue or if its replication factor is below a threshold, its consistency score is high, its failure detection count is low, and it has a high resource allocation priority. If not in the ghost LRU queue, admission is also based on a predetermined probability.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = False
    obj_key = obj.key

    if obj_key in ghost_lru_queue:
        should_admit = True
    else:
        obj_metadata = metadata.get(obj_key, {
            'replication_factor': 0,
            'consistency_score': 0.5,
            'failure_detection_count': 0,
            'resource_allocation_priority': 0.5
        })

        if (obj_metadata['replication_factor'] < REPLICATION_FACTOR_THRESHOLD and
            obj_metadata['consistency_score'] >= CONSISTENCY_SCORE_THRESHOLD and
            obj_metadata['failure_detection_count'] <= FAILURE_DETECTION_COUNT_THRESHOLD and
            obj_metadata['resource_allocation_priority'] >= RESOURCE_ALLOCATION_PRIORITY_THRESHOLD):
            should_admit = True
        else:
            should_admit = False

    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Remove the object from the ghost LRU queue if it exists there. Increment the replication factor, recalculate the consistency score, reset the failure detection count, and adjust the resource allocation priority based on current cache load.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    obj_key = obj.key

    if obj_key in ghost_lru_queue:
        ghost_lru_queue.remove(obj_key)

    obj_metadata = metadata.get(obj_key, {
        'replication_factor': 0,
        'consistency_score': 0.5,
        'failure_detection_count': 0,
        'resource_allocation_priority': 0.5
    })

    obj_metadata['replication_factor'] += 1
    obj_metadata['consistency_score'] = min(1.0, obj_metadata['consistency_score'] + 0.1)
    obj_metadata['failure_detection_count'] = 0
    obj_metadata['resource_allocation_priority'] = min(1.0, obj_metadata['resource_allocation_priority'] + 0.1 * (cache_snapshot.size / cache_snapshot.capacity))

    metadata[obj_key] = obj_metadata

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    Add the object to the MRU end of the ghost LRU queue. If this exceeds the queue's capacity, remove the LRU object. Decrease the consistency score slightly, increment the failure detection count, and lower the resource allocation priority.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    obj_key = obj.key

    if obj_key in ghost_lru_queue:
        ghost_lru_queue.remove(obj_key)
    ghost_lru_queue.append(obj_key)

    if len(ghost_lru_queue) > GHOST_LRU_CAPACITY:
        ghost_lru_queue.pop(0)

    obj_metadata = metadata.get(obj_key, {
        'replication_factor': 0,
        'consistency_score': 0.5,
        'failure_detection_count': 0,
        'resource_allocation_priority': 0.5
    })

    obj_metadata['consistency_score'] = max(0.0, obj_metadata['consistency_score'] - 0.1)
    obj_metadata['failure_detection_count'] += 1
    obj_metadata['resource_allocation_priority'] = max(0.0, obj_metadata['resource_allocation_priority'] - 0.1)

    metadata[obj_key] = obj_metadata

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    Decrease the ghost LRU queue's capacity. Increment the replication factor, boost the consistency score, reset the failure detection count, and increase the resource allocation priority.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global GHOST_LRU_CAPACITY
    GHOST_LRU_CAPACITY = max(1, GHOST_LRU_CAPACITY - 1)

    obj_key = obj.key
    obj_metadata = metadata.get(obj_key, {
        'replication_factor': 0,
        'consistency_score': 0.5,
        'failure_detection_count': 0,
        'resource_allocation_priority': 0.5
    })

    obj_metadata['replication_factor'] += 1
    obj_metadata['consistency_score'] = min(1.0, obj_metadata['consistency_score'] + 0.2)
    obj_metadata['failure_detection_count'] = 0
    obj_metadata['resource_allocation_priority'] = min(1.0, obj_metadata['resource_allocation_priority'] + 0.2)

    metadata[obj_key] = obj_metadata