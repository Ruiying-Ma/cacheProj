# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
FREQUENCY_THRESHOLD = 5
REDUNDANCY_THRESHOLD = 1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for object frequency, object size, redundancy count, and load distribution metrics across cache nodes.
object_frequency = {}
object_redundancy = {}
load_distribution = {}
object_sizes = {}

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy admits an object if it is frequently accessed, has a unique redundancy count, and fits within the current load distribution strategy to ensure balanced storage efficiency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = False
    
    # Check if the object is frequently accessed
    freq = object_frequency.get(obj.key, 0)
    if freq < FREQUENCY_THRESHOLD:
        return should_admit
    
    # Check if the object has a unique redundancy count
    redundancy = object_redundancy.get(obj.key, 0)
    if redundancy > REDUNDANCY_THRESHOLD:
        return should_admit
    
    # Check if the object fits within the current load distribution strategy
    current_load = cache_snapshot.size
    if current_load + obj.size > cache_snapshot.capacity:
        return should_admit
    
    should_admit = True
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the policy increments the frequency count, updates the redundancy count, adjusts the load distribution metrics, and records the object size to maintain storage efficiency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    # Increment the frequency count
    object_frequency[obj.key] = object_frequency.get(obj.key, 0) + 1
    
    # Update the redundancy count
    object_redundancy[obj.key] = object_redundancy.get(obj.key, 0) + 1
    
    # Adjust the load distribution metrics
    load_distribution[obj.key] = load_distribution.get(obj.key, 0) + obj.size
    
    # Record the object size
    object_sizes[obj.key] = obj.size

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the policy increments the frequency count and updates the redundancy count to track potential future admissions, while also adjusting load distribution metrics to reflect the decision.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    # Increment the frequency count
    object_frequency[obj.key] = object_frequency.get(obj.key, 0) + 1
    
    # Update the redundancy count
    object_redundancy[obj.key] = object_redundancy.get(obj.key, 0) + 1
    
    # Adjust the load distribution metrics
    load_distribution[obj.key] = load_distribution.get(obj.key, 0) + obj.size

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the frequency count for the object, updates the redundancy count if necessary, and recalculates load distribution metrics to ensure ongoing balance and efficiency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Increment the frequency count
    object_frequency[obj.key] = object_frequency.get(obj.key, 0) + 1
    
    # Update the redundancy count if necessary
    object_redundancy[obj.key] = object_redundancy.get(obj.key, 0) + 1
    
    # Recalculate load distribution metrics
    load_distribution[obj.key] = load_distribution.get(obj.key, 0) + obj.size