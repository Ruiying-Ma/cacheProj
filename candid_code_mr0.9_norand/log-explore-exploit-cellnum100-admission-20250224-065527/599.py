# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
INITIAL_RELEVANCE_THRESHOLD = 0.5
EDGE_DEVICE_PRIORITY = 1.2
HIGH_PRIORITY_USER = 1.5

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including object access frequency, object size, and a relevance score derived from natural language processing analysis of the object's content. It also tracks the object's source (edge device or central server) and user identity (using federated identity management).
metadata = {
    'access_frequency': {},
    'object_size': {},
    'relevance_score': {},
    'source': {},
    'user_identity': {},
    'dynamic_threshold': INITIAL_RELEVANCE_THRESHOLD
}

def calculate_relevance_score(obj):
    # Placeholder for actual NLP-based relevance score calculation
    return 0.5  # This should be replaced with actual NLP analysis

def get_source_priority(source):
    return EDGE_DEVICE_PRIORITY if source == 'edge_device' else 1.0

def get_user_priority(user_identity):
    return HIGH_PRIORITY_USER if user_identity == 'high_priority' else 1.0

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy admits an object if its relevance score exceeds a dynamic threshold, which is adjusted based on the current cache load and the importance of the object's source and user identity. Objects from edge devices or high-priority users are given preference.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = False
    
    # Calculate relevance score
    relevance_score = calculate_relevance_score(obj)
    
    # Get source and user priority
    source_priority = get_source_priority(metadata['source'].get(obj.key, 'central_server'))
    user_priority = get_user_priority(metadata['user_identity'].get(obj.key, 'normal_user'))
    
    # Adjusted relevance score
    adjusted_relevance_score = relevance_score * source_priority * user_priority
    
    # Check if the object should be admitted
    if adjusted_relevance_score > metadata['dynamic_threshold']:
        should_admit = True
    
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the policy updates the access frequency to 1, records the object size, calculates and stores the relevance score, and logs the source and user identity. The dynamic threshold for relevance score is recalibrated based on the new cache load.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    # Update metadata
    metadata['access_frequency'][obj.key] = 1
    metadata['object_size'][obj.key] = obj.size
    metadata['relevance_score'][obj.key] = calculate_relevance_score(obj)
    metadata['source'][obj.key] = 'edge_device'  # Placeholder, should be actual source
    metadata['user_identity'][obj.key] = 'high_priority'  # Placeholder, should be actual user identity
    
    # Recalibrate dynamic threshold
    cache_load = cache_snapshot.size / cache_snapshot.capacity
    metadata['dynamic_threshold'] = INITIAL_RELEVANCE_THRESHOLD * (1 + cache_load)

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the policy updates the dynamic threshold for relevance score based on the current cache load and the characteristics of the rejected object, such as its relevance score, source, and user identity.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    # Calculate relevance score
    relevance_score = calculate_relevance_score(obj)
    
    # Get source and user priority
    source_priority = get_source_priority(metadata['source'].get(obj.key, 'central_server'))
    user_priority = get_user_priority(metadata['user_identity'].get(obj.key, 'normal_user'))
    
    # Adjusted relevance score
    adjusted_relevance_score = relevance_score * source_priority * user_priority
    
    # Recalibrate dynamic threshold
    cache_load = cache_snapshot.size / cache_snapshot.capacity
    metadata['dynamic_threshold'] = max(INITIAL_RELEVANCE_THRESHOLD, adjusted_relevance_score * (1 + cache_load))

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the access frequency of the object, re-evaluates and updates the relevance score using natural language processing, and adjusts the dynamic threshold for relevance score based on the updated cache state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Increment access frequency
    metadata['access_frequency'][obj.key] += 1
    
    # Re-evaluate and update relevance score
    metadata['relevance_score'][obj.key] = calculate_relevance_score(obj)
    
    # Recalibrate dynamic threshold
    cache_load = cache_snapshot.size / cache_snapshot.capacity
    metadata['dynamic_threshold'] = INITIAL_RELEVANCE_THRESHOLD * (1 + cache_load)