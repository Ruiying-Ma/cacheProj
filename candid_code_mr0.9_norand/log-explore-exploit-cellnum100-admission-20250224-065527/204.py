# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
THROUGHPUT_THRESHOLD = 100  # Example threshold for transaction throughput
LATENCY_THRESHOLD = 50  # Example threshold for synchronization latency
LOAD_THRESHOLD = 80  # Example threshold for load distribution

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for data shards, transaction throughput, synchronization latency, and load distribution. Each shard has counters for transaction counts and latency measurements, and a load distribution map is maintained to track the load on each shard.
shard_metadata = {
    'transaction_counts': {},  # Dictionary to store transaction counts per shard
    'latency_measurements': {},  # Dictionary to store latency measurements per shard
    'load_distribution': {}  # Dictionary to store load distribution per shard
}

def get_shard(obj):
    # Example function to determine the shard of an object
    # This is a placeholder and should be replaced with actual logic to determine the shard
    return obj.key[0]  # Assuming the first character of the key determines the shard

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy admits an object into the cache if the transaction throughput for its shard is below a certain threshold and the synchronization latency is within acceptable limits. Additionally, the load distribution map is checked to ensure the shard is not overloaded.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    shard = get_shard(obj)
    transaction_count = shard_metadata['transaction_counts'].get(shard, 0)
    latency = shard_metadata['latency_measurements'].get(shard, 0)
    load = shard_metadata['load_distribution'].get(shard, 0)

    if transaction_count < THROUGHPUT_THRESHOLD and latency < LATENCY_THRESHOLD and load < LOAD_THRESHOLD:
        should_admit = True
    else:
        should_admit = False
    
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the transaction count for the corresponding shard is incremented, the synchronization latency is updated with the latest measurement, and the load distribution map is adjusted to reflect the new load on the shard.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    shard = get_shard(obj)
    shard_metadata['transaction_counts'][shard] = shard_metadata['transaction_counts'].get(shard, 0) + 1
    shard_metadata['latency_measurements'][shard] = cache_snapshot.access_count  # Example latency update
    shard_metadata['load_distribution'][shard] = shard_metadata['load_distribution'].get(shard, 0) + obj.size

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the transaction count for the corresponding shard is still incremented to track attempted transactions, and the synchronization latency is updated. The load distribution map remains unchanged.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    shard = get_shard(obj)
    shard_metadata['transaction_counts'][shard] = shard_metadata['transaction_counts'].get(shard, 0) + 1
    shard_metadata['latency_measurements'][shard] = cache_snapshot.access_count  # Example latency update

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    When a cache hit occurs, the transaction count for the corresponding shard is incremented, the synchronization latency is updated with the latest measurement, and the load distribution map is adjusted to reflect the current load on the shard.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    shard = get_shard(obj)
    shard_metadata['transaction_counts'][shard] = shard_metadata['transaction_counts'].get(shard, 0) + 1
    shard_metadata['latency_measurements'][shard] = cache_snapshot.access_count  # Example latency update
    shard_metadata['load_distribution'][shard] = shard_metadata['load_distribution'].get(shard, 0) + obj.size