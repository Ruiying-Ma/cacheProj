# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
HIGH_ACCESS_FREQUENCY_THRESHOLD = 10
LOW_BANDWIDTH_USAGE_THRESHOLD = 100
SUFFICIENT_VM_RESOURCES_THRESHOLD = 50

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for data shards, including access frequency, last access time, and bandwidth usage. It also tracks virtual machine (VM) resource utilization and cache occupancy.
metadata = {
    'access_frequency': {},  # {obj.key: frequency}
    'last_access_time': {},  # {obj.key: last_access_time}
    'bandwidth_usage': {},   # {obj.key: bandwidth_usage}
    'vm_resources': {},      # {obj.key: vm_resources}
    'cache_occupancy': 0     # current cache occupancy count
}

def admit(cache_snapshot, obj, key_to_be_evicted):
    '''
    This function defines how the policy determines whether an object should be admitted into the cache.
    The policy admits an object if its data shard has a high access frequency, low bandwidth usage, and the VM managing the shard has sufficient resources. It also considers the current cache occupancy to avoid overloading.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object being requested.
        - `key_to_be_evicted`: The key of the object in the cache that may be evicted if the currently requested object is admitted and triggers an eviction. If no admission occurs or if admission does not cause an eviction, this is set to `None`.
    - Return:
        - `should_admit`: A boolean value indicating whether the requested object should be admitted into the cache. If `True`, the object is admitted; if `False`, it is not.
    '''
    should_admit = False
    
    # Check access frequency
    access_frequency = metadata['access_frequency'].get(obj.key, 0)
    if access_frequency < HIGH_ACCESS_FREQUENCY_THRESHOLD:
        return should_admit
    
    # Check bandwidth usage
    bandwidth_usage = metadata['bandwidth_usage'].get(obj.key, 0)
    if bandwidth_usage > LOW_BANDWIDTH_USAGE_THRESHOLD:
        return should_admit
    
    # Check VM resources
    vm_resources = metadata['vm_resources'].get(obj.key, 0)
    if vm_resources < SUFFICIENT_VM_RESOURCES_THRESHOLD:
        return should_admit
    
    # Check cache occupancy
    if cache_snapshot.size + obj.size > cache_snapshot.capacity:
        return should_admit
    
    should_admit = True
    return should_admit

def update_after_admit(cache_snapshot, obj):
    '''
    This function defines how the policy update **each** of the metadata it maintains immediately after it decides to admit an object into the cache.
    Upon admitting an object, the policy updates the access frequency and last access time for the corresponding data shard. It also adjusts the bandwidth usage and VM resource utilization metrics, and increments the cache occupancy count.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just admitted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = metadata['access_frequency'].get(key, 0) + 1
    metadata['last_access_time'][key] = cache_snapshot.access_count
    metadata['bandwidth_usage'][key] = metadata['bandwidth_usage'].get(key, 0) + obj.size
    metadata['vm_resources'][key] = metadata['vm_resources'].get(key, 0) + 1
    metadata['cache_occupancy'] += 1

def update_after_not_admit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after it decides **not** to admit an object into the cache.
    If an object is not admitted, the policy updates the access frequency and last access time for the corresponding data shard to reflect the attempted access. It also logs the bandwidth usage and VM resource status without changing the cache occupancy.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just denied admission to the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = metadata['access_frequency'].get(key, 0) + 1
    metadata['last_access_time'][key] = cache_snapshot.access_count
    metadata['bandwidth_usage'][key] = metadata['bandwidth_usage'].get(key, 0) + obj.size
    metadata['vm_resources'][key] = metadata['vm_resources'].get(key, 0) + 1

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates **each** of the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access frequency and last access time for the corresponding data shard. It also recalculates the bandwidth usage and VM resource utilization to ensure optimal performance, without altering the cache occupancy.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = metadata['access_frequency'].get(key, 0) + 1
    metadata['last_access_time'][key] = cache_snapshot.access_count
    metadata['bandwidth_usage'][key] = metadata['bandwidth_usage'].get(key, 0) + obj.size
    metadata['vm_resources'][key] = metadata['vm_resources'].get(key, 0) + 1