# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
DEFAULT_PGV = 0.5  # Default Predictive Gradient Vector for new objects
DEFAULT_TE = 1.0   # Default Temporal Entropy for new objects
CSM_TIERS = 3      # Number of Cognitive State Map tiers
AV_WEIGHTS = [0.5, 0.3, 0.2]  # Weights for PGV, TE, and CSM tier respectively

# Put the metadata specifically maintained by the policy below. The policy maintains a Predictive Gradient Vector (PGV) for each object, representing its likelihood of future access based on past access patterns. It also tracks Temporal Entropy (TE) to measure the unpredictability of access intervals and a Cognitive State Map (CSM) to group objects into dynamic priority tiers based on their access behavior. An Adaptive Vector (AV) adjusts the weight of these factors over time to optimize eviction decisions.
metadata = {
    "pgv": {},  # Predictive Gradient Vector for each object (key -> PGV value)
    "te": {},   # Temporal Entropy for each object (key -> TE value)
    "csm": {},  # Cognitive State Map tier for each object (key -> tier index)
    "last_access": {},  # Last access time for each object (key -> access_count)
    "av_weights": AV_WEIGHTS,  # Adaptive Vector weights
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by identifying the object with the lowest combined score derived from its PGV, TE, and CSM tier. The Adaptive Vector dynamically adjusts the weight of each factor to prioritize objects with low future access probability, high entropy, and low cognitive priority.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate the combined score for each object
        pgv = metadata["pgv"].get(key, DEFAULT_PGV)
        te = metadata["te"].get(key, DEFAULT_TE)
        csm_tier = metadata["csm"].get(key, CSM_TIERS - 1)  # Default to lowest priority tier
        score = (
            metadata["av_weights"][0] * pgv +
            metadata["av_weights"][1] * te +
            metadata["av_weights"][2] * csm_tier
        )
        # Select the object with the lowest score
        if score < min_score:
            min_score = score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the PGV of the accessed object is updated using a gradient synthesis algorithm to predict its next access likelihood. The TE is recalculated to reflect the updated access interval, and the CSM is adjusted to potentially move the object to a higher priority tier. The AV is fine-tuned based on the overall cache performance metrics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update PGV using a gradient synthesis algorithm
    last_access = metadata["last_access"].get(key, current_time)
    interval = current_time - last_access
    metadata["pgv"][key] = 1 / (1 + math.exp(-interval))  # Example gradient synthesis

    # Update TE to reflect the updated access interval
    metadata["te"][key] = -math.log(1 / (interval + 1))  # Example entropy calculation

    # Adjust CSM tier based on access behavior
    if metadata["pgv"][key] > 0.7:  # Example threshold for high priority
        metadata["csm"][key] = 0  # Move to highest priority tier
    elif metadata["pgv"][key] > 0.4:
        metadata["csm"][key] = 1  # Move to medium priority tier
    else:
        metadata["csm"][key] = 2  # Move to lowest priority tier

    # Update last access time
    metadata["last_access"][key] = current_time

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, an initial PGV is assigned based on recent access trends, and its TE is initialized to a neutral value. The object is placed in a default CSM tier, and the AV is updated to account for the new object's impact on the cache's overall dynamics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Assign initial PGV and TE
    metadata["pgv"][key] = DEFAULT_PGV
    metadata["te"][key] = DEFAULT_TE

    # Place object in default CSM tier
    metadata["csm"][key] = CSM_TIERS - 1  # Default to lowest priority tier

    # Update last access time
    metadata["last_access"][key] = current_time

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the PGVs of remaining objects are recalibrated to account for the removal. The TE of neighboring objects is adjusted to reflect the change in access patterns, and the CSM tiers are rebalanced if necessary. The AV is updated to learn from the eviction decision and improve future predictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Remove metadata for the evicted object
    metadata["pgv"].pop(evicted_key, None)
    metadata["te"].pop(evicted_key, None)
    metadata["csm"].pop(evicted_key, None)
    metadata["last_access"].pop(evicted_key, None)

    # Recalibrate PGVs and TEs for remaining objects
    for key in cache_snapshot.cache.keys():
        metadata["pgv"][key] *= 0.9  # Example decay factor
        metadata["te"][key] *= 1.1  # Example adjustment for increased uncertainty

    # Rebalance CSM tiers if necessary
    for key in cache_snapshot.cache.keys():
        if metadata["pgv"][key] > 0.7:
            metadata["csm"][key] = 0
        elif metadata["pgv"][key] > 0.4:
            metadata["csm"][key] = 1
        else:
            metadata["csm"][key] = 2