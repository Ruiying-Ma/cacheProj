# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
PHM_DECAY_RATE = 0.9  # Decay rate for Predictive Heuristic Map
CDS_NEUTRAL_VALUE = 0.5  # Neutral value for Causal Drift Score
ELI_INITIAL_VALUE = 1.0  # Initial Entropic Layering Index value
TNC_DECAY_RATE = 0.95  # Decay rate for Temporal Node Calibration

# Put the metadata specifically maintained by the policy below. The policy maintains a Predictive Heuristic Map (PHM) for access patterns, a Causal Drift Score (CDS) to track shifts in usage trends, Temporal Node Calibration (TNC) timestamps for recency and frequency, and an Entropic Layering Index (ELI) to measure the randomness of access patterns for each object.
PHM = {}  # Predictive Heuristic Map: {key: score}
CDS = {}  # Causal Drift Score: {key: score}
TNC = {}  # Temporal Node Calibration: {key: timestamp}
ELI = {}  # Entropic Layering Index: {key: score}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    '''
    candid_obj_key = None
    min_combined_score = math.inf

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate combined score
        phm_score = PHM.get(key, 0)
        cds_score = CDS.get(key, CDS_NEUTRAL_VALUE)
        tnc_score = cache_snapshot.access_count - TNC.get(key, 0)
        eli_score = ELI.get(key, ELI_INITIAL_VALUE)
        combined_score = phm_score + cds_score + tnc_score + eli_score

        # Find the object with the lowest combined score
        if combined_score < min_combined_score:
            min_combined_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key

    # Update PHM to reinforce predicted access pattern
    PHM[key] = PHM.get(key, 0) + 1

    # Recalibrate CDS to reflect alignment with current trends
    CDS[key] = CDS.get(key, CDS_NEUTRAL_VALUE) * PHM_DECAY_RATE + 1

    # Refresh TNC timestamp to mark recency
    TNC[key] = cache_snapshot.access_count

    # Adjust ELI to reflect reduced randomness
    ELI[key] = max(ELI.get(key, ELI_INITIAL_VALUE) * TNC_DECAY_RATE, 0)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key

    # Update PHM to include the new access pattern
    PHM[key] = 1

    # Initialize CDS to a neutral value
    CDS[key] = CDS_NEUTRAL_VALUE

    # Set TNC timestamp to the current time
    TNC[key] = cache_snapshot.access_count

    # Calculate ELI based on the initial observed randomness
    ELI[key] = ELI_INITIAL_VALUE

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key

    # Prune PHM to remove the evicted object's access pattern
    if evicted_key in PHM:
        del PHM[evicted_key]

    # Adjust CDS to reflect the removal of the evicted object's influence
    if evicted_key in CDS:
        del CDS[evicted_key]

    # Discard TNC for the evicted object
    if evicted_key in TNC:
        del TNC[evicted_key]

    # Recalibrate ELI for remaining objects
    for key in ELI:
        ELI[key] = max(ELI[key] * TNC_DECAY_RATE, 0)