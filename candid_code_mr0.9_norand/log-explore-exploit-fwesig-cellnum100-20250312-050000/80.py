# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
COHESION_INCREMENT = 0.05
DEFAULT_COHESION_SCORE = 0.5
DEFAULT_PREDICTIVE_SYNCHRONICITY_SCORE = 0.5
DEFAULT_DYNAMIC_LATENCY_WEIGHT = 1.0
DEFAULT_ENTROPIC_PRIORITY_INDEX = 1.0
LATENCY_DECAY_FACTOR = 0.9
ENTROPY_ADJUSTMENT_FACTOR = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cache entry, including a Cohesion Score (measuring how often the entry is accessed alongside others), a Predictive Synchronicity Score (forecasting future access patterns based on historical trends), a Dynamic Latency Weight (tracking the time-sensitivity of the entry), and an Entropic Priority Index (quantifying the randomness of access patterns to balance stability and adaptability).
metadata = defaultdict(lambda: {
    "cohesion_score": DEFAULT_COHESION_SCORE,
    "predictive_synchronicity_score": DEFAULT_PREDICTIVE_SYNCHRONICITY_SCORE,
    "dynamic_latency_weight": DEFAULT_DYNAMIC_LATENCY_WEIGHT,
    "entropic_priority_index": DEFAULT_ENTROPIC_PRIORITY_INDEX,
    "last_access_time": 0
})

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by calculating a composite score for each entry using a weighted formula: (1 - Cohesion Score) + (1 - Predictive Synchronicity Score) + Dynamic Latency Weight + Entropic Priority Index. The entry with the highest composite score is evicted, prioritizing low cohesion, low predictability, high latency sensitivity, and high entropy.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    max_composite_score = float('-inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        meta = metadata[key]
        composite_score = (
            (1 - meta["cohesion_score"]) +
            (1 - meta["predictive_synchronicity_score"]) +
            meta["dynamic_latency_weight"] +
            meta["entropic_priority_index"]
        )
        if composite_score > max_composite_score:
            max_composite_score = composite_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the Cohesion Score of the accessed entry is increased slightly, the Predictive Synchronicity Score is updated based on the observed access pattern, the Dynamic Latency Weight is recalibrated to reflect the time since the last access, and the Entropic Priority Index is adjusted to reflect the reduced randomness of the access pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    meta = metadata[obj.key]
    meta["cohesion_score"] = min(1.0, meta["cohesion_score"] + COHESION_INCREMENT)
    meta["predictive_synchronicity_score"] = min(1.0, meta["predictive_synchronicity_score"] + COHESION_INCREMENT)
    meta["dynamic_latency_weight"] = LATENCY_DECAY_FACTOR * (cache_snapshot.access_count - meta["last_access_time"])
    meta["entropic_priority_index"] = max(0.0, meta["entropic_priority_index"] - ENTROPY_ADJUSTMENT_FACTOR)
    meta["last_access_time"] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the Cohesion Score is initialized to a neutral value, the Predictive Synchronicity Score is seeded based on recent access trends, the Dynamic Latency Weight is set to a default value reflecting average latency sensitivity, and the Entropic Priority Index is initialized to a high value to account for initial uncertainty.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    metadata[obj.key] = {
        "cohesion_score": DEFAULT_COHESION_SCORE,
        "predictive_synchronicity_score": DEFAULT_PREDICTIVE_SYNCHRONICITY_SCORE,
        "dynamic_latency_weight": DEFAULT_DYNAMIC_LATENCY_WEIGHT,
        "entropic_priority_index": DEFAULT_ENTROPIC_PRIORITY_INDEX,
        "last_access_time": cache_snapshot.access_count
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an entry, the Cohesion Scores of remaining entries are recalculated to reflect the removal of the evicted entry, the Predictive Synchronicity Scores are updated to account for the altered access patterns, the Dynamic Latency Weights are normalized to maintain balance, and the Entropic Priority Indices are adjusted to reflect the increased randomness introduced by the eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    del metadata[evicted_obj.key]
    
    for key, meta in metadata.items():
        meta["cohesion_score"] = max(0.0, meta["cohesion_score"] - COHESION_INCREMENT)
        meta["predictive_synchronicity_score"] = max(0.0, meta["predictive_synchronicity_score"] - COHESION_INCREMENT)
        meta["dynamic_latency_weight"] *= LATENCY_DECAY_FACTOR
        meta["entropic_priority_index"] = min(1.0, meta["entropic_priority_index"] + ENTROPY_ADJUSTMENT_FACTOR)