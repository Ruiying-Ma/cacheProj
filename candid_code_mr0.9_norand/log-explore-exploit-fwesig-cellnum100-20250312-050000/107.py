# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
DEFAULT_PI = 1.0
DEFAULT_LD = 1.0
DEFAULT_SP = 1.0
DEFAULT_FREQUENCY = 1
DEFAULT_RECENCY = 0
DEFAULT_COHERENCE = 1.0
DEFAULT_WRITE_LATENCY = 1.0
DEFAULT_ACCESS_ARBITRATION = 1.0
DEFAULT_PAGE_SWAP_FREQUENCY = 1.0
DEFAULT_PROBABILISTIC_SCORE = 1.0

# Put the metadata specifically maintained by the policy below. The policy maintains a Unified Predictive Score (UPS) that combines Predictive Index (PI), Latency Dynamics (LD), Sequential Prioritization (SP), and a Composite Access Score (CAS) derived from frequency, recency, coherence, write latency, access arbitration, page swap frequency, and probabilistic metrics. It also tracks a Dynamic Weight Matrix (DWM) to adjust the importance of each component in UPS and archives metadata of evicted objects for future modeling.
metadata = {
    "PI": defaultdict(lambda: DEFAULT_PI),
    "LD": defaultdict(lambda: DEFAULT_LD),
    "SP": defaultdict(lambda: DEFAULT_SP),
    "frequency": defaultdict(lambda: DEFAULT_FREQUENCY),
    "recency": defaultdict(lambda: DEFAULT_RECENCY),
    "coherence": defaultdict(lambda: DEFAULT_COHERENCE),
    "write_latency": defaultdict(lambda: DEFAULT_WRITE_LATENCY),
    "access_arbitration": defaultdict(lambda: DEFAULT_ACCESS_ARBITRATION),
    "page_swap_frequency": defaultdict(lambda: DEFAULT_PAGE_SWAP_FREQUENCY),
    "probabilistic_score": defaultdict(lambda: DEFAULT_PROBABILISTIC_SCORE),
    "UPS": defaultdict(float),
    "DWM": {
        "PI": 1.0,
        "LD": 1.0,
        "SP": 1.0,
        "CAS": 1.0
    },
    "evicted_metadata": []
}

def calculate_CAS(key):
    """Calculate the Composite Access Score (CAS) for a given object key."""
    return (
        metadata["frequency"][key] +
        metadata["recency"][key] +
        metadata["coherence"][key] +
        metadata["write_latency"][key] +
        metadata["access_arbitration"][key] +
        metadata["page_swap_frequency"][key] +
        metadata["probabilistic_score"][key]
    )

def calculate_UPS(key):
    """Calculate the Unified Predictive Score (UPS) for a given object key."""
    CAS = calculate_CAS(key)
    return (
        metadata["DWM"]["PI"] * metadata["PI"][key] +
        metadata["DWM"]["LD"] * metadata["LD"][key] +
        metadata["DWM"]["SP"] * metadata["SP"][key] +
        metadata["DWM"]["CAS"] * CAS
    )

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    '''
    candid_obj_key = None
    min_HES = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        UPS = calculate_UPS(key)
        LHM = metadata["LD"][key]  # Latency Harmonization Metrics
        HES = UPS + LHM

        if HES < min_HES or (HES == min_HES and metadata["coherence"][key] < metadata["coherence"].get(candid_obj_key, float('inf'))):
            min_HES = HES
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    metadata["PI"][key] += 1  # Increase Predictive Index
    metadata["LD"][key] *= 0.9  # Recalibrate Latency Dynamics
    metadata["SP"][key] += 1  # Update Sequential Prioritization
    metadata["frequency"][key] += 1
    metadata["recency"][key] = cache_snapshot.access_count
    metadata["coherence"][key] *= 1.1
    metadata["write_latency"][key] *= 0.95
    metadata["access_arbitration"][key] *= 1.05
    metadata["probabilistic_score"][key] *= 1.02
    metadata["UPS"][key] = calculate_UPS(key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    metadata["PI"][key] = DEFAULT_PI
    metadata["LD"][key] = DEFAULT_LD
    metadata["SP"][key] = DEFAULT_SP
    metadata["frequency"][key] = DEFAULT_FREQUENCY
    metadata["recency"][key] = cache_snapshot.access_count
    metadata["coherence"][key] = DEFAULT_COHERENCE
    metadata["write_latency"][key] = DEFAULT_WRITE_LATENCY
    metadata["access_arbitration"][key] = DEFAULT_ACCESS_ARBITRATION
    metadata["page_swap_frequency"][key] = DEFAULT_PAGE_SWAP_FREQUENCY
    metadata["probabilistic_score"][key] = DEFAULT_PROBABILISTIC_SCORE
    metadata["UPS"][key] = calculate_UPS(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key
    metadata["evicted_metadata"].append({
        "key": evicted_key,
        "PI": metadata["PI"].pop(evicted_key, None),
        "LD": metadata["LD"].pop(evicted_key, None),
        "SP": metadata["SP"].pop(evicted_key, None),
        "frequency": metadata["frequency"].pop(evicted_key, None),
        "recency": metadata["recency"].pop(evicted_key, None),
        "coherence": metadata["coherence"].pop(evicted_key, None),
        "write_latency": metadata["write_latency"].pop(evicted_key, None),
        "access_arbitration": metadata["access_arbitration"].pop(evicted_key, None),
        "page_swap_frequency": metadata["page_swap_frequency"].pop(evicted_key, None),
        "probabilistic_score": metadata["probabilistic_score"].pop(evicted_key, None),
        "UPS": metadata["UPS"].pop(evicted_key, None)
    })

    # Recalibrate LHM and adjust DWM
    for key in cache_snapshot.cache:
        metadata["LD"][key] *= 1.1  # Redistribute latency impact
        metadata["UPS"][key] = calculate_UPS(key)