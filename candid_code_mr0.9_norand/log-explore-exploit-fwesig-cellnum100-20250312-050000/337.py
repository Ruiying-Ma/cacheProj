# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
NEUTRAL_AGS = 1.0  # Neutral starting value for AGS
INITIAL_SPS = 1.0  # Initial semantic priority score
PEM_DECAY = 0.9    # Decay factor for weakening PEM entanglements
RTM_WINDOW = 5     # Number of recent accesses to track in RTM

# Put the metadata specifically maintained by the policy below. The policy maintains a recursive temporal map (RTM) that tracks access patterns over multiple time scales, an adaptive gradient score (AGS) that adjusts based on recent access trends, a probabilistic entanglement matrix (PEM) that links related objects based on co-access likelihood, and a semantic priority score (SPS) derived from object-specific importance metrics.
RTM = defaultdict(deque)  # Tracks recent access times for each object
AGS = defaultdict(lambda: NEUTRAL_AGS)  # Tracks adaptive gradient scores
PEM = defaultdict(lambda: defaultdict(float))  # Tracks entanglement strengths
SPS = defaultdict(lambda: INITIAL_SPS)  # Tracks semantic priority scores

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by combining the AGS and SPS to prioritize objects with low recent access trends and low semantic importance, while using the PEM to avoid evicting objects strongly entangled with frequently accessed ones.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Compute eviction score: lower AGS and SPS are prioritized
        score = AGS[key] + SPS[key]

        # Penalize objects strongly entangled with frequently accessed ones
        for other_key in cache_snapshot.cache:
            if other_key != key:
                score += PEM[key][other_key] * AGS[other_key]

        # Select the object with the lowest score
        if score < min_score:
            min_score = score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the RTM is updated to reflect the new temporal access pattern, the AGS is incrementally adjusted to reflect the increased access frequency, the PEM strengthens links between the accessed object and others accessed in close temporal proximity, and the SPS is recalibrated if the hit indicates a higher semantic importance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Update RTM with the current access time
    RTM[obj.key].append(cache_snapshot.access_count)
    if len(RTM[obj.key]) > RTM_WINDOW:
        RTM[obj.key].popleft()

    # Incrementally adjust AGS to reflect increased access frequency
    AGS[obj.key] += 1

    # Strengthen PEM links with recently accessed objects
    for other_key in cache_snapshot.cache:
        if other_key != obj.key:
            PEM[obj.key][other_key] += 1
            PEM[other_key][obj.key] += 1

    # Recalibrate SPS if the hit indicates higher semantic importance
    SPS[obj.key] += 0.1  # Example adjustment for semantic importance

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the RTM initializes its temporal mapping, the AGS is set to a neutral starting value, the PEM establishes initial weak entanglements with recently accessed objects, and the SPS is computed based on the object's initial semantic priority.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Initialize RTM for the new object
    RTM[obj.key] = deque([cache_snapshot.access_count])

    # Set AGS to a neutral starting value
    AGS[obj.key] = NEUTRAL_AGS

    # Establish initial weak entanglements with recently accessed objects
    for other_key in cache_snapshot.cache:
        if other_key != obj.key:
            PEM[obj.key][other_key] = 0.1
            PEM[other_key][obj.key] = 0.1

    # Compute SPS based on the object's initial semantic priority
    SPS[obj.key] = INITIAL_SPS

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the RTM removes its temporal mapping, the AGS is redistributed to other objects to maintain balance, the PEM weakens or removes entanglements involving the evicted object, and the SPS is recalibrated for remaining objects to reflect the updated cache state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Remove RTM mapping for the evicted object
    if evicted_obj.key in RTM:
        del RTM[evicted_obj.key]

    # Redistribute AGS to maintain balance
    if evicted_obj.key in AGS:
        redistributed_ags = AGS[evicted_obj.key] / max(1, len(cache_snapshot.cache) - 1)
        for key in cache_snapshot.cache:
            if key != evicted_obj.key:
                AGS[key] += redistributed_ags
        del AGS[evicted_obj.key]

    # Weaken or remove PEM entanglements involving the evicted object
    if evicted_obj.key in PEM:
        for other_key in PEM[evicted_obj.key]:
            PEM[other_key][evicted_obj.key] *= PEM_DECAY
        del PEM[evicted_obj.key]

    for other_key in PEM:
        if evicted_obj.key in PEM[other_key]:
            PEM[other_key][evicted_obj.key] *= PEM_DECAY

    # Recalibrate SPS for remaining objects
    for key in cache_snapshot.cache:
        SPS[key] *= 0.95  # Example recalibration factor