# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
DEFAULT_ENTROPY = 1000  # Default high entropy for new objects
ADAPTIVE_GRADIENT_STEP = 0.1  # Step size for adaptive gradient tuning
TEMPORAL_RELATION_WEIGHT = 1.0  # Weight for temporal relationships in TFM
CONTEXTUAL_PROBABILITY_WEIGHT = 1.0  # Weight for contextual probabilities in PCE

# Put the metadata specifically maintained by the policy below. The policy maintains a Temporal Fusion Matrix (TFM) to track temporal access patterns between cache objects, a Probabilistic Context Encoding (PCE) vector to encode contextual access probabilities, an entropy score for each object to measure its access predictability, and an adaptive gradient value to fine-tune eviction thresholds dynamically.
TFM = defaultdict(lambda: defaultdict(float))  # Temporal Fusion Matrix
PCE = defaultdict(float)  # Probabilistic Context Encoding vector
ENTROPY = defaultdict(lambda: DEFAULT_ENTROPY)  # Entropy scores
ADAPTIVE_GRADIENT = 0.0  # Adaptive gradient value
RECENTLY_ACCESSED = deque(maxlen=10)  # Tracks recently accessed objects for temporal updates

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by identifying the object with the highest entropy score (least predictable access) and the lowest combined weight from the TFM and PCE, while dynamically adjusting thresholds using the adaptive gradient to balance between temporal locality and contextual relevance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global ADAPTIVE_GRADIENT

    # Calculate the combined weight for each object in the cache
    eviction_candidates = []
    for key, cached_obj in cache_snapshot.cache.items():
        tfm_weight = sum(TFM[key].values()) * TEMPORAL_RELATION_WEIGHT
        pce_weight = PCE[key] * CONTEXTUAL_PROBABILITY_WEIGHT
        combined_weight = tfm_weight + pce_weight
        adjusted_entropy = ENTROPY[key] - ADAPTIVE_GRADIENT
        eviction_candidates.append((adjusted_entropy, combined_weight, key))

    # Sort by highest entropy (least predictable) and lowest combined weight
    eviction_candidates.sort(key=lambda x: (x[0], x[1]), reverse=True)

    # Select the eviction victim
    candid_obj_key = eviction_candidates[0][2]
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the TFM is updated to strengthen the temporal relationship between the accessed object and recently accessed objects, the PCE vector is recalibrated to increase the probability of future access for the object, and the entropy score is reduced to reflect increased predictability.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global TFM, PCE, ENTROPY, RECENTLY_ACCESSED

    # Update TFM to strengthen temporal relationships
    for recent_key in RECENTLY_ACCESSED:
        if recent_key != obj.key:
            TFM[recent_key][obj.key] += 1.0

    # Update PCE to increase probability of future access
    PCE[obj.key] += 1.0

    # Reduce entropy to reflect increased predictability
    ENTROPY[obj.key] = max(0, ENTROPY[obj.key] - 1)

    # Update recently accessed objects
    RECENTLY_ACCESSED.append(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the TFM is updated to initialize temporal relationships with recently accessed objects, the PCE vector is updated to encode an initial access probability for the new object, and the entropy score is set to a default high value to reflect initial uncertainty.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global TFM, PCE, ENTROPY, RECENTLY_ACCESSED

    # Initialize temporal relationships in TFM
    for recent_key in RECENTLY_ACCESSED:
        if recent_key != obj.key:
            TFM[recent_key][obj.key] = 1.0
            TFM[obj.key][recent_key] = 1.0

    # Initialize PCE with an initial access probability
    PCE[obj.key] = 1.0

    # Set entropy to a default high value
    ENTROPY[obj.key] = DEFAULT_ENTROPY

    # Update recently accessed objects
    RECENTLY_ACCESSED.append(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the TFM is pruned to remove references to the evicted object, the PCE vector is adjusted to redistribute probabilities among remaining objects, and the adaptive gradient is tuned to refine future eviction thresholds based on the impact of the eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global TFM, PCE, ENTROPY, ADAPTIVE_GRADIENT

    # Prune TFM to remove references to the evicted object
    if evicted_obj.key in TFM:
        del TFM[evicted_obj.key]
    for key in TFM:
        if evicted_obj.key in TFM[key]:
            del TFM[key][evicted_obj.key]

    # Adjust PCE to redistribute probabilities
    if evicted_obj.key in PCE:
        del PCE[evicted_obj.key]
    total_pce = sum(PCE.values())
    if total_pce > 0:
        for key in PCE:
            PCE[key] /= total_pce

    # Tune adaptive gradient based on the impact of the eviction
    ADAPTIVE_GRADIENT += ADAPTIVE_GRADIENT_STEP