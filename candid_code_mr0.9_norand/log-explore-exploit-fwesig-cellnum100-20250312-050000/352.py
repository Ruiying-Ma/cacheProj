# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
DEFAULT_ACCESS_LATENCY = 1
DEFAULT_PREDICTIVE_INDEX = 0.5
DEFAULT_SEQUENTIAL_PRIORITY = 0.5
GRADIENT_HARMONY_RECENCY_BIAS = 0.6
GRADIENT_HARMONY_FREQUENCY_BIAS = 0.4
SEQUENTIAL_ACCESS_THRESHOLD = 1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for cache alignment (tracking data block boundaries), access latency (historical latency for each block), storage stratification (hot, warm, cold tiers), data pipelining (sequential access patterns), Predictive Index (forecasted future access likelihood), Sequential Priority (likelihood of sequential access), and Gradient Harmony (balance between recency and frequency).
metadata = {
    "access_latency": defaultdict(lambda: DEFAULT_ACCESS_LATENCY),
    "tier": defaultdict(lambda: "cold"),  # "cold", "warm", "hot"
    "alignment_metadata": defaultdict(lambda: None),  # Tracks sequential patterns
    "predictive_index": defaultdict(lambda: DEFAULT_PREDICTIVE_INDEX),
    "sequential_priority": defaultdict(lambda: DEFAULT_SEQUENTIAL_PRIORITY),
    "gradient_harmony": defaultdict(lambda: GRADIENT_HARMONY_RECENCY_BIAS),
    "insertion_timestamp": {},  # Tracks insertion time for tie-breaking
    "last_access_time": {},  # Tracks last access time for recency
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy calculates a composite score for each object by combining access latency, tier stratification, alignment with sequential patterns, Predictive Index, Sequential Priority, and Gradient Harmony. The object with the lowest composite score is evicted, with ties broken by the oldest insertion timestamp.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate composite score
        latency = metadata["access_latency"][key]
        tier_score = {"hot": 3, "warm": 2, "cold": 1}[metadata["tier"][key]]
        alignment = metadata["alignment_metadata"][key] or 0
        predictive_index = metadata["predictive_index"][key]
        sequential_priority = metadata["sequential_priority"][key]
        gradient_harmony = metadata["gradient_harmony"][key]

        composite_score = (
            latency +
            tier_score +
            alignment +
            predictive_index +
            sequential_priority +
            gradient_harmony
        )

        # Tie-breaking by oldest insertion timestamp
        if composite_score < min_score or (
            composite_score == min_score and metadata["insertion_timestamp"][key] < metadata["insertion_timestamp"][candid_obj_key]
        ):
            min_score = composite_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update access latency
    metadata["access_latency"][key] = current_time - metadata["last_access_time"].get(key, current_time)

    # Adjust tier based on frequency
    if metadata["tier"][key] == "cold":
        metadata["tier"][key] = "warm"
    elif metadata["tier"][key] == "warm":
        metadata["tier"][key] = "hot"

    # Recalibrate alignment metadata for sequential patterns
    if metadata["alignment_metadata"][key] is not None:
        metadata["alignment_metadata"][key] += 1

    # Update Predictive Index using Adaptive Forecasting
    metadata["predictive_index"][key] = min(1.0, metadata["predictive_index"][key] + 0.1)

    # Increment Sequential Priority if sequential access is detected
    if metadata["last_access_time"].get(key, 0) + SEQUENTIAL_ACCESS_THRESHOLD >= current_time:
        metadata["sequential_priority"][key] += 0.1

    # Adjust Gradient Harmony to balance recency and frequency
    metadata["gradient_harmony"][key] = (
        GRADIENT_HARMONY_RECENCY_BIAS * (current_time - metadata["last_access_time"].get(key, current_time)) +
        GRADIENT_HARMONY_FREQUENCY_BIAS * metadata["access_latency"][key]
    )

    # Update last access time
    metadata["last_access_time"][key] = current_time

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Initialize access latency
    metadata["access_latency"][key] = DEFAULT_ACCESS_LATENCY

    # Place object in the cold tier
    metadata["tier"][key] = "cold"

    # Evaluate alignment metadata for sequential patterns
    metadata["alignment_metadata"][key] = 0

    # Initialize Predictive Index using Adaptive Forecasting
    metadata["predictive_index"][key] = DEFAULT_PREDICTIVE_INDEX

    # Set Sequential Priority to a baseline
    metadata["sequential_priority"][key] = DEFAULT_SEQUENTIAL_PRIORITY

    # Slightly bias Gradient Harmony toward recency
    metadata["gradient_harmony"][key] = GRADIENT_HARMONY_RECENCY_BIAS

    # Record insertion timestamp
    metadata["insertion_timestamp"][key] = current_time

    # Update last access time
    metadata["last_access_time"][key] = current_time

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key

    # Recalibrate stratification thresholds for tiers
    for key in cache_snapshot.cache:
        if metadata["tier"][key] == "hot" and metadata["access_latency"][key] > 10:
            metadata["tier"][key] = "warm"
        elif metadata["tier"][key] == "warm" and metadata["access_latency"][key] > 20:
            metadata["tier"][key] = "cold"

    # Adjust alignment metadata for remaining objects
    for key in cache_snapshot.cache:
        if metadata["alignment_metadata"][key] is not None:
            metadata["alignment_metadata"][key] -= 1

    # Recalculate Predictive Index to account for the eviction's impact
    for key in cache_snapshot.cache:
        metadata["predictive_index"][key] = max(0, metadata["predictive_index"][key] - 0.1)

    # Deprioritize Sequential Priority for sequences involving the evicted object
    for key in cache_snapshot.cache:
        if metadata["alignment_metadata"][key] == evicted_key:
            metadata["sequential_priority"][key] -= 0.1

    # Rebalance Gradient Harmony to maintain cache harmony
    for key in cache_snapshot.cache:
        metadata["gradient_harmony"][key] = (
            GRADIENT_HARMONY_RECENCY_BIAS * metadata["last_access_time"].get(key, 0) +
            GRADIENT_HARMONY_FREQUENCY_BIAS * metadata["access_latency"][key]
        )