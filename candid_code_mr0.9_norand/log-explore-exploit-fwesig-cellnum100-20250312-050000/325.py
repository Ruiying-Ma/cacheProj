# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
ALPHA = 0.5  # Weight for Semantic Drift
BETA = 0.3   # Weight for Predictive Interpolation
GAMMA = 0.2  # Weight for Temporal Synthesis
DELTA = 0.1  # Weight for Semantic Fusion
EPSILON = 0.05  # Weight for Latency Profile

# Put the metadata specifically maintained by the policy below. The policy maintains a Hybrid Relevance Score (HRS) for each object, combining Semantic Drift, Latency Profile, Predictive Interpolation, Semantic Fusion, and Temporal Synthesis. It also tracks a Dynamic Bloom Filter for recent access patterns and a Global Stability Index (GSI) derived from Temporal Entropy and cache-wide access trends.
HRS = {}  # Dictionary to store the Hybrid Relevance Score for each object key
dynamic_bloom_filter = set()  # Set to simulate a simple Dynamic Bloom Filter
GSI = 0  # Global Stability Index

def calculate_hrs(obj, cache_snapshot):
    '''
    Helper function to calculate the HRS of an object.
    '''
    semantic_drift = ALPHA * (cache_snapshot.access_count - HRS.get(obj.key, {}).get('last_access', 0))
    predictive_interpolation = BETA * obj.size
    temporal_synthesis = GAMMA * (cache_snapshot.hit_count / (cache_snapshot.access_count + 1))
    semantic_fusion = DELTA * len(dynamic_bloom_filter)
    latency_profile = EPSILON * obj.size
    return semantic_drift + predictive_interpolation + temporal_synthesis + semantic_fusion + latency_profile

def recalculate_gsi(cache_snapshot):
    '''
    Helper function to recalculate the Global Stability Index (GSI).
    '''
    global GSI
    total_hrs = sum(HRS[obj.key]['score'] for obj in cache_snapshot.cache.values())
    GSI = total_hrs / (len(cache_snapshot.cache) + 1)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evicts the object with the lowest HRS. If multiple objects have the same HRS, the one contributing most to GSI instability is evicted to enhance cache stability.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_hrs = float('inf')
    min_gsi_impact = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        obj_hrs = HRS[key]['score']
        gsi_impact = abs(GSI - obj_hrs)
        if obj_hrs < min_hrs or (obj_hrs == min_hrs and gsi_impact > min_gsi_impact):
            min_hrs = obj_hrs
            min_gsi_impact = gsi_impact
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the HRS of the accessed object is recalculated by updating its Semantic Drift, Predictive Interpolation, Semantic Fusion, and Temporal Synthesis components. The Dynamic Bloom Filter is reinforced with the accessed key, and the GSI is adjusted to reflect reduced uncertainty.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global dynamic_bloom_filter
    HRS[obj.key] = {
        'score': calculate_hrs(obj, cache_snapshot),
        'last_access': cache_snapshot.access_count
    }
    dynamic_bloom_filter.add(obj.key)
    recalculate_gsi(cache_snapshot)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its HRS is initialized using Semantic Drift, Latency Profile, Predictive Interpolation, Semantic Fusion, and Temporal Synthesis. The Dynamic Bloom Filter is updated with the new key, and the GSI is recalculated to account for the new entry.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global dynamic_bloom_filter
    HRS[obj.key] = {
        'score': calculate_hrs(obj, cache_snapshot),
        'last_access': cache_snapshot.access_count
    }
    dynamic_bloom_filter.add(obj.key)
    recalculate_gsi(cache_snapshot)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the Dynamic Bloom Filter is updated to remove the evicted key. The HRS of remaining objects is adjusted to reflect the redistribution of importance, and the GSI is recalculated to reflect the new cache composition.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global dynamic_bloom_filter
    dynamic_bloom_filter.discard(evicted_obj.key)
    del HRS[evicted_obj.key]
    for key in HRS:
        HRS[key]['score'] = calculate_hrs(cache_snapshot.cache[key], cache_snapshot)
    recalculate_gsi(cache_snapshot)