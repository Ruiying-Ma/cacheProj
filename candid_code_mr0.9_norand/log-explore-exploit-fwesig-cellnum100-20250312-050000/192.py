# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
INITIAL_PREDICTIVE_SCORE = 100  # Initial predictive score for new objects
NEUTRAL_STABILITY_INDEX = 50    # Neutral baseline for stability index
PREDICTIVE_SCORE_DECAY = 0.9    # Decay factor for predictive score recalibration
STABILITY_INDEX_INCREMENT = 5   # Increment for stability index on consistent access
STABILITY_INDEX_DECREMENT = 10  # Decrement for stability index on disruption
WEAK_LINK_WEIGHT = 1            # Initial weight for weak links in Cascade Synchronization Map
STRONG_LINK_INCREMENT = 2       # Increment for strengthening links in Cascade Synchronization Map

# Put the metadata specifically maintained by the policy below. The policy maintains a bifurcated metadata structure: a 'Predictive Score' for each object based on access patterns using Predictive Interpolation, and a 'Stability Index' that tracks the consistency of these patterns using Synthetic Recalibration. Additionally, a 'Cascade Synchronization Map' ensures dependencies between objects are tracked to avoid cascading evictions of related data.
predictive_scores = {}  # Maps object keys to their predictive scores
stability_indices = {}  # Maps object keys to their stability indices
cascade_sync_map = defaultdict(lambda: defaultdict(int))  # Nested dict for dependency weights

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by identifying the object with the lowest Predictive Score, recalibrated by its Stability Index. If multiple candidates exist, the Cascade Synchronization Map is consulted to minimize disruption to related objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    # Calculate recalibrated score for each object in the cache
    for key, cached_obj in cache_snapshot.cache.items():
        recalibrated_score = predictive_scores[key] - stability_indices[key]
        if recalibrated_score < min_score:
            min_score = recalibrated_score
            candid_obj_key = key
        elif recalibrated_score == min_score:
            # Use Cascade Synchronization Map to minimize disruption
            disruption = sum(cascade_sync_map[key].values())
            current_disruption = sum(cascade_sync_map[candid_obj_key].values())
            if disruption < current_disruption:
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the Predictive Score of the accessed object is incrementally adjusted using Predictive Interpolation based on the time since its last access, while its Stability Index is recalibrated to reflect the consistency of its access pattern. The Cascade Synchronization Map is updated to strengthen links to frequently co-accessed objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    predictive_scores[key] += 1  # Increment predictive score
    stability_indices[key] += STABILITY_INDEX_INCREMENT  # Recalibrate stability index

    # Strengthen links in the Cascade Synchronization Map
    for other_key in cache_snapshot.cache:
        if other_key != key:
            cascade_sync_map[key][other_key] += STRONG_LINK_INCREMENT
            cascade_sync_map[other_key][key] += STRONG_LINK_INCREMENT

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, an initial Predictive Score is assigned based on the object's expected access frequency, and its Stability Index is set to a neutral baseline. The Cascade Synchronization Map is updated to establish weak initial links to objects accessed in close temporal proximity.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    predictive_scores[key] = INITIAL_PREDICTIVE_SCORE  # Assign initial predictive score
    stability_indices[key] = NEUTRAL_STABILITY_INDEX  # Set neutral stability index

    # Establish weak links in the Cascade Synchronization Map
    for other_key in cache_snapshot.cache:
        if other_key != key:
            cascade_sync_map[key][other_key] += WEAK_LINK_WEIGHT
            cascade_sync_map[other_key][key] += WEAK_LINK_WEIGHT

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the Predictive Scores of remaining objects are recalibrated to account for the removal, and the Stability Index of related objects is adjusted to reflect the disruption. The Cascade Synchronization Map is pruned to remove dependencies involving the evicted object.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Recalibrate predictive scores and stability indices
    for key in cache_snapshot.cache:
        predictive_scores[key] *= PREDICTIVE_SCORE_DECAY
        stability_indices[key] -= STABILITY_INDEX_DECREMENT

    # Prune Cascade Synchronization Map
    if evicted_key in cascade_sync_map:
        del cascade_sync_map[evicted_key]
    for key in cascade_sync_map:
        if evicted_key in cascade_sync_map[key]:
            del cascade_sync_map[key][evicted_key]