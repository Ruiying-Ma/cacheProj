# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
INITIAL_PPL_SCORE = 1.0
INITIAL_GFA_VALUE = 1.0
INITIAL_SDF_METRIC = 100.0
SDF_DECAY_FACTOR = 0.95
GFA_GRADIENT_FACTOR = 0.1
PPL_ADJUSTMENT_FACTOR = 0.05

# Put the metadata specifically maintained by the policy below. The policy maintains a Temporal Shift Encoding (TSE) vector for each cache object to track time-based access patterns, a Probabilistic Phase Linking (PPL) score to identify correlations between objects during workload phases, a Gradient Flow Allocation (GFA) value to prioritize objects based on their recent access gradients, and a Semantic Drift Fusion (SDF) metric to measure how the object's relevance changes over time.
metadata = {
    "TSE": {},  # {obj.key: last_access_time}
    "PPL": {},  # {obj.key: PPL_score}
    "GFA": {},  # {obj.key: GFA_value}
    "SDF": {},  # {obj.key: SDF_metric}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by combining the SDF metric and the inverse of the PPL score to identify objects with low semantic relevance and weak phase correlation, while also considering the GFA value to deprioritize objects with flat or negative access gradients.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate the eviction score
        SDF = metadata["SDF"].get(key, INITIAL_SDF_METRIC)
        PPL = metadata["PPL"].get(key, INITIAL_PPL_SCORE)
        GFA = metadata["GFA"].get(key, INITIAL_GFA_VALUE)
        eviction_score = SDF + (1 / (PPL + 1e-6)) + GFA

        # Find the object with the minimum score
        if eviction_score < min_score:
            min_score = eviction_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the TSE vector is updated to reflect the current temporal access pattern, the PPL score is adjusted to strengthen phase correlations with other recently accessed objects, the GFA value is recalculated to reflect the new gradient of access frequency, and the SDF metric is slightly decayed to account for potential semantic drift.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update TSE vector
    metadata["TSE"][key] = current_time

    # Adjust PPL score
    metadata["PPL"][key] = metadata["PPL"].get(key, INITIAL_PPL_SCORE) + PPL_ADJUSTMENT_FACTOR

    # Recalculate GFA value
    last_access_time = metadata["TSE"].get(key, 0)
    time_diff = current_time - last_access_time
    metadata["GFA"][key] = metadata["GFA"].get(key, INITIAL_GFA_VALUE) + GFA_GRADIENT_FACTOR / (time_diff + 1e-6)

    # Decay SDF metric
    metadata["SDF"][key] = metadata["SDF"].get(key, INITIAL_SDF_METRIC) * SDF_DECAY_FACTOR

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the TSE vector is initialized based on the current time, the PPL score is seeded with a neutral value to allow future phase linking, the GFA value is set to a baseline reflecting initial access priority, and the SDF metric is initialized to a high value to reflect the object's immediate relevance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Initialize TSE vector
    metadata["TSE"][key] = current_time

    # Seed PPL score
    metadata["PPL"][key] = INITIAL_PPL_SCORE

    # Set GFA value
    metadata["GFA"][key] = INITIAL_GFA_VALUE

    # Initialize SDF metric
    metadata["SDF"][key] = INITIAL_SDF_METRIC

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the TSE vector is removed, the PPL scores of remaining objects are adjusted to account for the loss of phase correlation, the GFA values are recalibrated to redistribute priority among the remaining objects, and the SDF metrics are normalized to ensure consistent semantic relevance across the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Remove TSE vector
    if evicted_key in metadata["TSE"]:
        del metadata["TSE"][evicted_key]

    # Adjust PPL scores
    for key in metadata["PPL"]:
        metadata["PPL"][key] *= (1 - PPL_ADJUSTMENT_FACTOR)

    # Recalibrate GFA values
    total_gfa = sum(metadata["GFA"].values())
    for key in metadata["GFA"]:
        metadata["GFA"][key] /= (total_gfa + 1e-6)

    # Normalize SDF metrics
    max_sdf = max(metadata["SDF"].values(), default=1)
    for key in metadata["SDF"]:
        metadata["SDF"][key] /= max_sdf