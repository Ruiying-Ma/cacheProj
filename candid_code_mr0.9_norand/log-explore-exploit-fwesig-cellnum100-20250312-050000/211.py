# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
DEFAULT_PRIORITY_TAG = 1
DEFAULT_PROBABILISTIC_GRADIENT_SCORE = 0.5
DEFAULT_SEMANTIC_ENTROPY = 0.5
DEFAULT_ACCESS_LATENCY = 0
HOT_TIER_THRESHOLD = 0.8
WARM_TIER_THRESHOLD = 0.5

# Put the metadata specifically maintained by the policy below. The policy maintains a rotation index, access latency counters, priority tags, a sequential eviction queue, stratification tiers (hot, warm, cold), probabilistic gradient scores, semantic entropy scores, an adaptive latency map, and a dynamic contextual threshold. It integrates sequential access patterns, workload trends, and tier-based stratification for optimal cache behavior.
metadata = {
    "rotation_index": 0,
    "access_latency_counters": {},  # {key: latency}
    "priority_tags": {},  # {key: priority}
    "sequential_eviction_queue": [],  # [key1, key2, ...]
    "stratification_tiers": {"hot": set(), "warm": set(), "cold": set()},  # {"hot": {key1, ...}, ...}
    "probabilistic_gradient_scores": {},  # {key: score}
    "semantic_entropy_scores": {},  # {key: score}
    "adaptive_latency_map": {},  # {key: latency}
    "dynamic_contextual_threshold": 0.5,
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first identifies blocks in the cold tier with the lowest priority tag and probabilistic gradient score. Among these, it selects the block with the highest combined semantic entropy and access latency. If no cold-tier blocks are available, it defaults to the least recently rotated block in the sequential eviction queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    cold_tier = metadata["stratification_tiers"]["cold"]
    if cold_tier:
        # Find the block in the cold tier with the lowest priority tag and probabilistic gradient score
        candidates = sorted(
            cold_tier,
            key=lambda key: (
                metadata["priority_tags"][key],
                metadata["probabilistic_gradient_scores"][key],
                -metadata["semantic_entropy_scores"][key],
                -metadata["access_latency_counters"][key],
            ),
        )
        candid_obj_key = candidates[0]
    else:
        # Default to the least recently rotated block in the sequential eviction queue
        candid_obj_key = metadata["sequential_eviction_queue"][metadata["rotation_index"]]
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a hit, the access latency counter is reset, the priority tag is incremented, and the block is moved to the end of the sequential eviction queue. The block is promoted to a hotter tier if its frequency increases, its probabilistic gradient score is updated, its semantic entropy score is recalculated, and the contextual threshold is adjusted to reflect the updated workload dynamics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    # Reset access latency counter
    metadata["access_latency_counters"][key] = DEFAULT_ACCESS_LATENCY
    # Increment priority tag
    metadata["priority_tags"][key] += 1
    # Move block to the end of the sequential eviction queue
    metadata["sequential_eviction_queue"].remove(key)
    metadata["sequential_eviction_queue"].append(key)
    # Promote to a hotter tier if frequency increases
    if metadata["priority_tags"][key] > HOT_TIER_THRESHOLD:
        metadata["stratification_tiers"]["hot"].add(key)
        metadata["stratification_tiers"]["warm"].discard(key)
        metadata["stratification_tiers"]["cold"].discard(key)
    elif metadata["priority_tags"][key] > WARM_TIER_THRESHOLD:
        metadata["stratification_tiers"]["warm"].add(key)
        metadata["stratification_tiers"]["cold"].discard(key)
    # Update probabilistic gradient score and semantic entropy score
    metadata["probabilistic_gradient_scores"][key] += 0.1
    metadata["semantic_entropy_scores"][key] += 0.05
    # Adjust contextual threshold
    metadata["dynamic_contextual_threshold"] += 0.01

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    On insertion, the rotation index is updated, the new block is assigned a default priority tag, its access latency counter is initialized, and it is added to the end of the sequential eviction queue. The block is placed in the cold tier, its probabilistic gradient score is initialized based on workload trends, its semantic entropy is set to a neutral value, and the contextual threshold is recalibrated to account for the new object.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    # Update rotation index
    metadata["rotation_index"] = (metadata["rotation_index"] + 1) % len(cache_snapshot.cache)
    # Assign default priority tag and initialize access latency counter
    metadata["priority_tags"][key] = DEFAULT_PRIORITY_TAG
    metadata["access_latency_counters"][key] = DEFAULT_ACCESS_LATENCY
    # Add to the end of the sequential eviction queue
    metadata["sequential_eviction_queue"].append(key)
    # Place in the cold tier
    metadata["stratification_tiers"]["cold"].add(key)
    # Initialize probabilistic gradient score and semantic entropy
    metadata["probabilistic_gradient_scores"][key] = DEFAULT_PROBABILISTIC_GRADIENT_SCORE
    metadata["semantic_entropy_scores"][key] = DEFAULT_SEMANTIC_ENTROPY
    # Recalibrate contextual threshold
    metadata["dynamic_contextual_threshold"] -= 0.01

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the rotation index skips to the next block, the evicted block's metadata is cleared, and the sequential eviction queue is updated. Stratification thresholds for tiers are recalibrated, alignment metadata for remaining blocks is adjusted, the evicted block is removed from the adaptive latency map, and semantic entropy scores of remaining blocks are slightly adjusted to reflect the new cache dynamics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    # Skip to the next block in the rotation index
    metadata["rotation_index"] = (metadata["rotation_index"] + 1) % len(cache_snapshot.cache)
    # Clear evicted block's metadata
    metadata["priority_tags"].pop(evicted_key, None)
    metadata["access_latency_counters"].pop(evicted_key, None)
    metadata["probabilistic_gradient_scores"].pop(evicted_key, None)
    metadata["semantic_entropy_scores"].pop(evicted_key, None)
    metadata["adaptive_latency_map"].pop(evicted_key, None)
    # Update the sequential eviction queue
    metadata["sequential_eviction_queue"].remove(evicted_key)
    # Recalibrate stratification thresholds
    metadata["stratification_tiers"]["hot"].discard(evicted_key)
    metadata["stratification_tiers"]["warm"].discard(evicted_key)
    metadata["stratification_tiers"]["cold"].discard(evicted_key)
    # Adjust semantic entropy scores of remaining blocks
    for key in metadata["semantic_entropy_scores"]:
        metadata["semantic_entropy_scores"][key] -= 0.01