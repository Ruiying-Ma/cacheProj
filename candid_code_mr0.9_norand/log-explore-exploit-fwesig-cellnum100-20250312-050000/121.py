# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
GQ_CAPACITY = 100  # Maximum size of the ghost queue
HOT_THRESHOLD = 5  # Minimum frequency for an object to be promoted to the hot tier
WARM_THRESHOLD = 3  # Minimum frequency for an object to be promoted to the warm tier

# Put the metadata specifically maintained by the policy below. The policy maintains frequency counters, recency timestamps, access latency, storage stratification tiers (hot, warm, cold), sequential access alignment metadata, and a ghost queue (GQ) for tracking recently evicted objects.
metadata = {
    "frequency": {},  # Tracks the frequency of each object
    "recency": {},  # Tracks the last access time of each object
    "access_latency": {},  # Tracks the access latency of each object
    "tiers": {"hot": set(), "warm": set(), "cold": set()},  # Tracks objects in hot, warm, and cold tiers
    "alignment": {},  # Tracks sequential access alignment metadata
    "ghost_queue": []  # Tracks recently evicted objects
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    '''
    candid_obj_key = None

    # Step 1: Prioritize eviction from the cold tier
    cold_objects = metadata["tiers"]["cold"]
    if cold_objects:
        # Find the object in the cold tier with the highest access latency and least alignment
        candid_obj_key = min(
            cold_objects,
            key=lambda key: (metadata["access_latency"].get(key, float('inf')), metadata["alignment"].get(key, float('inf')))
        )
    else:
        # Step 2: If no cold objects, evict from LFU-MQ (least-frequently-used and least-recently-used)
        candid_obj_key = min(
            cache_snapshot.cache.keys(),
            key=lambda key: (metadata["frequency"].get(key, 0), metadata["recency"].get(key, float('inf')))
        )

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    # Increase frequency counter
    metadata["frequency"][key] = metadata["frequency"].get(key, 0) + 1
    # Update recency timestamp
    metadata["recency"][key] = cache_snapshot.access_count
    # Recalculate access latency
    metadata["access_latency"][key] = cache_snapshot.access_count - metadata["recency"].get(key, 0)
    # Adjust tier based on frequency
    freq = metadata["frequency"][key]
    if freq >= HOT_THRESHOLD:
        metadata["tiers"]["hot"].add(key)
        metadata["tiers"]["warm"].discard(key)
        metadata["tiers"]["cold"].discard(key)
    elif freq >= WARM_THRESHOLD:
        metadata["tiers"]["warm"].add(key)
        metadata["tiers"]["cold"].discard(key)
    else:
        metadata["tiers"]["cold"].add(key)
    # Update alignment metadata (dummy logic for sequential patterns)
    metadata["alignment"][key] = metadata["alignment"].get(key, 0) + 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    # Initialize frequency to 1
    metadata["frequency"][key] = 1
    # Set recency timestamp to current time
    metadata["recency"][key] = cache_snapshot.access_count
    # Assign to the cold tier
    metadata["tiers"]["cold"].add(key)
    # Evaluate alignment with sequential patterns (dummy logic)
    metadata["alignment"][key] = 0
    # If the object was in GQ, place it in MQ
    if key in metadata["ghost_queue"]:
        metadata["ghost_queue"].remove(key)
        metadata["tiers"]["warm"].add(key)  # Promote to warm tier
        metadata["tiers"]["cold"].discard(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key
    # Place the evicted object in the GQ
    metadata["ghost_queue"].append(evicted_key)
    # Trim the GQ if it exceeds capacity
    if len(metadata["ghost_queue"]) > GQ_CAPACITY:
        metadata["ghost_queue"].pop(0)
    # Recalibrate stratification thresholds (dummy logic)
    # Update alignment metadata for remaining objects (dummy logic)
    # Adjust LFU-MQ queue if necessary
    for tier in metadata["tiers"].values():
        tier.discard(evicted_key)
    metadata["frequency"].pop(evicted_key, None)
    metadata["recency"].pop(evicted_key, None)
    metadata["access_latency"].pop(evicted_key, None)
    metadata["alignment"].pop(evicted_key, None)