# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
QFS_INCREMENT = 1.0  # Increment for QFS on hit
CGF_DECAY = 0.9      # Decay factor for CGF updates
APT_HOT_THRESHOLD = 0.7  # Threshold for transitioning to 'hot' state
APT_COLD_THRESHOLD = 0.3  # Threshold for transitioning to 'cold' state

# Put the metadata specifically maintained by the policy below. The policy maintains a Quantum Feedback Score (QFS) for each cache object, which oscillates predictively based on recent access patterns, a Contextual Gradient Flow (CGF) vector that tracks the object's relevance in varying workload contexts, and an Adaptive Phase Transition (APT) state that determines the object's likelihood of transitioning between 'hot' and 'cold' states.
metadata = {
    "QFS": {},  # Quantum Feedback Score for each object key
    "CGF": {},  # Contextual Gradient Flow for each object key
    "APT": {},  # Adaptive Phase Transition state for each object key
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by identifying the object with the lowest combined QFS and CGF score, adjusted by its APT state. Objects in a 'cold' APT state are prioritized for eviction unless their QFS indicates a potential resurgence in access.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        qfs = metadata["QFS"].get(key, 0)
        cgf = metadata["CGF"].get(key, 0)
        apt = metadata["APT"].get(key, 0.5)  # Default neutral phase

        # Calculate combined score
        combined_score = qfs + cgf - apt

        # Prioritize 'cold' APT state for eviction
        if apt < APT_COLD_THRESHOLD:
            combined_score -= 10  # Strong bias for eviction

        # Find the object with the lowest score
        if combined_score < min_score:
            min_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the QFS of the accessed object is incrementally adjusted to reflect its predictive oscillation pattern, the CGF vector is updated to reinforce its relevance in the current workload context, and the APT state is recalibrated to reflect a potential shift toward a 'hot' state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key

    # Incrementally adjust QFS
    metadata["QFS"][key] = metadata["QFS"].get(key, 0) + QFS_INCREMENT

    # Update CGF with decay
    metadata["CGF"][key] = metadata["CGF"].get(key, 0) * CGF_DECAY + 1

    # Recalibrate APT state
    apt = metadata["APT"].get(key, 0.5)
    if apt < APT_HOT_THRESHOLD:
        metadata["APT"][key] = min(1.0, apt + 0.1)  # Shift toward 'hot'

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its QFS is initialized based on the predictive oscillation of similar objects, its CGF vector is seeded with contextual relevance derived from the workload, and its APT state is set to a neutral phase to allow adaptive learning.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key

    # Initialize QFS based on predictive oscillation (default to 0)
    metadata["QFS"][key] = 0

    # Seed CGF with contextual relevance (default to 0)
    metadata["CGF"][key] = 0

    # Set APT state to neutral phase
    metadata["APT"][key] = 0.5

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy updates the global oscillation model to account for the removed object's QFS, adjusts the CGF vectors of remaining objects to reflect the new context, and recalibrates the APT states of neighboring objects to ensure smooth phase transitions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Remove evicted object's metadata
    if evicted_key in metadata["QFS"]:
        del metadata["QFS"][evicted_key]
    if evicted_key in metadata["CGF"]:
        del metadata["CGF"][evicted_key]
    if evicted_key in metadata["APT"]:
        del metadata["APT"][evicted_key]

    # Adjust CGF vectors of remaining objects
    for key in cache_snapshot.cache.keys():
        metadata["CGF"][key] = metadata["CGF"].get(key, 0) * CGF_DECAY

    # Recalibrate APT states of neighboring objects
    for key in cache_snapshot.cache.keys():
        apt = metadata["APT"].get(key, 0.5)
        metadata["APT"][key] = max(0.0, min(1.0, apt - 0.05))  # Smooth transition