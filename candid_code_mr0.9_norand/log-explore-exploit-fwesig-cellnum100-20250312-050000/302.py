# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
QGM_DECAY_RATE = 0.9  # Decay rate for QGM gradients
ESF_BASELINE_ENTROPY = 1.0  # Baseline entropy for new objects
TNM_INITIAL_UTILITY = 1.0  # Initial utility score for TNM
TNM_DECAY_RATE = 0.95  # Decay rate for TNM utility scores

# Put the metadata specifically maintained by the policy below. The policy maintains a Quantum Gradient Map (QGM) to track access frequency gradients, an Entropic State Flow (ESF) to measure the unpredictability of access patterns, a Predictive Context Cascade (PCC) to anticipate future access based on temporal and contextual patterns, and a Temporal Neural Modulation (TNM) score to weigh recency against long-term utility.
QGM = {}  # Maps object keys to their access frequency gradients
ESF = {}  # Maps object keys to their entropy values
PCC = {}  # Maps object keys to their prediction confidence scores
TNM = {}  # Maps object keys to their recency-weighted utility scores

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by identifying the object with the lowest combined score derived from the QGM gradient, ESF entropy, PCC prediction confidence, and TNM recency-weighted utility. Objects with stable but low utility and high entropy are prioritized for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        qgm_score = QGM.get(key, 0)
        esf_score = ESF.get(key, ESF_BASELINE_ENTROPY)
        pcc_score = PCC.get(key, 0)
        tnm_score = TNM.get(key, 0)

        # Calculate combined score
        combined_score = qgm_score + esf_score - pcc_score - tnm_score

        # Prioritize objects with the lowest combined score
        if combined_score < min_score:
            min_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    The QGM gradient is adjusted to reflect an increase in access frequency, the ESF entropy is recalculated to account for reduced unpredictability, the PCC is updated with the new access context to refine future predictions, and the TNM score is boosted to emphasize recent utility.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key

    # Update QGM gradient
    QGM[key] = QGM.get(key, 0) + 1

    # Update ESF entropy
    ESF[key] = max(0, ESF.get(key, ESF_BASELINE_ENTROPY) - 0.1)

    # Update PCC prediction confidence
    PCC[key] = PCC.get(key, 0) + 0.1

    # Update TNM recency-weighted utility
    TNM[key] = TNM.get(key, TNM_INITIAL_UTILITY) * TNM_DECAY_RATE + 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    The QGM initializes a neutral gradient for the new object, the ESF sets a baseline entropy value, the PCC incorporates the new object into its predictive model, and the TNM assigns an initial recency-weighted utility score based on the insertion time.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key

    # Initialize QGM gradient
    QGM[key] = 0

    # Set baseline ESF entropy
    ESF[key] = ESF_BASELINE_ENTROPY

    # Incorporate into PCC predictive model
    PCC[key] = 0

    # Assign initial TNM utility score
    TNM[key] = TNM_INITIAL_UTILITY

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    The QGM removes the gradient entry for the evicted object, the ESF recalibrates global entropy to reflect the reduced cache state, the PCC adjusts its model to deprioritize the evicted object in future predictions, and the TNM normalizes scores to redistribute weight among remaining objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Remove QGM gradient entry
    QGM.pop(evicted_key, None)

    # Recalibrate ESF entropy
    ESF.pop(evicted_key, None)

    # Adjust PCC predictive model
    PCC.pop(evicted_key, None)

    # Normalize TNM scores
    TNM.pop(evicted_key, None)
    total_tnm = sum(TNM.values())
    if total_tnm > 0:
        for key in TNM:
            TNM[key] /= total_tnm