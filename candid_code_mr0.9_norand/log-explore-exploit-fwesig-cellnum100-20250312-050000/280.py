# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict
import heapq

# Put tunable constant parameters below
DEFAULT_COMPRESSION_SCORE = 1.0  # Default predictive compression score for new objects
LATENCY_PARTITION_COUNT = 5  # Number of latency partitions

# Put the metadata specifically maintained by the policy below. The policy maintains a predictive compression score for each object, a recursive index tree for object access patterns, latency partitions to group objects by access speed, and a dynamic entanglement map to track interdependencies between objects.
predictive_compression_scores = {}  # Maps obj.key to its predictive compression score
recursive_index_tree = defaultdict(list)  # Tracks access patterns (e.g., obj.key -> list of access times)
latency_partitions = [set() for _ in range(LATENCY_PARTITION_COUNT)]  # Groups objects by access speed
dynamic_entanglement_map = defaultdict(set)  # Tracks interdependencies (e.g., obj.key -> set of related keys)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the object with the lowest predictive compression score within the highest latency partition, while considering the dynamic entanglement map to avoid evicting objects that are frequently accessed together.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    for partition in reversed(latency_partitions):  # Start from the highest latency partition
        if not partition:
            continue
        # Sort objects in the partition by predictive compression score
        candidates = sorted(partition, key=lambda key: predictive_compression_scores[key])
        for candidate_key in candidates:
            # Avoid evicting objects that are frequently accessed together with the new object
            if not dynamic_entanglement_map[candidate_key].intersection(dynamic_entanglement_map[obj.key]):
                candid_obj_key = candidate_key
                break
        if candid_obj_key:
            break
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the predictive compression score of the object is recalculated based on recent access patterns, the recursive index tree is updated to reflect the new access, and the object's latency partition is adjusted if its access speed changes.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    # Update predictive compression score based on recent access patterns
    access_times = recursive_index_tree[obj.key]
    access_times.append(cache_snapshot.access_count)
    if len(access_times) > 1:
        time_diffs = [access_times[i] - access_times[i - 1] for i in range(1, len(access_times))]
        predictive_compression_scores[obj.key] = 1.0 / (sum(time_diffs) / len(time_diffs))
    else:
        predictive_compression_scores[obj.key] = DEFAULT_COMPRESSION_SCORE

    # Update latency partition
    current_partition = None
    for i, partition in enumerate(latency_partitions):
        if obj.key in partition:
            current_partition = i
            partition.remove(obj.key)
            break
    new_partition = min(LATENCY_PARTITION_COUNT - 1, int(predictive_compression_scores[obj.key]))
    latency_partitions[new_partition].add(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its predictive compression score is initialized, it is added to the recursive index tree, placed in the appropriate latency partition, and its dynamic entanglement relationships are established based on observed dependencies.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    # Initialize predictive compression score
    predictive_compression_scores[obj.key] = DEFAULT_COMPRESSION_SCORE

    # Add to recursive index tree
    recursive_index_tree[obj.key].append(cache_snapshot.access_count)

    # Place in appropriate latency partition
    latency_partitions[0].add(obj.key)

    # Establish dynamic entanglement relationships
    for cached_key in cache_snapshot.cache:
        if cached_key != obj.key:
            dynamic_entanglement_map[obj.key].add(cached_key)
            dynamic_entanglement_map[cached_key].add(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, its entry is removed from the recursive index tree, its latency partition is updated to reflect the removal, and its dynamic entanglement relationships are recalibrated to redistribute dependencies among remaining objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    # Remove from recursive index tree
    if evicted_obj.key in recursive_index_tree:
        del recursive_index_tree[evicted_obj.key]

    # Remove from latency partition
    for partition in latency_partitions:
        if evicted_obj.key in partition:
            partition.remove(evicted_obj.key)
            break

    # Recalibrate dynamic entanglement relationships
    if evicted_obj.key in dynamic_entanglement_map:
        related_keys = dynamic_entanglement_map[evicted_obj.key]
        for related_key in related_keys:
            dynamic_entanglement_map[related_key].remove(evicted_obj.key)
        del dynamic_entanglement_map[evicted_obj.key]