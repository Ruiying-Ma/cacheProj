# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
TEMPORAL_COHESION_INCREMENT = 1
PREDICTIVE_ACCESS_WEIGHT = 0.7
CONTEXTUAL_DRIFT_DECAY = 0.9
TIER_PROMOTION_THRESHOLD = 5
TIER_COUNT = 3

# Put the metadata specifically maintained by the policy below. The policy maintains a temporal cohesion score for each object, a predictive access probability based on historical patterns, a contextual drift factor to measure changes in access behavior, and a hierarchical mapping of objects into tiers based on their access frequency and recency.
metadata = {
    "temporal_cohesion": defaultdict(int),  # {obj.key: temporal_cohesion_score}
    "predictive_access": defaultdict(float),  # {obj.key: predictive_access_probability}
    "contextual_drift": defaultdict(float),  # {obj.key: contextual_drift_factor}
    "tiers": defaultdict(int),  # {obj.key: tier_level (0 is the lowest tier)}
    "tier_objects": defaultdict(set),  # {tier_level: set of obj.keys}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the object with the lowest combined score of temporal cohesion, predictive access probability, and contextual drift factor, prioritizing lower-tier objects in the hierarchical mapping.
    '''
    candid_obj_key = None
    min_score = float('inf')

    # Iterate through tiers from lowest to highest
    for tier in range(TIER_COUNT):
        for obj_key in metadata["tier_objects"][tier]:
            cached_obj = cache_snapshot.cache[obj_key]
            combined_score = (
                metadata["temporal_cohesion"][obj_key] +
                metadata["predictive_access"][obj_key] +
                metadata["contextual_drift"][obj_key]
            )
            if combined_score < min_score:
                min_score = combined_score
                candid_obj_key = obj_key

        # If a candidate is found in the current tier, stop searching higher tiers
        if candid_obj_key is not None:
            break

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    obj_key = obj.key

    # Increment temporal cohesion score
    metadata["temporal_cohesion"][obj_key] += TEMPORAL_COHESION_INCREMENT

    # Update predictive access probability using a weighted moving average
    metadata["predictive_access"][obj_key] = (
        PREDICTIVE_ACCESS_WEIGHT * metadata["predictive_access"][obj_key] +
        (1 - PREDICTIVE_ACCESS_WEIGHT)
    )

    # Recalibrate contextual drift factor
    metadata["contextual_drift"][obj_key] *= CONTEXTUAL_DRIFT_DECAY

    # Promote object to a higher tier if thresholds are met
    current_tier = metadata["tiers"][obj_key]
    if current_tier > 0 and metadata["temporal_cohesion"][obj_key] >= TIER_PROMOTION_THRESHOLD:
        metadata["tier_objects"][current_tier].remove(obj_key)
        metadata["tiers"][obj_key] = current_tier - 1
        metadata["tier_objects"][current_tier - 1].add(obj_key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    obj_key = obj.key

    # Assign initial temporal cohesion score and predictive access probability
    metadata["temporal_cohesion"][obj_key] = 1
    metadata["predictive_access"][obj_key] = 0.5  # Neutral initial probability

    # Initialize contextual drift factor to a neutral value
    metadata["contextual_drift"][obj_key] = 0.0

    # Place object in the lowest tier
    metadata["tiers"][obj_key] = TIER_COUNT - 1
    metadata["tier_objects"][TIER_COUNT - 1].add(obj_key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_obj_key = evicted_obj.key

    # Remove evicted object from metadata
    current_tier = metadata["tiers"][evicted_obj_key]
    metadata["tier_objects"][current_tier].remove(evicted_obj_key)
    del metadata["temporal_cohesion"][evicted_obj_key]
    del metadata["predictive_access"][evicted_obj_key]
    del metadata["contextual_drift"][evicted_obj_key]
    del metadata["tiers"][evicted_obj_key]

    # Adjust contextual drift factors of remaining objects
    for obj_key in cache_snapshot.cache:
        metadata["contextual_drift"][obj_key] *= CONTEXTUAL_DRIFT_DECAY