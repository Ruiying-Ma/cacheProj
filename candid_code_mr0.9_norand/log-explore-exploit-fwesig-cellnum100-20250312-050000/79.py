# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
PREDICTIVE_OVERLAP_INCREMENT = 1  # Increment for Predictive Overlap on hit
SEQUENTIAL_GRADIENT_DECAY = 0.9   # Decay factor for Sequential Gradient
TEMPORAL_CASCADE_WINDOW = 100     # Time window for Temporal Cascade adjustment

# Put the metadata specifically maintained by the policy below. The policy maintains a Predictive Overlap score for each object (indicating likelihood of future reuse based on access patterns), a Contextual Filter tag (categorizing objects based on workload context), a Temporal Cascade timestamp (tracking recency of access in multiple time windows), and a Sequential Gradient value (capturing sequential access trends).
metadata = {
    "predictive_overlap": {},  # Maps obj.key -> Predictive Overlap score
    "contextual_filter": {},  # Maps obj.key -> Contextual Filter tag
    "temporal_cascade": {},   # Maps obj.key -> Temporal Cascade timestamp
    "sequential_gradient": {},  # Maps obj.key -> Sequential Gradient value
    "last_access_time": {}    # Maps obj.key -> Last access time for sequential trend tracking
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by combining the Predictive Overlap score, Contextual Filter priority, and Temporal Cascade recency, with a bias against objects with high Sequential Gradient values to preserve sequential access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        predictive_overlap = metadata["predictive_overlap"].get(key, 0)
        contextual_filter = metadata["contextual_filter"].get(key, 0)
        temporal_cascade = metadata["temporal_cascade"].get(key, 0)
        sequential_gradient = metadata["sequential_gradient"].get(key, 0)

        # Combine scores with a bias against high Sequential Gradient values
        score = (
            predictive_overlap * 0.5 +  # Weight for Predictive Overlap
            contextual_filter * 0.3 +  # Weight for Contextual Filter
            (cache_snapshot.access_count - temporal_cascade) * 0.2 -  # Recency bias
            sequential_gradient * 0.4  # Bias against high Sequential Gradient
        )

        if score < min_score:
            min_score = score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the Predictive Overlap score is increased for the accessed object, the Temporal Cascade timestamp is updated to the current time, and the Sequential Gradient is adjusted based on the proximity of the access to prior sequential patterns. The Contextual Filter tag remains unchanged.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update Predictive Overlap score
    metadata["predictive_overlap"][key] = metadata["predictive_overlap"].get(key, 0) + PREDICTIVE_OVERLAP_INCREMENT

    # Update Temporal Cascade timestamp
    metadata["temporal_cascade"][key] = current_time

    # Update Sequential Gradient
    last_access_time = metadata["last_access_time"].get(key, None)
    if last_access_time is not None:
        time_diff = current_time - last_access_time
        metadata["sequential_gradient"][key] = metadata["sequential_gradient"].get(key, 0) * SEQUENTIAL_GRADIENT_DECAY + (1 / (time_diff + 1))
    metadata["last_access_time"][key] = current_time

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    On insertion, the Predictive Overlap score is initialized based on historical access patterns, the Contextual Filter tag is assigned based on the workload context, the Temporal Cascade timestamp is set to the current time, and the Sequential Gradient is initialized to reflect recent sequential trends.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Initialize Predictive Overlap score
    metadata["predictive_overlap"][key] = 1  # Default initial value

    # Assign Contextual Filter tag (default to 0 for simplicity)
    metadata["contextual_filter"][key] = 0

    # Set Temporal Cascade timestamp
    metadata["temporal_cascade"][key] = current_time

    # Initialize Sequential Gradient
    metadata["sequential_gradient"][key] = 0

    # Track last access time
    metadata["last_access_time"][key] = current_time

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the Predictive Overlap scores of remaining objects are recalibrated to account for the removed object, the Contextual Filter tags are re-evaluated for potential shifts in workload context, and the Temporal Cascade timestamps are adjusted to maintain relative recency. Sequential Gradient values are left unchanged.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Recalibrate Predictive Overlap scores
    for key in cache_snapshot.cache.keys():
        metadata["predictive_overlap"][key] = max(0, metadata["predictive_overlap"].get(key, 0) - 1)

    # Re-evaluate Contextual Filter tags (default to no change for simplicity)
    # Adjust Temporal Cascade timestamps
    for key in cache_snapshot.cache.keys():
        if key != evicted_key:
            metadata["temporal_cascade"][key] = max(0, metadata["temporal_cascade"].get(key, 0) - TEMPORAL_CASCADE_WINDOW)