# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
LATENCY_DRIFT_NEUTRAL = 0
CAUSAL_REINFORCEMENT_INITIAL = 0
PREDICTIVE_GRANULARITY_BASELINE = 0.5
ENTANGLEMENT_INITIAL_WEIGHT = 0.1
RECENT_ACCESS_WINDOW = 10

# Put the metadata specifically maintained by the policy below. The policy maintains a Latency Drift score for each object (tracking how access latency changes over time), a Causal Reinforcement score (indicating how often an objectâ€™s access correlates with others), a Dynamic Entanglement map (tracking relationships between objects based on access patterns), and a Predictive Granularity index (estimating the likelihood of future access based on recent trends).
latency_drift = defaultdict(lambda: LATENCY_DRIFT_NEUTRAL)
causal_reinforcement = defaultdict(lambda: CAUSAL_REINFORCEMENT_INITIAL)
dynamic_entanglement = defaultdict(lambda: defaultdict(float))
predictive_granularity = defaultdict(lambda: PREDICTIVE_GRANULARITY_BASELINE)
recent_accesses = deque(maxlen=RECENT_ACCESS_WINDOW)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by combining the Latency Drift score (favoring objects with increasing latency), the inverse of the Causal Reinforcement score (favoring objects with weak correlations), and the Predictive Granularity index (favoring objects with low future access probability). The Dynamic Entanglement map is used to avoid evicting objects that are strongly tied to frequently accessed ones.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate eviction score
        score = (
            latency_drift[key] +
            (1 / (1 + causal_reinforcement[key])) +  # Avoid division by zero
            predictive_granularity[key]
        )
        
        # Penalize eviction of strongly entangled objects
        entanglement_penalty = sum(dynamic_entanglement[key].values())
        score += entanglement_penalty

        # Choose the object with the minimum score
        if score < min_score:
            min_score = score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the Latency Drift score is updated to reflect the change in access latency, the Causal Reinforcement score is incremented for objects accessed in close temporal proximity, the Dynamic Entanglement map is updated to strengthen links between the accessed object and others accessed recently, and the Predictive Granularity index is refined based on the new access pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Update Latency Drift
    latency_drift[obj.key] += 1

    # Update Causal Reinforcement for recently accessed objects
    for recent_key in recent_accesses:
        if recent_key != obj.key:
            causal_reinforcement[recent_key] += 1
            causal_reinforcement[obj.key] += 1

            # Update Dynamic Entanglement map
            dynamic_entanglement[obj.key][recent_key] += ENTANGLEMENT_INITIAL_WEIGHT
            dynamic_entanglement[recent_key][obj.key] += ENTANGLEMENT_INITIAL_WEIGHT

    # Refine Predictive Granularity
    predictive_granularity[obj.key] *= 0.9  # Decay factor to reflect higher likelihood of future access

    # Update recent accesses
    recent_accesses.append(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the Latency Drift score is initialized to a neutral value, the Causal Reinforcement score is set based on recent correlations, the Dynamic Entanglement map is updated to include weak initial links to recently accessed objects, and the Predictive Granularity index is seeded with a baseline probability derived from recent access trends.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Initialize Latency Drift
    latency_drift[obj.key] = LATENCY_DRIFT_NEUTRAL

    # Set Causal Reinforcement based on recent correlations
    for recent_key in recent_accesses:
        causal_reinforcement[recent_key] += 1
        causal_reinforcement[obj.key] += 1

        # Update Dynamic Entanglement map
        dynamic_entanglement[obj.key][recent_key] = ENTANGLEMENT_INITIAL_WEIGHT
        dynamic_entanglement[recent_key][obj.key] = ENTANGLEMENT_INITIAL_WEIGHT

    # Seed Predictive Granularity
    predictive_granularity[obj.key] = PREDICTIVE_GRANULARITY_BASELINE

    # Update recent accesses
    recent_accesses.append(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the Latency Drift scores of remaining objects are adjusted to account for the removal, the Causal Reinforcement scores are recalibrated to remove dependencies on the evicted object, the Dynamic Entanglement map is pruned to remove links involving the evicted object, and the Predictive Granularity index is rebalanced to reflect the updated cache state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Adjust Latency Drift
    if evicted_key in latency_drift:
        del latency_drift[evicted_key]

    # Recalibrate Causal Reinforcement
    if evicted_key in causal_reinforcement:
        del causal_reinforcement[evicted_key]

    # Prune Dynamic Entanglement map
    if evicted_key in dynamic_entanglement:
        del dynamic_entanglement[evicted_key]
    for key in dynamic_entanglement:
        if evicted_key in dynamic_entanglement[key]:
            del dynamic_entanglement[key][evicted_key]

    # Rebalance Predictive Granularity
    if evicted_key in predictive_granularity:
        del predictive_granularity[evicted_key]