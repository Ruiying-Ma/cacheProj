# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
PAS_INCREMENT = 10  # Increment for PAS on a hit
PAS_CRITICAL_THRESHOLD = 5  # Threshold below which PAS is considered critically low
DSS_NEUTRAL = 0  # Neutral value for DSS
LCI_BASE = 1  # Base value for LCI calculation
RECENT_ACCESS_WINDOW = 5  # Number of recent accesses to consider for CDG links

# Put the metadata specifically maintained by the policy below. The policy maintains a predictive access score (PAS) for each object, a causal dependency graph (CDG) to track relationships between objects, a dynamic synchrony score (DSS) to measure temporal access patterns, and a latency collapse index (LCI) to prioritize low-latency retrievals.
PAS = defaultdict(int)  # Predictive Access Score for each object
DSS = defaultdict(int)  # Dynamic Synchrony Score for each object
LCI = defaultdict(int)  # Latency Collapse Index for each object
CDG = defaultdict(set)  # Causal Dependency Graph (key -> set of dependent keys)
LAST_ACCESS_TIME = {}  # Last access time for each object
RECENT_ACCESSES = deque()  # Queue to track recent accesses for CDG updates

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evicts the object with the lowest combined score derived from PAS, DSS, and LCI, while ensuring that objects with high causal dependencies in the CDG are preserved unless their PAS is critically low.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate combined score
        combined_score = PAS[key] + DSS[key] + LCI[key]

        # Check if the object is a candidate for eviction
        if combined_score < min_score and (PAS[key] > PAS_CRITICAL_THRESHOLD or not CDG[key]):
            min_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Increase PAS
    PAS[key] += PAS_INCREMENT

    # Recalibrate DSS
    if key in LAST_ACCESS_TIME:
        DSS[key] = current_time - LAST_ACCESS_TIME[key]
    else:
        DSS[key] = DSS_NEUTRAL

    # Update last access time
    LAST_ACCESS_TIME[key] = current_time

    # Update CDG with new causal relationships
    for recent_key in RECENT_ACCESSES:
        if recent_key != key:
            CDG[key].add(recent_key)
            CDG[recent_key].add(key)

    # Update recent accesses
    RECENT_ACCESSES.append(key)
    if len(RECENT_ACCESSES) > RECENT_ACCESS_WINDOW:
        RECENT_ACCESSES.popleft()

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Initialize PAS
    PAS[key] = PAS_INCREMENT  # Predictive fetching algorithms can be more complex

    # Set DSS to neutral value
    DSS[key] = DSS_NEUTRAL

    # Add to CDG with inferred causal links
    for recent_key in RECENT_ACCESSES:
        if recent_key != key:
            CDG[key].add(recent_key)
            CDG[recent_key].add(key)

    # Calculate LCI
    LCI[key] = LCI_BASE + obj.size  # Example: prioritize smaller objects for low latency

    # Update last access time
    LAST_ACCESS_TIME[key] = current_time

    # Update recent accesses
    RECENT_ACCESSES.append(key)
    if len(RECENT_ACCESSES) > RECENT_ACCESS_WINDOW:
        RECENT_ACCESSES.popleft()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key

    # Adjust PAS and DSS of remaining objects
    for key in cache_snapshot.cache:
        if key in CDG[evicted_key]:
            PAS[key] = max(PAS[key] - PAS_INCREMENT, 0)  # Reduce PAS for related objects
            DSS[key] = DSS_NEUTRAL  # Reset DSS for related objects

    # Prune CDG
    if evicted_key in CDG:
        for related_key in CDG[evicted_key]:
            CDG[related_key].discard(evicted_key)
        del CDG[evicted_key]

    # Recalculate LCI for related objects
    for key in cache_snapshot.cache:
        if key in CDG and evicted_key in CDG[key]:
            LCI[key] = LCI_BASE + cache_snapshot.cache[key].size