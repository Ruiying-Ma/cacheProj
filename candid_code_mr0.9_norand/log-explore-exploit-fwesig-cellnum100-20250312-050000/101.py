# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
INITIAL_COHESION_SCORE = 1
NEUTRAL_LATENCY_GRADIENT = 0
LATENCY_GRADIENT_DECAY = 0.9
COHESION_SCORE_INCREMENT = 1

# Put the metadata specifically maintained by the policy below. The policy maintains a predictive cohesion score for each object, a dynamic cluster ID for grouping related objects, a latency gradient value to track access time trends, and a sequential mapping index to capture access patterns.
metadata = {
    "cohesion_scores": {},  # {obj.key: predictive_cohesion_score}
    "clusters": {},         # {cluster_id: set(obj.key)}
    "object_to_cluster": {},# {obj.key: cluster_id}
    "latency_gradients": {},# {obj.key: latency_gradient}
    "sequential_indices": {},# {obj.key: sequential_index}
    "last_access_times": {} # {obj.key: last_access_time}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by identifying the object with the lowest predictive cohesion score within the least recently accessed dynamic cluster, factoring in the steepest negative latency gradient and lowest sequential mapping priority.
    '''
    candid_obj_key = None
    min_cohesion_score = float('inf')
    min_sequential_index = float('inf')
    steepest_negative_gradient = float('inf')
    least_recent_cluster = None
    least_recent_time = float('inf')

    # Identify the least recently accessed cluster
    for cluster_id, keys in metadata["clusters"].items():
        if not keys:
            continue
        cluster_last_access_time = min(metadata["last_access_times"][key] for key in keys)
        if cluster_last_access_time < least_recent_time:
            least_recent_time = cluster_last_access_time
            least_recent_cluster = cluster_id

    # Find the eviction candidate within the least recently accessed cluster
    if least_recent_cluster is not None:
        for key in metadata["clusters"][least_recent_cluster]:
            cohesion_score = metadata["cohesion_scores"][key]
            latency_gradient = metadata["latency_gradients"][key]
            sequential_index = metadata["sequential_indices"][key]

            if (cohesion_score < min_cohesion_score or
                (cohesion_score == min_cohesion_score and latency_gradient < steepest_negative_gradient) or
                (cohesion_score == min_cohesion_score and latency_gradient == steepest_negative_gradient and sequential_index < min_sequential_index)):
                min_cohesion_score = cohesion_score
                steepest_negative_gradient = latency_gradient
                min_sequential_index = sequential_index
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    # Increment predictive cohesion score
    metadata["cohesion_scores"][key] += COHESION_SCORE_INCREMENT

    # Recalculate latency gradient
    current_time = cache_snapshot.access_count
    last_access_time = metadata["last_access_times"].get(key, current_time)
    time_difference = current_time - last_access_time
    metadata["latency_gradients"][key] = LATENCY_GRADIENT_DECAY * metadata["latency_gradients"].get(key, NEUTRAL_LATENCY_GRADIENT) - time_difference

    # Update sequential mapping index
    metadata["sequential_indices"][key] = current_time

    # Update last access time
    metadata["last_access_times"][key] = current_time

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Assign initial predictive cohesion score
    metadata["cohesion_scores"][key] = INITIAL_COHESION_SCORE

    # Place the object into a dynamic cluster
    # For simplicity, group objects by size similarity (e.g., same size -> same cluster)
    cluster_id = obj.size
    if cluster_id not in metadata["clusters"]:
        metadata["clusters"][cluster_id] = set()
    metadata["clusters"][cluster_id].add(key)
    metadata["object_to_cluster"][key] = cluster_id

    # Initialize latency gradient to neutral
    metadata["latency_gradients"][key] = NEUTRAL_LATENCY_GRADIENT

    # Assign sequential mapping index based on insertion order
    metadata["sequential_indices"][key] = current_time

    # Update last access time
    metadata["last_access_times"][key] = current_time

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key
    cluster_id = metadata["object_to_cluster"].get(evicted_key)

    # Remove evicted object from its cluster
    if cluster_id is not None:
        metadata["clusters"][cluster_id].remove(evicted_key)
        if not metadata["clusters"][cluster_id]:  # Remove empty cluster
            del metadata["clusters"][cluster_id]

    # Remove metadata for the evicted object
    metadata["cohesion_scores"].pop(evicted_key, None)
    metadata["object_to_cluster"].pop(evicted_key, None)
    metadata["latency_gradients"].pop(evicted_key, None)
    metadata["sequential_indices"].pop(evicted_key, None)
    metadata["last_access_times"].pop(evicted_key, None)

    # Recalibrate predictive cohesion scores of remaining objects in the same cluster
    if cluster_id is not None and cluster_id in metadata["clusters"]:
        for key in metadata["clusters"][cluster_id]:
            metadata["cohesion_scores"][key] = max(metadata["cohesion_scores"][key] - 1, 0)

    # Rebalance sequential mapping indices
    current_time = cache_snapshot.access_count
    for key in metadata["sequential_indices"]:
        metadata["sequential_indices"][key] = current_time