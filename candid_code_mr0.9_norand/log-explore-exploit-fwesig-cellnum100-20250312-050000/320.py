# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
PROBABILISTIC_OFFSET_BASE = 10  # Base value for probabilistic offset adjustments
ACCESS_PROBABILITY_DECAY = 0.9  # Decay factor for access probability updates

# Put the metadata specifically maintained by the policy below. The policy maintains three key metadata structures: (1) a Cascade Queue that stratifies objects into temporal layers based on recency, (2) a Predictive Fusion model that estimates future access probabilities for each object using historical patterns, and (3) a Probabilistic Offset table that introduces controlled randomness to balance between prediction accuracy and diversity in cache contents.
cascade_queue = defaultdict(deque)  # Temporal layers: {layer_index: deque([obj.key, ...])}
access_probabilities = defaultdict(float)  # Predictive Fusion model: {obj.key: access_probability}
probabilistic_offsets = defaultdict(int)  # Probabilistic Offset table: {obj.key: offset_value}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by first identifying the least recently used object in the lowest temporal layer of the Cascade Queue, then applying a weighted adjustment using the Predictive Fusion model's access probability, and finally introducing a small random offset from the Probabilistic Offset table to avoid deterministic eviction patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Identify the lowest temporal layer with objects
    for layer_index in sorted(cascade_queue.keys()):
        if cascade_queue[layer_index]:
            # Find the least recently used object in this layer
            lru_key = cascade_queue[layer_index][0]
            # Calculate the weighted score for eviction
            eviction_score = access_probabilities[lru_key] + probabilistic_offsets[lru_key]
            if candid_obj_key is None or eviction_score < (
                access_probabilities[candid_obj_key] + probabilistic_offsets[candid_obj_key]
            ):
                candid_obj_key = lru_key
    # Remove the selected object from the Cascade Queue
    for layer_index in cascade_queue:
        if candid_obj_key in cascade_queue[layer_index]:
            cascade_queue[layer_index].remove(candid_obj_key)
            break
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the accessed object is promoted to a higher temporal layer in the Cascade Queue, its access probability is recalibrated in the Predictive Fusion model based on the new access, and the Probabilistic Offset for that object is slightly adjusted to reflect its updated likelihood of future use.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Promote the object to a higher temporal layer
    for layer_index in sorted(cascade_queue.keys(), reverse=True):
        if obj.key in cascade_queue[layer_index]:
            cascade_queue[layer_index].remove(obj.key)
            cascade_queue[layer_index + 1].append(obj.key)
            break
    # Recalibrate the access probability
    access_probabilities[obj.key] = (
        access_probabilities[obj.key] * ACCESS_PROBABILITY_DECAY + 1
    )
    # Adjust the probabilistic offset
    probabilistic_offsets[obj.key] += 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, it is placed in the lowest temporal layer of the Cascade Queue, its initial access probability is estimated by the Predictive Fusion model, and a random Probabilistic Offset is assigned to introduce diversity in its future treatment.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Place the object in the lowest temporal layer
    cascade_queue[0].append(obj.key)
    # Estimate the initial access probability
    access_probabilities[obj.key] = 1.0
    # Assign an initial probabilistic offset
    probabilistic_offsets[obj.key] = PROBABILISTIC_OFFSET_BASE

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the Cascade Queue is rebalanced to maintain temporal stratification, the Predictive Fusion model is updated to reduce the weight of the evicted object's historical data, and the Probabilistic Offset table is recalibrated to ensure randomness remains evenly distributed across remaining objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Rebalance the Cascade Queue
    for layer_index in sorted(cascade_queue.keys()):
        if evicted_obj.key in cascade_queue[layer_index]:
            cascade_queue[layer_index].remove(evicted_obj.key)
            break
    # Update the Predictive Fusion model
    if evicted_obj.key in access_probabilities:
        del access_probabilities[evicted_obj.key]
    # Recalibrate the Probabilistic Offset table
    if evicted_obj.key in probabilistic_offsets:
        del probabilistic_offsets[evicted_obj.key]