# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
DEFAULT_PAS = 1.0  # Default Predictive Access Score for new objects
DEFAULT_SDV = 0.0  # Default Semantic Drift Vector for new objects
DEFAULT_HTI = 1.0  # Default Hybrid Temporal Index for new objects
DEFAULT_RSC = 0    # Default Recursive Stability Counter for new objects
PAS_DECAY_FACTOR = 0.9  # Decay factor for PAS recalibration
SDV_ADJUSTMENT_FACTOR = 0.1  # Adjustment factor for SDV recalibration
HTI_INCREMENT = 1.0  # Increment for HTI on access
RSC_INCREMENT = 1    # Increment for RSC on access
RSC_DECAY_FACTOR = 0.95  # Decay factor for RSC recalibration

# Put the metadata specifically maintained by the policy below. The policy maintains a Predictive Access Score (PAS) for each object, a Semantic Drift Vector (SDV) to track changes in access patterns, a Hybrid Temporal Index (HTI) combining recency and frequency, and a Recursive Stability Counter (RSC) to measure the stability of an object's access pattern over time.
metadata = {
    "PAS": defaultdict(lambda: DEFAULT_PAS),  # Predictive Access Score
    "SDV": defaultdict(lambda: DEFAULT_SDV),  # Semantic Drift Vector
    "HTI": defaultdict(lambda: DEFAULT_HTI),  # Hybrid Temporal Index
    "RSC": defaultdict(lambda: DEFAULT_RSC),  # Recursive Stability Counter
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evicts the object with the lowest combined score derived from PAS, SDV, HTI, and RSC, prioritizing objects with low predicted future access, high semantic drift, low temporal relevance, and unstable access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate the combined score for each object
        pas = metadata["PAS"][key]
        sdv = metadata["SDV"][key]
        hti = metadata["HTI"][key]
        rsc = metadata["RSC"][key]
        combined_score = pas - sdv + (1 / hti) - rsc

        # Find the object with the lowest combined score
        if combined_score < min_score:
            min_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the PAS is updated using a lightweight predictive model, the SDV is recalculated to reflect the current access context, the HTI is incremented to boost recency and frequency, and the RSC is adjusted to reflect increased stability of the object's access pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    metadata["PAS"][key] *= PAS_DECAY_FACTOR  # Decay PAS to reflect predictive adjustment
    metadata["SDV"][key] += SDV_ADJUSTMENT_FACTOR  # Adjust SDV to reflect current access context
    metadata["HTI"][key] += HTI_INCREMENT  # Increment HTI for recency and frequency
    metadata["RSC"][key] += RSC_INCREMENT  # Increment RSC for stability

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the PAS is initialized using historical or default predictive data, the SDV is set to a neutral baseline, the HTI is initialized to reflect immediate recency, and the RSC is set to a low value to allow stability to build over time.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata["PAS"][key] = DEFAULT_PAS  # Initialize PAS
    metadata["SDV"][key] = DEFAULT_SDV  # Set SDV to neutral baseline
    metadata["HTI"][key] = DEFAULT_HTI  # Initialize HTI for immediate recency
    metadata["RSC"][key] = DEFAULT_RSC  # Set RSC to low value

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the PAS of remaining objects is recalibrated to account for the removal, the SDV is adjusted to mitigate any semantic drift caused by the eviction, the HTI is normalized to maintain temporal balance, and the RSC is updated to reflect the impact of the eviction on stability.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    for key in cache_snapshot.cache.keys():
        # Recalibrate PAS
        metadata["PAS"][key] *= PAS_DECAY_FACTOR

        # Adjust SDV to mitigate semantic drift
        metadata["SDV"][key] -= SDV_ADJUSTMENT_FACTOR

        # Normalize HTI
        metadata["HTI"][key] = max(metadata["HTI"][key] - HTI_INCREMENT, DEFAULT_HTI)

        # Update RSC to reflect eviction impact
        metadata["RSC"][key] *= RSC_DECAY_FACTOR

    # Remove metadata for the evicted object
    del metadata["PAS"][evicted_key]
    del metadata["SDV"][evicted_key]
    del metadata["HTI"][evicted_key]
    del metadata["RSC"][evicted_key]