# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict
import math

# Put tunable constant parameters below
THS_DECAY_FACTOR = 0.9  # Decay factor for temporal harmonic score
PDS_DECAY_FACTOR = 0.8  # Decay factor for predictive differentiation score
SAM_WEIGHT = 0.5        # Weight for structural augmentation map in composite score
CCI_WEIGHT = 0.5        # Weight for contextual cohesion index in composite score

# Put the metadata specifically maintained by the policy below. The policy maintains a multi-dimensional metadata structure: (1) a temporal harmonic score (THS) for each object, calculated using a weighted average of recent access intervals, (2) a predictive differentiation score (PDS) that estimates future access likelihood based on patterns in past accesses, (3) a structural augmentation map (SAM) that tracks relationships between objects based on co-access patterns, and (4) a contextual cohesion index (CCI) that measures how well an object aligns with the current workload context.
metadata = {
    "THS": {},  # Temporal Harmonic Score: {key: score}
    "PDS": {},  # Predictive Differentiation Score: {key: score}
    "SAM": defaultdict(lambda: defaultdict(float)),  # Structural Augmentation Map: {key1: {key2: weight}}
    "CCI": {},  # Contextual Cohesion Index: {key: score}
    "last_access_time": {},  # Last access time for each object: {key: time}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by combining the THS, PDS, SAM, and CCI into a composite score. Objects with low temporal harmonic scores, low predictive differentiation scores, weak structural relationships, and poor contextual cohesion are prioritized for eviction. Ties are broken by favoring objects with the oldest last access time.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    current_time = cache_snapshot.access_count

    for key, cached_obj in cache_snapshot.cache.items():
        # Composite score calculation
        ths = metadata["THS"].get(key, 0)
        pds = metadata["PDS"].get(key, 0)
        sam = sum(metadata["SAM"][key].values()) * SAM_WEIGHT
        cci = metadata["CCI"].get(key, 0) * CCI_WEIGHT
        composite_score = ths + pds + sam + cci

        # Break ties by oldest last access time
        last_access_time = metadata["last_access_time"].get(key, 0)
        if composite_score < min_score or (composite_score == min_score and last_access_time < metadata["last_access_time"].get(candid_obj_key, 0)):
            min_score = composite_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the THS is recalculated to reflect the updated access interval, the PDS is adjusted based on the observed access pattern, the SAM is updated to strengthen the relationship between the accessed object and other recently accessed objects, and the CCI is recalibrated to reflect the object's alignment with the current workload context.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key

    # Update THS
    last_access_time = metadata["last_access_time"].get(key, current_time)
    interval = current_time - last_access_time
    metadata["THS"][key] = metadata["THS"].get(key, 0) * THS_DECAY_FACTOR + 1 / (interval + 1)

    # Update PDS
    metadata["PDS"][key] = metadata["PDS"].get(key, 0) * PDS_DECAY_FACTOR + 1

    # Update SAM
    for other_key in cache_snapshot.cache:
        if other_key != key:
            metadata["SAM"][key][other_key] += 1
            metadata["SAM"][other_key][key] += 1

    # Update CCI
    metadata["CCI"][key] = metadata["CCI"].get(key, 0) + 1

    # Update last access time
    metadata["last_access_time"][key] = current_time

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the THS is initialized based on the insertion time, the PDS is seeded with an initial prediction based on workload history, the SAM is updated to establish initial relationships with other objects in the cache, and the CCI is computed to assess the new object's relevance to the current workload context.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key

    # Initialize THS
    metadata["THS"][key] = 1 / (current_time + 1)

    # Seed PDS
    metadata["PDS"][key] = 1

    # Update SAM
    for other_key in cache_snapshot.cache:
        if other_key != key:
            metadata["SAM"][key][other_key] = 1
            metadata["SAM"][other_key][key] = 1

    # Compute CCI
    metadata["CCI"][key] = 1

    # Update last access time
    metadata["last_access_time"][key] = current_time

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the SAM is updated to weaken or remove relationships involving the evicted object, the CCI is recalibrated to reflect the removal's impact on workload alignment, and the PDS is adjusted to account for the absence of the evicted object in future predictions. The THS for the evicted object is discarded.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Remove THS
    metadata["THS"].pop(evicted_key, None)

    # Adjust PDS
    metadata["PDS"].pop(evicted_key, None)

    # Update SAM
    if evicted_key in metadata["SAM"]:
        for related_key in metadata["SAM"][evicted_key]:
            metadata["SAM"][related_key].pop(evicted_key, None)
        metadata["SAM"].pop(evicted_key, None)

    # Recalibrate CCI
    metadata["CCI"].pop(evicted_key, None)

    # Remove last access time
    metadata["last_access_time"].pop(evicted_key, None)