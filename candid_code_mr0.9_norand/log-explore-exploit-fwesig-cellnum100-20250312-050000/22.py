# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
SQ_CAPACITY_RATIO = 0.5  # Fraction of the total cache capacity allocated to SQ
MAX_FREQUENCY = 3        # Maximum frequency for an object
DEFAULT_PRIORITY = 1      # Default priority level for new objects

# Put the metadata specifically maintained by the policy below. The policy maintains a hybrid structure combining two FIFO queues (SQ and MQ) with a ghost queue (GQ) for tracking evicted objects, along with metadata for priority levels, data locality, and burst buffering. Each object also tracks its access frequency.
SQ = []  # FIFO queue for short-term objects
MQ = []  # FIFO queue for long-term objects
GQ = []  # Ghost queue for tracking evicted objects
metadata = {}  # Metadata for objects: {key: {'frequency', 'priority', 'locality', 'burst_buffering'}}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first checks if SQ exceeds its capacity. If so, objects are moved to MQ or evicted based on frequency. If MQ is full, the lowest-priority object in MQ is identified using priority levels, data locality, and burst buffering metadata. Objects with zero frequency or weak locality relationships are preferred for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    sq_capacity = int(SQ_CAPACITY_RATIO * cache_snapshot.capacity)

    # Check if SQ exceeds its capacity
    if len(SQ) > 0 and cache_snapshot.size + obj.size > sq_capacity:
        # Move objects from SQ to MQ or evict based on frequency
        while len(SQ) > 0 and cache_snapshot.size + obj.size > sq_capacity:
            sq_obj_key = SQ.pop(0)
            sq_obj = cache_snapshot.cache[sq_obj_key]
            if metadata[sq_obj_key]['frequency'] > 1:
                MQ.append(sq_obj_key)
            else:
                candid_obj_key = sq_obj_key
                break

    # If MQ is full or no candidate from SQ, evict from MQ
    if candid_obj_key is None and len(MQ) > 0:
        # Identify the lowest-priority object in MQ
        MQ.sort(key=lambda k: (metadata[k]['priority'], metadata[k]['locality'], metadata[k]['burst_buffering']))
        candid_obj_key = MQ.pop(0)

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a hit, the object's frequency is increased if below 3, its priority level is incremented, and its data locality relationships are strengthened. Burst buffering metadata is updated to reflect the access spike, and the object is repositioned in MQ or SQ based on its updated frequency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    if key in metadata:
        # Update frequency
        if metadata[key]['frequency'] < MAX_FREQUENCY:
            metadata[key]['frequency'] += 1

        # Increment priority level
        metadata[key]['priority'] += 1

        # Strengthen data locality relationships
        metadata[key]['locality'] += 1

        # Update burst buffering metadata
        metadata[key]['burst_buffering'] += 1

        # Reposition in MQ or SQ based on frequency
        if key in SQ and metadata[key]['frequency'] > 1:
            SQ.remove(key)
            MQ.append(key)
        elif key in MQ and metadata[key]['frequency'] <= 1:
            MQ.remove(key)
            SQ.append(key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    On insertion, the object is placed in SQ or MQ based on whether it was in GQ. Its frequency is initialized to 1, priority level is set to default, data locality metadata is updated to link it with nearby data, and burst buffering metadata is initialized to track potential access spikes.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    # Initialize metadata
    metadata[key] = {
        'frequency': 1,
        'priority': DEFAULT_PRIORITY,
        'locality': 0,
        'burst_buffering': 0
    }

    # Place in SQ or MQ based on GQ
    if key in GQ:
        GQ.remove(key)
        MQ.append(key)
    else:
        SQ.append(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    On eviction, the evicted object is added to GQ, and its frequency is no longer tracked. The priority levels of remaining objects are recalibrated, data locality relationships are adjusted to remove the evicted object, and burst buffering metadata is updated to account for the reduced cache capacity.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    # Add evicted object to GQ
    GQ.append(evicted_key)

    # Remove metadata for evicted object
    if evicted_key in metadata:
        del metadata[evicted_key]

    # Recalibrate priority levels
    for key in metadata:
        metadata[key]['priority'] = max(1, metadata[key]['priority'] - 1)

    # Adjust data locality relationships
    for key in metadata:
        metadata[key]['locality'] = max(0, metadata[key]['locality'] - 1)

    # Update burst buffering metadata
    for key in metadata:
        metadata[key]['burst_buffering'] = max(0, metadata[key]['burst_buffering'] - 1)