# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque

# Put tunable constant parameters below
SQ_CAPACITY = 0.5  # Fraction of the total cache capacity allocated to SQ
BASELINE_TEMPORAL_COHERENCE = 1.0
NEUTRAL_GRADIENT_DIFFUSION = 1.0
CONTEXTUAL_DRIFT_ADJUSTMENT_RATE = 0.01

# Put the metadata specifically maintained by the policy below. The policy maintains two FIFO queues (SQ and MQ) for cache objects, a ghost queue (GQ) for evicted objects, and a Predictive Heuristic Map (PHM) for each object. PHM tracks temporal coherence, gradient diffusion, and contextual drift adjustment. Each object also has a frequency counter.
SQ = deque()  # FIFO queue for short-term objects
MQ = deque()  # FIFO queue for long-term objects
GQ = deque()  # Ghost queue for evicted objects
PHM = {}  # Predictive Heuristic Map: {key: {'frequency', 'temporal_coherence', 'gradient_diffusion', 'contextual_drift'}}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    If SQ exceeds its capacity, objects are moved to MQ until an object with frequency < 2 is found or MQ is full. If MQ is full, the object with the lowest combined PHM score is evicted. If SQ is not full, the object with frequency < 2 is evicted. Evicted objects are added to GQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global SQ, MQ, GQ, PHM
    candid_obj_key = None
    sq_capacity_bytes = int(SQ_CAPACITY * cache_snapshot.capacity)

    # If SQ exceeds its capacity
    if sum(o.size for o in SQ) + obj.size > sq_capacity_bytes:
        while SQ:
            candidate = SQ.popleft()
            if PHM[candidate.key]['frequency'] < 2 or len(MQ) == 0:
                candid_obj_key = candidate.key
                break
            MQ.append(candidate)

    # If MQ is full or no candidate found in SQ
    if candid_obj_key is None:
        if len(MQ) > 0:
            # Evict the object with the lowest combined PHM score
            candid_obj_key = min(MQ, key=lambda o: (
                PHM[o.key]['temporal_coherence'] +
                PHM[o.key]['gradient_diffusion'] +
                PHM[o.key]['contextual_drift']
            )).key
            MQ = deque(o for o in MQ if o.key != candid_obj_key)

    # If SQ is not full
    if candid_obj_key is None:
        for candidate in SQ:
            if PHM[candidate.key]['frequency'] < 2:
                candid_obj_key = candidate.key
                SQ = deque(o for o in SQ if o.key != candid_obj_key)
                break

    # Add evicted object to GQ
    if candid_obj_key:
        GQ.append(cache_snapshot.cache[candid_obj_key])

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Increase the frequency of the hit object if it is less than 3. Update its temporal coherence score to reflect recent access, recalculate its gradient diffusion value, and adjust its contextual drift factor based on the current workload.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global PHM
    if obj.key in PHM:
        # Increase frequency if less than 3
        if PHM[obj.key]['frequency'] < 3:
            PHM[obj.key]['frequency'] += 1

        # Update temporal coherence
        PHM[obj.key]['temporal_coherence'] = cache_snapshot.access_count

        # Recalculate gradient diffusion
        PHM[obj.key]['gradient_diffusion'] += 1

        # Adjust contextual drift
        PHM[obj.key]['contextual_drift'] += CONTEXTUAL_DRIFT_ADJUSTMENT_RATE

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    Set the frequency of the inserted object to 1. Initialize its temporal coherence score to a baseline, set gradient diffusion to a neutral rate, and seed contextual drift adjustment based on the workload. Place the object in SQ or MQ based on whether it was in GQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global SQ, MQ, GQ, PHM
    # Initialize PHM for the object
    PHM[obj.key] = {
        'frequency': 1,
        'temporal_coherence': BASELINE_TEMPORAL_COHERENCE,
        'gradient_diffusion': NEUTRAL_GRADIENT_DIFFUSION,
        'contextual_drift': CONTEXTUAL_DRIFT_ADJUSTMENT_RATE
    }

    # Place the object in SQ or MQ based on whether it was in GQ
    if obj in GQ:
        MQ.append(obj)
        GQ = deque(o for o in GQ if o.key != obj.key)
    else:
        SQ.append(obj)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Add the evicted object to the rear of GQ and stop tracking its frequency. Recalibrate the PHM by slightly adjusting the contextual drift factors of remaining objects to adapt to workload changes.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global GQ, PHM
    # Add evicted object to the rear of GQ
    GQ.append(evicted_obj)

    # Stop tracking its frequency
    if evicted_obj.key in PHM:
        del PHM[evicted_obj.key]

    # Recalibrate PHM for remaining objects
    for key in PHM:
        PHM[key]['contextual_drift'] += CONTEXTUAL_DRIFT_ADJUSTMENT_RATE