# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
DEFAULT_PGS = 50  # Default Predictive Gradient Score for new objects
DEFAULT_TCF = 1.0  # Default Temporal Cascade Factor for new objects
PGS_INCREMENT = 10  # Increment for PGS on hit
TCF_DECAY = 0.95  # Decay factor for TCF on hit
DSM_LINK_STRENGTH = 0.1  # Initial link strength for DSM
PGS_ADJUSTMENT_AFTER_EVICTION = -5  # Adjustment to PGS after eviction

# Put the metadata specifically maintained by the policy below. The policy maintains a Predictive Gradient Score (PGS) for each object, combining Predictive Score, Gradient Entanglement Score, and Stability Index into a unified metric. It also tracks a Temporal Cascade Factor (TCF) to ensure fairness and account for temporal rebalancing, and a Dynamic Synchronization Map (DSM) to manage object dependencies and co-access patterns.
pgs = {}  # Predictive Gradient Score for each object (keyed by obj.key)
tcf = {}  # Temporal Cascade Factor for each object (keyed by obj.key)
dsm = defaultdict(lambda: defaultdict(float))  # Dynamic Synchronization Map (nested dict)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the object with the lowest PGS, adjusted by its TCF. If multiple candidates exist, the DSM is consulted to minimize disruption to related objects, prioritizing eviction of objects with weaker dependency links and less recent access.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    # Calculate the adjusted score (PGS / TCF) for each object in the cache
    for key, cached_obj in cache_snapshot.cache.items():
        adjusted_score = pgs[key] / tcf[key]
        if adjusted_score < min_score:
            min_score = adjusted_score
            candid_obj_key = key
        elif adjusted_score == min_score:
            # Use DSM to break ties: prioritize eviction of objects with weaker dependency links
            if sum(dsm[key].values()) < sum(dsm[candid_obj_key].values()):
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the PGS of the accessed object is incrementally adjusted using a combination of Predictive Interpolation and gradient-based updates from recent access patterns. The TCF of all other objects is slightly reduced to maintain fairness, and the DSM is updated to strengthen links to frequently co-accessed objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Incrementally adjust the PGS of the accessed object
    pgs[obj.key] += PGS_INCREMENT

    # Slightly reduce the TCF of all other objects
    for key in tcf:
        if key != obj.key:
            tcf[key] *= TCF_DECAY

    # Update DSM to strengthen links to frequently co-accessed objects
    for key in cache_snapshot.cache:
        if key != obj.key:
            dsm[obj.key][key] += DSM_LINK_STRENGTH
            dsm[key][obj.key] += DSM_LINK_STRENGTH

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, it is initialized with a moderate PGS derived from predictive coherence and access patterns of similar objects, and a neutral TCF. The DSM is updated to establish weak initial links to objects accessed in close temporal proximity, and the TCF of existing objects is slightly adjusted to accommodate the new entry.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Initialize PGS and TCF for the new object
    pgs[obj.key] = DEFAULT_PGS
    tcf[obj.key] = DEFAULT_TCF

    # Establish weak initial links in DSM
    for key in cache_snapshot.cache:
        dsm[obj.key][key] += DSM_LINK_STRENGTH
        dsm[key][obj.key] += DSM_LINK_STRENGTH

    # Slightly adjust the TCF of existing objects
    for key in tcf:
        if key != obj.key:
            tcf[key] *= TCF_DECAY

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the PGS of remaining objects is recalibrated to account for the removal, and the TCF is adjusted to ensure fairness. The DSM is pruned to remove dependencies involving the evicted object, and related objects' PGS is slightly adjusted to reflect the predictive impact of the eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Recalibrate the PGS of remaining objects
    for key in pgs:
        pgs[key] += PGS_ADJUSTMENT_AFTER_EVICTION

    # Adjust the TCF of remaining objects
    for key in tcf:
        tcf[key] *= TCF_DECAY

    # Prune DSM to remove dependencies involving the evicted object
    if evicted_obj.key in dsm:
        del dsm[evicted_obj.key]
    for key in dsm:
        if evicted_obj.key in dsm[key]:
            del dsm[key][evicted_obj.key]