# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
COHERENCE_WEIGHT = 0.4
WRITE_LATENCY_WEIGHT = 0.3
ACCESS_ARBITRATION_WEIGHT = 0.2
PAGE_SWAP_WEIGHT = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cache line, including a coherence score (indicating how often the data is shared across cores), a write latency score (tracking the average time taken for writes to this cache line), an access arbitration score (indicating contention levels for this cache line), and a page swap frequency (tracking how often the page containing this cache line has been swapped in/out).
metadata = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by calculating a composite score for each cache line using a weighted formula: (coherence score * 0.4) + (write latency score * 0.3) + (access arbitration score * 0.2) + (page swap frequency * 0.1). The cache line with the lowest composite score is evicted, prioritizing lines that are less shared, have higher write latencies, lower contention, and lower page swap activity.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate the composite score for each cached object
        meta = metadata[key]
        composite_score = (
            meta['coherence_score'] * COHERENCE_WEIGHT +
            meta['write_latency_score'] * WRITE_LATENCY_WEIGHT +
            meta['access_arbitration_score'] * ACCESS_ARBITRATION_WEIGHT +
            meta['page_swap_frequency'] * PAGE_SWAP_WEIGHT
        )
        # Find the object with the lowest composite score
        if composite_score < min_score:
            min_score = composite_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the coherence score is incremented slightly to reflect increased sharing, the write latency score is updated based on the most recent write operation (if applicable), the access arbitration score is adjusted based on the current contention level, and the page swap frequency remains unchanged.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    if key in metadata:
        metadata[key]['coherence_score'] += 1  # Increment coherence score
        # Update write latency score (example: assume a constant adjustment for simplicity)
        metadata[key]['write_latency_score'] = max(1, metadata[key]['write_latency_score'] - 1)
        # Adjust access arbitration score based on contention (example: assume contention is proportional to access count)
        metadata[key]['access_arbitration_score'] = cache_snapshot.access_count % 10

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the coherence score is initialized to a low default value, the write latency score is set based on the initial write operation (if any), the access arbitration score is initialized based on the current contention level, and the page swap frequency is set to the historical average for the page containing the new object.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata[key] = {
        'coherence_score': 1,  # Low default value
        'write_latency_score': 10,  # Example: assume an initial constant value
        'access_arbitration_score': cache_snapshot.access_count % 10,  # Example: based on current contention
        'page_swap_frequency': 5  # Example: assume a historical average
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a cache line, the metadata for the evicted line is logged for future analysis, and the composite score weights are dynamically adjusted (if necessary) to optimize future eviction decisions based on observed performance trends.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in metadata:
        # Log metadata for future analysis (example: print to console or store in a log)
        print(f"Evicted metadata: {metadata[evicted_key]}")
        # Remove metadata for the evicted object
        del metadata[evicted_key]
    
    # Example: Adjust weights dynamically (not implemented here, but could be based on observed trends)