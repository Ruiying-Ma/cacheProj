# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
HYBRID_GRADIENT_INCREMENT = 1
INITIAL_HYBRID_GRADIENT_SCORE = 0
INITIAL_HYBRID_ENTROPY_SCORE = 0
INITIAL_RESONANCE_LATENCY = 1
CONTEXTUAL_SCORE_ADJUSTMENT = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains a hybrid gradient score combining stochastic and probabilistic elements, a unified contextual score that adapts to workload patterns and access correlations, a resonance-latency map that tracks both object correlations and access latency trends, and a hybrid entropy score that reflects both semantic unpredictability and correlation strength.
hybrid_gradient_scores = {}
hybrid_entropy_scores = {}
resonance_latency_map = {}
unified_contextual_score = 0

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by identifying objects with the lowest hybrid gradient score, provided their hybrid entropy score is below the unified contextual score. If multiple candidates exist, the object with the highest value in the resonance-latency map is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_hybrid_gradient_score = float('inf')
    max_resonance_latency = float('-inf')

    for key, cached_obj in cache_snapshot.cache.items():
        if hybrid_entropy_scores[key] < unified_contextual_score:
            if hybrid_gradient_scores[key] < min_hybrid_gradient_score:
                min_hybrid_gradient_score = hybrid_gradient_scores[key]
                candid_obj_key = key
                max_resonance_latency = resonance_latency_map[key]
            elif hybrid_gradient_scores[key] == min_hybrid_gradient_score:
                if resonance_latency_map[key] > max_resonance_latency:
                    candid_obj_key = key
                    max_resonance_latency = resonance_latency_map[key]
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    On a cache hit, the hybrid gradient score of the accessed object is increased slightly, the unified contextual score is recalibrated based on recent workload and correlation patterns, the resonance-latency map is updated to reflect reduced latency and strengthened correlations for the object, and the hybrid entropy score is adjusted to reflect the updated predictability and correlation strength.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    hybrid_gradient_scores[key] += HYBRID_GRADIENT_INCREMENT
    global unified_contextual_score
    unified_contextual_score += CONTEXTUAL_SCORE_ADJUSTMENT
    resonance_latency_map[key] -= 1  # Reduced latency
    hybrid_entropy_scores[key] -= 0.1  # Adjusted for predictability

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its hybrid gradient score is initialized to a neutral value, the unified contextual score is adjusted to account for the new object and workload trends, the resonance-latency map is updated to include weak initial correlations and initial latency for the object, and its hybrid entropy score is set to a neutral value reflecting initial unpredictability.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    hybrid_gradient_scores[key] = INITIAL_HYBRID_GRADIENT_SCORE
    global unified_contextual_score
    unified_contextual_score += CONTEXTUAL_SCORE_ADJUSTMENT
    resonance_latency_map[key] = INITIAL_RESONANCE_LATENCY
    hybrid_entropy_scores[key] = INITIAL_HYBRID_ENTROPY_SCORE

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the unified contextual score is recalibrated to reflect the reduced cache size and workload dynamics, the resonance-latency map is updated to remove the evicted object and adjust correlations and latencies for remaining objects, and the hybrid entropy scores of remaining objects are slightly adjusted to account for the change in cache dynamics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    global unified_contextual_score
    unified_contextual_score -= CONTEXTUAL_SCORE_ADJUSTMENT
    del resonance_latency_map[evicted_key]
    del hybrid_gradient_scores[evicted_key]
    del hybrid_entropy_scores[evicted_key]

    for key in cache_snapshot.cache.keys():
        resonance_latency_map[key] += 1  # Adjust latency
        hybrid_entropy_scores[key] += 0.1  # Adjust entropy