# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict

# Put tunable constant parameters below
SDAP_BASELINE = 1.0  # Baseline value for SDAP factor
TQFS_DECAY_RATE = 0.9  # Decay rate for TQFS to reflect temporal patterns
CATEGORY_PROPORTION_WEIGHT = 0.5  # Weight for maintaining PEM balance

# Put the metadata specifically maintained by the policy below. The policy maintains a Temporal-Quantum Fusion Score (TQFS) that combines temporal access patterns and multi-dimensional gradient encoding. It tracks a Predictive Equilibrium Map (PEM) to balance diversity and predict future access likelihood. A Semantic Drift-Adaptive Priority (SDAP) factor is used to detect and adapt to shifts in access patterns. Recursive Fusion Pruning (RFP) metadata forecasts future access trends while ensuring proportional representation of object categories.
TQFS = defaultdict(float)  # Tracks the TQFS score for each object
SDAP = defaultdict(float)  # Tracks the SDAP factor for each object
PEM = defaultdict(int)  # Tracks the count of objects per category
RFP = defaultdict(float)  # Tracks future access predictions for each object
CATEGORY_MAP = {}  # Maps object keys to their categories

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evicts the object with the lowest combined TQFS and SDAP score, ensuring the PEM remains balanced. If multiple candidates exist, RFP is used to predict the object least likely to be accessed soon, and ties are broken by favoring objects with older temporal patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        combined_score = TQFS[key] + SDAP[key]
        if combined_score < min_score or (combined_score == min_score and RFP[key] < RFP[candid_obj_key]):
            min_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the TQFS is updated to reflect the object's increased recency and frequency. The PEM is adjusted to maintain proportional representation of the object's category. The SDAP factor is recalculated to account for any shifts in access patterns, and RFP metadata is refined using the new access data.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    TQFS[key] = TQFS.get(key, 0) * TQFS_DECAY_RATE + 1
    category = CATEGORY_MAP[key]
    PEM[category] += 1
    SDAP[key] = SDAP_BASELINE + (cache_snapshot.access_count - TQFS[key]) * 0.1
    RFP[key] = TQFS[key] / (cache_snapshot.access_count + 1)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its TQFS is initialized using its insertion context, and the PEM is updated to include the new object's category. The SDAP factor is set to a baseline value, and RFP metadata is seeded with initial predictions based on the object's insertion characteristics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    category = obj.key.split('_')[0]  # Example: Derive category from key prefix
    CATEGORY_MAP[key] = category
    TQFS[key] = 1
    PEM[category] += 1
    SDAP[key] = SDAP_BASELINE
    RFP[key] = 1 / (cache_snapshot.access_count + 1)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the TQFS and SDAP factor of the evicted object are removed. The PEM is rebalanced to account for the removed object's category, and RFP metadata is adjusted to exclude the evicted object's historical trends, ensuring future predictions remain accurate.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    category = CATEGORY_MAP.pop(evicted_key, None)
    if category:
        PEM[category] -= 1
        if PEM[category] == 0:
            del PEM[category]
    TQFS.pop(evicted_key, None)
    SDAP.pop(evicted_key, None)
    RFP.pop(evicted_key, None)