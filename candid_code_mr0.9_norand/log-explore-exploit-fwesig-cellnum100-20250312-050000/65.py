# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import math

# Put tunable constant parameters below
TEMPORAL_DECAY_FACTOR = 0.9  # Decay factor for temporal vector updates
PROBABILISTIC_SCORE_WEIGHT = 0.7  # Weight for probabilistic score in eviction decision
ENTROPY_WEIGHT = 0.3  # Weight for entropy in eviction decision

# Put the metadata specifically maintained by the policy below. The policy maintains a temporal vector for each cached object, representing its access patterns over time, a probabilistic score indicating its likelihood of future access, and a hierarchical entropy value that measures the unpredictability of its access pattern relative to other objects.
metadata = {
    "temporal_vectors": {},  # Maps obj.key to a list of access times
    "probabilistic_scores": {},  # Maps obj.key to a float score
    "entropy_values": {},  # Maps obj.key to a float entropy value
}

def calculate_entropy(temporal_vector):
    '''
    Helper function to calculate entropy based on a temporal vector.
    '''
    if not temporal_vector:
        return 0
    time_differences = [temporal_vector[i] - temporal_vector[i - 1] for i in range(1, len(temporal_vector))]
    if not time_differences:
        return 0
    total = sum(time_differences)
    probabilities = [diff / total for diff in time_differences]
    entropy = -sum(p * math.log2(p) for p in probabilities if p > 0)
    return entropy

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Combine probabilistic score, temporal vector synthesis, and entropy
        prob_score = metadata["probabilistic_scores"].get(key, 0)
        entropy = metadata["entropy_values"].get(key, 0)
        temporal_vector = metadata["temporal_vectors"].get(key, [])
        temporal_alignment = sum(temporal_vector)  # Synthesis of temporal vector

        # Calculate eviction score
        eviction_score = (
            PROBABILISTIC_SCORE_WEIGHT * (1 - prob_score) +
            ENTROPY_WEIGHT * entropy -
            TEMPORAL_DECAY_FACTOR * temporal_alignment
        )

        # Select the object with the lowest eviction score
        if eviction_score < min_score:
            min_score = eviction_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update temporal vector
    if key not in metadata["temporal_vectors"]:
        metadata["temporal_vectors"][key] = []
    metadata["temporal_vectors"][key].append(current_time)

    # Update probabilistic score
    recent_accesses = metadata["temporal_vectors"][key][-5:]  # Use the last 5 accesses
    if len(recent_accesses) > 1:
        avg_interval = sum(recent_accesses[i] - recent_accesses[i - 1] for i in range(1, len(recent_accesses))) / (len(recent_accesses) - 1)
        metadata["probabilistic_scores"][key] = 1 / (1 + avg_interval)
    else:
        metadata["probabilistic_scores"][key] = 1.0

    # Update entropy
    metadata["entropy_values"][key] = calculate_entropy(metadata["temporal_vectors"][key])

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Initialize temporal vector
    metadata["temporal_vectors"][key] = [current_time]

    # Initialize probabilistic score
    metadata["probabilistic_scores"][key] = 1.0  # Assume high likelihood of future access initially

    # Initialize entropy
    metadata["entropy_values"][key] = calculate_entropy(metadata["temporal_vectors"][key])

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key

    # Remove metadata for the evicted object
    if evicted_key in metadata["temporal_vectors"]:
        del metadata["temporal_vectors"][evicted_key]
    if evicted_key in metadata["probabilistic_scores"]:
        del metadata["probabilistic_scores"][evicted_key]
    if evicted_key in metadata["entropy_values"]:
        del metadata["entropy_values"][evicted_key]

    # Rebalance entropy and probabilistic scores for remaining objects
    for key in cache_snapshot.cache.keys():
        temporal_vector = metadata["temporal_vectors"].get(key, [])
        metadata["entropy_values"][key] = calculate_entropy(temporal_vector)

        recent_accesses = temporal_vector[-5:]  # Use the last 5 accesses
        if len(recent_accesses) > 1:
            avg_interval = sum(recent_accesses[i] - recent_accesses[i - 1] for i in range(1, len(recent_accesses))) / (len(recent_accesses) - 1)
            metadata["probabilistic_scores"][key] = 1 / (1 + avg_interval)
        else:
            metadata["probabilistic_scores"][key] = 1.0