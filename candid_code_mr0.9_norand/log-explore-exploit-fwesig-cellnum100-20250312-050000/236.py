# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
INITIAL_UPG = 1.0  # Initial Unified Priority Gradient
FAIRNESS_DECAY = 0.9  # Decay factor for fairness recalibration
LOCALITY_WEIGHT = 1.0  # Weight for Dynamic Locality Map in composite score
HEURISTIC_WEIGHT = 1.0  # Weight for Predictive Heuristic Index in composite score
UPG_WEIGHT = 1.0  # Weight for Unified Priority Gradient in composite score

# Put the metadata specifically maintained by the policy below. The policy maintains a Unified Priority Gradient (combining priority levels, stochastic scores, and temporal-contextual scores), a Dynamic Locality Map (integrating data locality and sequential trends), a Predictive Heuristic Index (capturing future access likelihood, workload phases, and burst buffering), a Fairness Synchronization Flag (ensuring fairness and adaptive scaling), and a Multi-Phase Cascade Timestamp (tracking multi-window recency and predictive adjustments).
metadata = {
    "UPG": {},  # Unified Priority Gradient: {key: float}
    "DLM": {},  # Dynamic Locality Map: {key: set of related keys}
    "PHI": {},  # Predictive Heuristic Index: {key: float}
    "FSF": {},  # Fairness Synchronization Flag: {key: bool}
    "MCT": {},  # Multi-Phase Cascade Timestamp: {key: int}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate composite score
        upg = metadata["UPG"].get(key, INITIAL_UPG)
        phi = metadata["PHI"].get(key, 0)
        dlm = len(metadata["DLM"].get(key, set()))
        mct = metadata["MCT"].get(key, 0)
        fsf = metadata["FSF"].get(key, False)

        # Composite score with bias against strong locality and high future access likelihood
        score = (
            UPG_WEIGHT * upg +
            HEURISTIC_WEIGHT * phi +
            LOCALITY_WEIGHT * dlm
        )
        if fsf:  # Deprioritize overused objects
            score *= FAIRNESS_DECAY
        # Break ties by favoring older objects
        score -= mct / cache_snapshot.access_count

        # Select the object with the minimum score
        if score < min_score:
            min_score = score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    # Increase Unified Priority Gradient
    metadata["UPG"][key] = metadata["UPG"].get(key, INITIAL_UPG) + 1
    # Update Dynamic Locality Map
    for related_key in cache_snapshot.cache:
        if related_key != key:
            metadata["DLM"].setdefault(key, set()).add(related_key)
            metadata["DLM"].setdefault(related_key, set()).add(key)
    # Adjust Predictive Heuristic Index
    metadata["PHI"][key] = metadata["PHI"].get(key, 0) + 1
    # Reset Fairness Synchronization Flag
    metadata["FSF"][key] = False
    # Update Multi-Phase Cascade Timestamp
    metadata["MCT"][key] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    # Initialize Unified Priority Gradient
    metadata["UPG"][key] = INITIAL_UPG
    # Update Dynamic Locality Map
    for related_key in cache_snapshot.cache:
        if related_key != key:
            metadata["DLM"].setdefault(key, set()).add(related_key)
            metadata["DLM"].setdefault(related_key, set()).add(key)
    # Initialize Predictive Heuristic Index
    metadata["PHI"][key] = 0
    # Set Fairness Synchronization Flag
    metadata["FSF"][key] = False
    # Set Multi-Phase Cascade Timestamp
    metadata["MCT"][key] = cache_snapshot.access_count

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key
    # Recalibrate Unified Priority Gradient for fairness
    for key in metadata["UPG"]:
        metadata["UPG"][key] *= FAIRNESS_DECAY
    # Adjust Dynamic Locality Map
    if evicted_key in metadata["DLM"]:
        for related_key in metadata["DLM"][evicted_key]:
            metadata["DLM"].get(related_key, set()).discard(evicted_key)
        del metadata["DLM"][evicted_key]
    # Recalibrate Predictive Heuristic Index
    for key in metadata["PHI"]:
        metadata["PHI"][key] += metadata["PHI"].get(evicted_key, 0) * 0.1
    # Update Fairness Synchronization Flag
    for key in metadata["FSF"]:
        metadata["FSF"][key] = False
    # Adjust Multi-Phase Cascade Timestamps
    for key in metadata["MCT"]:
        metadata["MCT"][key] = max(metadata["MCT"][key] - 1, 0)