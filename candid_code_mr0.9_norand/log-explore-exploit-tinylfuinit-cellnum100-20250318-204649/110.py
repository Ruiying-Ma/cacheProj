# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections
import time

# Put tunable constant parameters below
T1_CAPACITY = 0.5  # Fraction of total cache capacity allocated to T1
T2_CAPACITY = 0.5  # Fraction of total cache capacity allocated to T2
B1_CAPACITY = 0.5  # Fraction of total cache capacity allocated to B1
B2_CAPACITY = 0.5  # Fraction of total cache capacity allocated to B2

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, last access timestamp, disk I/O rate, network latency, user request pattern statistics, and the queue (T1 or T2) the object belongs to. It also tracks the recency of objects in T1 and T2, and maintains B1 and B2 as ghost queues.
access_frequency = collections.defaultdict(int)
last_access_timestamp = collections.defaultdict(int)
disk_io_rate = collections.defaultdict(float)
network_latency = collections.defaultdict(float)
user_request_pattern = collections.defaultdict(int)
queue_membership = collections.defaultdict(str)
recency_timestamp = collections.defaultdict(int)
T1 = collections.OrderedDict()
T2 = collections.OrderedDict()
B1 = collections.OrderedDict()
B2 = collections.OrderedDict()

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy calculates a weighted score for each object based on access frequency, recency of access, disk I/O rate, network latency, and user request patterns. Objects with lower scores are evicted first, prioritizing T1 for eviction if not empty, otherwise T2.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    def calculate_score(key):
        return (access_frequency[key] * 0.4 + 
                (cache_snapshot.access_count - last_access_timestamp[key]) * 0.3 + 
                disk_io_rate[key] * 0.1 + 
                network_latency[key] * 0.1 + 
                user_request_pattern[key] * 0.1)
    
    for key in T1:
        score = calculate_score(key)
        if score < min_score:
            min_score = score
            candid_obj_key = key
    
    if candid_obj_key is None:
        for key in T2:
            score = calculate_score(key)
            if score < min_score:
                min_score = score
                candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access frequency, last access timestamp, and user request pattern statistics for the object. It moves the object to the most-recently-used end of T2 and updates its recency timestamp.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    access_frequency[obj.key] += 1
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    user_request_pattern[obj.key] += 1
    
    if obj.key in T1:
        T1.pop(obj.key)
        T2[obj.key] = obj
    elif obj.key in T2:
        T2.move_to_end(obj.key)
    
    recency_timestamp[obj.key] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the access frequency and last access timestamp. It updates the disk I/O rate and network latency metadata based on the source of the object. The object is placed in T1 or T2 based on its previous presence in B1 or B2, updating the recency timestamp accordingly.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    access_frequency[obj.key] = 1
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    user_request_pattern[obj.key] = 1
    disk_io_rate[obj.key] = 0.0  # Placeholder, should be updated based on actual I/O rate
    network_latency[obj.key] = 0.0  # Placeholder, should be updated based on actual network latency
    
    if obj.key in B1:
        B1.pop(obj.key)
        T2[obj.key] = obj
    elif obj.key in B2:
        B2.pop(obj.key)
        T2[obj.key] = obj
    else:
        T1[obj.key] = obj
    
    recency_timestamp[obj.key] = cache_snapshot.access_count

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy removes its metadata and recalculates the overall disk I/O rate and network latency statistics. The evicted object is moved to the rear of B1 or B2 based on its original queue, and redundant objects are removed from the front of B1 or B2 if full.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    queue = queue_membership[key]
    
    del access_frequency[key]
    del last_access_timestamp[key]
    del disk_io_rate[key]
    del network_latency[key]
    del user_request_pattern[key]
    del recency_timestamp[key]
    del queue_membership[key]
    
    if queue == 'T1':
        B1[key] = evicted_obj
        if len(B1) > B1_CAPACITY * cache_snapshot.capacity:
            B1.popitem(last=False)
    elif queue == 'T2':
        B2[key] = evicted_obj
        if len(B2) > B2_CAPACITY * cache_snapshot.capacity:
            B2.popitem(last=False)
    
    # Recalculate overall disk I/O rate and network latency statistics
    total_io_rate = sum(disk_io_rate.values())
    total_network_latency = sum(network_latency.values())
    # Placeholder for actual recalculation logic