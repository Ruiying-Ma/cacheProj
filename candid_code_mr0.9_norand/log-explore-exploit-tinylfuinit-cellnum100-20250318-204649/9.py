# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
FREQUENCY_WEIGHT = 0.7
RECENCY_WEIGHT = 0.3
WRITE_BACK_PRIORITY = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, recency of access, and write-back status for each cache entry. Additionally, it tracks a 'heat' score combining frequency and recency to prioritize eviction candidates.
metadata = {
    'access_frequency': {},
    'recency_timestamp': {},
    'write_back_status': {},
    'heat_score': {}
}

def calculate_heat_score(key, cache_snapshot):
    frequency = metadata['access_frequency'].get(key, 0)
    recency = metadata['recency_timestamp'].get(key, 0)
    write_back = metadata['write_back_status'].get(key, False)
    
    heat_score = (FREQUENCY_WEIGHT * frequency) + (RECENCY_WEIGHT * (cache_snapshot.access_count - recency))
    if write_back:
        heat_score -= WRITE_BACK_PRIORITY
    return heat_score

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on the lowest 'heat' score, which is a weighted combination of access frequency and recency. Entries marked for write-back are given a slight priority to ensure data integrity.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    lowest_heat_score = float('inf')
    
    for key in cache_snapshot.cache:
        heat_score = calculate_heat_score(key, cache_snapshot)
        if heat_score < lowest_heat_score:
            lowest_heat_score = heat_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy increments the access frequency and updates the recency timestamp for the accessed entry. The 'heat' score is recalculated to reflect the increased frequency and updated recency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = metadata['access_frequency'].get(key, 0) + 1
    metadata['recency_timestamp'][key] = cache_snapshot.access_count
    metadata['heat_score'][key] = calculate_heat_score(key, cache_snapshot)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object into the cache, the policy initializes the access frequency to 1, sets the recency timestamp to the current time, and calculates the initial 'heat' score. Write-back status is set based on the nature of the data.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = 1
    metadata['recency_timestamp'][key] = cache_snapshot.access_count
    metadata['write_back_status'][key] = False  # Assuming write-back status is False by default
    metadata['heat_score'][key] = calculate_heat_score(key, cache_snapshot)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes all metadata associated with the evicted entry. It then recalculates the 'heat' scores for remaining entries to ensure accurate prioritization for future evictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in metadata['access_frequency']:
        del metadata['access_frequency'][evicted_key]
    if evicted_key in metadata['recency_timestamp']:
        del metadata['recency_timestamp'][evicted_key]
    if evicted_key in metadata['write_back_status']:
        del metadata['write_back_status'][evicted_key]
    if evicted_key in metadata['heat_score']:
        del metadata['heat_score'][evicted_key]
    
    for key in cache_snapshot.cache:
        metadata['heat_score'][key] = calculate_heat_score(key, cache_snapshot)