# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
COMPUTATION_COST_FACTOR = 1.0
ENCRYPTION_STATUS_FACTOR = 1.0
ACCESS_FREQUENCY_FACTOR = 1.0
LAST_ACCESS_TIMESTAMP_FACTOR = 1.0

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, last access timestamp, encryption status, and computation cost for each cache entry.
metadata = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on a weighted score combining low access frequency, old access timestamp, high computation cost, and encryption status, prioritizing entries with lower scores.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        access_frequency = metadata[key]['access_frequency']
        last_access_timestamp = metadata[key]['last_access_timestamp']
        computation_cost = metadata[key]['computation_cost']
        encryption_status = metadata[key]['encryption_status']
        
        score = (ACCESS_FREQUENCY_FACTOR / access_frequency) + \
                (LAST_ACCESS_TIMESTAMP_FACTOR * (cache_snapshot.access_count - last_access_timestamp)) + \
                (COMPUTATION_COST_FACTOR * computation_cost) + \
                (ENCRYPTION_STATUS_FACTOR * encryption_status)
        
        if score < min_score:
            min_score = score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access frequency by incrementing it, refreshes the last access timestamp to the current time, and recalculates the computation cost if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    metadata[key]['access_frequency'] += 1
    metadata[key]['last_access_timestamp'] = cache_snapshot.access_count
    # Recalculate computation cost if necessary (assuming it is a function of access frequency)
    metadata[key]['computation_cost'] = COMPUTATION_COST_FACTOR / metadata[key]['access_frequency']

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the access frequency to 1, sets the last access timestamp to the current time, records the encryption status, and computes the initial computation cost.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata[key] = {
        'access_frequency': 1,
        'last_access_timestamp': cache_snapshot.access_count,
        'encryption_status': 1 if obj.size % 2 == 0 else 0,  # Example encryption status based on size
        'computation_cost': COMPUTATION_COST_FACTOR
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes all associated metadata for the evicted entry and may adjust the computation cost analysis for remaining entries if the evicted entry had a significant impact.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in metadata:
        del metadata[evicted_key]
    
    # Adjust computation cost analysis for remaining entries if necessary
    for key in metadata:
        metadata[key]['computation_cost'] = COMPUTATION_COST_FACTOR / metadata[key]['access_frequency']