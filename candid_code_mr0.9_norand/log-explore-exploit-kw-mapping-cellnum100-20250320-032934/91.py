# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque
import heapq

# Put tunable constant parameters below
REPLICATION_THRESHOLD = 5  # Frequency threshold for replication

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency, stability score, sequence of access times, chronological order of insertion times, and a predictive model for future access probabilities. It also tracks multiple copies of frequently accessed data for fault tolerance.
access_frequency = defaultdict(int)
recency = {}
stability_score = defaultdict(int)
access_times = defaultdict(deque)
insertion_order = deque()
predictive_model = defaultdict(float)  # Simplified predictive model
replicated_objects = set()

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy predicts future access patterns using the model and considers the least likely to be accessed soon. If predictions are inconclusive, it evaluates candidates based on the lowest access frequency, least recent access, and lowest stability score, prioritizing the eviction of the least recently used copies of frequently accessed data only when necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    min_score = float('inf')
    for key, cached_obj in cache_snapshot.cache.items():
        score = predictive_model[key]
        if score < min_score:
            min_score = score
            candid_obj_key = key

    if candid_obj_key is None:
        # If predictions are inconclusive, use fallback criteria
        min_freq = float('inf')
        min_recency = float('inf')
        min_stability = float('inf')
        for key, cached_obj in cache_snapshot.cache.items():
            if access_frequency[key] < min_freq or \
               (access_frequency[key] == min_freq and recency[key] < min_recency) or \
               (access_frequency[key] == min_freq and recency[key] == min_recency and stability_score[key] < min_stability):
                min_freq = access_frequency[key]
                min_recency = recency[key]
                min_stability = stability_score[key]
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency, recency, stability score, and access time sequence of the accessed entry. It reorders the chronological list if necessary, retrains the predictive model with the new access data, and checks if the data should be replicated for fault tolerance based on its updated access frequency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    access_frequency[obj.key] += 1
    recency[obj.key] = cache_snapshot.access_count
    access_times[obj.key].append(cache_snapshot.access_count)
    stability_score[obj.key] = len(set(access_times[obj.key])) / len(access_times[obj.key])
    insertion_order.remove(obj.key)
    insertion_order.append(obj.key)
    predictive_model[obj.key] = access_frequency[obj.key] / (cache_snapshot.access_count + 1)

    if access_frequency[obj.key] >= REPLICATION_THRESHOLD:
        replicated_objects.add(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its access frequency, recency, stability score, records the current time in the access sequence and chronological order, and updates the predictive model with the new object data. It also determines if the new object should have multiple copies based on its initial access frequency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    access_frequency[obj.key] = 1
    recency[obj.key] = cache_snapshot.access_count
    access_times[obj.key] = deque([cache_snapshot.access_count])
    stability_score[obj.key] = 1
    insertion_order.append(obj.key)
    predictive_model[obj.key] = 1 / (cache_snapshot.access_count + 1)

    if access_frequency[obj.key] >= REPLICATION_THRESHOLD:
        replicated_objects.add(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy updates the metadata of the remaining entries to reflect the removal, removes the object's metadata from the access sequence and chronological order, and retrains the predictive model to exclude the evicted object. It ensures that any necessary copies of frequently accessed data are maintained for fault tolerance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    del access_frequency[evicted_obj.key]
    del recency[evicted_obj.key]
    del stability_score[evicted_obj.key]
    del access_times[evicted_obj.key]
    insertion_order.remove(evicted_obj.key)
    del predictive_model[evicted_obj.key]

    if evicted_obj.key in replicated_objects:
        replicated_objects.remove(evicted_obj.key)