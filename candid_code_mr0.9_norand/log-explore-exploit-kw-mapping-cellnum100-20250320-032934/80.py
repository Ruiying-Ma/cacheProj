# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below

# Put the metadata specifically maintained by the policy below. The policy maintains a circular pointer, a FIFO queue, a hierarchical tree structure, access frequency, and timestamps for each cached object.
circular_pointer = 0
fifo_queue = []
tree = {}
access_frequency = {}
timestamps = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy starts by checking the object at the current pointer position. If its frequency is zero, it is evicted. If not, the policy checks the front of the FIFO queue. If the object at the front has a low score, it is evicted. If neither condition is met, the policy traverses the tree to find and evict the object with the lowest score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global circular_pointer, fifo_queue, tree, access_frequency, timestamps
    candid_obj_key = None
    
    # Check the object at the current pointer position
    keys = list(cache_snapshot.cache.keys())
    if keys:
        current_key = keys[circular_pointer]
        if access_frequency[current_key] == 0:
            candid_obj_key = current_key
        else:
            # Check the front of the FIFO queue
            front_key = fifo_queue[0]
            if access_frequency[front_key] == 0:
                candid_obj_key = front_key
            else:
                # Traverse the tree to find the object with the lowest score
                min_score = float('inf')
                for key in tree:
                    score = access_frequency[key] + (cache_snapshot.access_count - timestamps[key])
                    if score < min_score:
                        min_score = score
                        candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the access frequency of the object is set to 1, its timestamp is updated, and it may be moved to a different node in the tree based on its new score. The FIFO queue remains unchanged.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global access_frequency, timestamps
    access_frequency[obj.key] = 1
    timestamps[obj.key] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, it is placed at the rear of the FIFO queue, in the appropriate node in the tree based on its initial access frequency and recency, and at the current pointer location with its frequency set to 1. The tree structure is updated to reflect the new object, and scores of affected nodes are recalculated.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global circular_pointer, fifo_queue, tree, access_frequency, timestamps
    fifo_queue.append(obj.key)
    tree[obj.key] = obj
    access_frequency[obj.key] = 1
    timestamps[obj.key] = cache_snapshot.access_count
    circular_pointer = (circular_pointer + 1) % len(cache_snapshot.cache)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, it is removed from the current pointer position, the front of the FIFO queue, and from its node in the tree. The node from which it was evicted is updated by recalculating the node's score. The tree structure is adjusted if necessary to maintain balance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global circular_pointer, fifo_queue, tree, access_frequency, timestamps
    if evicted_obj.key in fifo_queue:
        fifo_queue.remove(evicted_obj.key)
    if evicted_obj.key in tree:
        del tree[evicted_obj.key]
    if evicted_obj.key in access_frequency:
        del access_frequency[evicted_obj.key]
    if evicted_obj.key in timestamps:
        del timestamps[evicted_obj.key]
    circular_pointer = (circular_pointer - 1) % len(cache_snapshot.cache)