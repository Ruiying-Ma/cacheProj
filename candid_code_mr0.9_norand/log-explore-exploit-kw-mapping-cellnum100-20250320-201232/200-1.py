# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque, defaultdict

# Put tunable constant parameters below
INITIAL_THRESHOLD = 1
INITIAL_ACTIVATION = 0
INITIAL_PROBABILITY = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains two LRU queues (T1 and T2) with dynamic capacities, two FIFO ghost queues (B1 and B2), a graph with nodes representing cached items and edges representing access patterns, and global statistics on access patterns and workload characteristics. Each cached item has a threshold value, an activation level, a probability of eviction, and counters for access frequency and recency.
metadata = {
    "T1": deque(),
    "T2": deque(),
    "B1": deque(),
    "B2": deque(),
    
    # Cache state information
    "object_meta": {},
    "graph": defaultdict(dict),
    "global_access_frequency": 0,
    "global_access_recency": 0
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first identifies items with activation levels below their threshold values. Among these, it selects the item with the highest probability of eviction, which is dynamically adjusted based on access frequency and recency. If no such item exists, it evicts from the least-recently-used end of T1 if not empty, otherwise from T2. The graph is used to identify the node with the lowest connection score and access frequency for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    
    # Select items with activation levels below their threshold values
    eviction_candidates = [key for key, meta in metadata['object_meta'].items() if meta['activation_level'] < meta['threshold']]
    if eviction_candidates:
        # Select the item with the highest probability of eviction
        candid_obj_key = max(eviction_candidates, key=lambda key: metadata['object_meta'][key]['prob_eviction'])
        
    else:    
        # Check the least-recently-used end of T1 first
        if metadata['T1']:
            candid_obj_key = metadata['T1'].pop()
        elif metadata['T2']:
            candid_obj_key = metadata['T2'].pop()
        else:
            # As a fallback, evict the node with lowest connection score and access frequency from the graph
            candid_obj_key = min(metadata['graph'], key=lambda key: (sum(metadata['graph'][key].values()), metadata['object_meta'][key]['access_freq']))
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the object's recency is updated to the current timestamp, and it is moved to the most-recently-used end of T2. The access frequency and recency counters are incremented, the activation level is increased, and the probability of eviction is recalculated. The access frequency of the corresponding node in the graph is incremented, and the connection score is updated based on recent access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count
    
    # Update metadata
    meta = metadata['object_meta'][key]
    meta['recency'] = current_time
    meta['access_freq'] += 1
    meta['activation_level'] += 1
    meta['prob_eviction'] = 1 / (1 + meta['activation_level'] + meta['access_freq'])
    
    if key in metadata['T1']:
        metadata['T1'].remove(key)
        metadata['T2'].append(key)
    elif key in metadata['T2']:
        metadata['T2'].remove(key)
        metadata['T2'].append(key)
    
    # Update graph
    if key in metadata['graph']:
        metadata['graph'][key]['access_freq'] += 1
        for conn_key in metadata['graph'][key]:
            metadata['graph'][key][conn_key] += 1
    
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its recency is set to the current timestamp. If it was in B1 or B2, it is moved to the most-recently-used end of T2; otherwise, it is placed at the most-recently-used end of T1. Its initial threshold value and activation level are set based on global access patterns, and the probability of eviction is initialized. A new node is created in the graph with an initial access frequency of 1, and edges are added based on recent access patterns. Global statistics are updated to reflect the new insertion.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count
    
    # New metadata entry
    meta = {
        'threshold': INITIAL_THRESHOLD,
        'activation_level': INITIAL_ACTIVATION,
        'prob_eviction': INITIAL_PROBABILITY,
        'access_freq': 1,
        'recency': current_time
    }
    
    metadata['object_meta'][key] = meta
    
    # Place the object in T1 or T2
    if key in metadata['B1']:
        metadata['B1'].remove(key)
        metadata['T2'].append(key)
    elif key in metadata['B2']:
        metadata['B2'].remove(key)
        metadata['T2'].append(key)
    else:
        metadata['T1'].append(key)
    
    # Update graph node
    metadata['graph'][key] = {'access_freq': 1}
    
    # Update global statistics
    metadata['global_access_frequency'] += 1
    metadata['global_access_recency'] = current_time

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the evicted object is moved to the rear of B1 if from T1, or B2 if from T2. The corresponding node and its edges are removed from the graph, and connection scores of remaining nodes are recalculated if necessary. Global statistics are updated to reflect the eviction, and the thresholds and probabilities for remaining items may be adjusted based on the updated workload characteristics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Move evicted object to B1 or B2
    if evicted_key in metadata['T1']:
        metadata['T1'].remove(evicted_key)
        metadata['B1'].append(evicted_key)
    elif evicted_key in metadata['T2']:
        metadata['T2'].remove(evicted_key)
        metadata['B2'].append(evicted_key)
    
    # Remove from object metadata and graph
    if evicted_key in metadata['object_meta']:
        del metadata['object_meta'][evicted_key]

    if evicted_key in metadata['graph']:
        del metadata['graph'][evicted_key]
    
    # Update global statistics
    metadata['global_access_frequency'] -= 1