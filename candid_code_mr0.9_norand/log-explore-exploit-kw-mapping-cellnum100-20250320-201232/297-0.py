# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
SQ_CAPACITY = 0.2  # Percentage of total cache capacity allocated to SQ
MQ_CAPACITY = 0.7  # Percentage of total cache capacity allocated to MQ

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency (timestamp of last access), a probabilistic eviction score, and the queue position (SQ, MQ, or GQ) for each cache item. It also tracks the number of copies for frequently accessed data.
cache_metadata = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first checks if SQ exceeds its capacity. If so, it moves items from SQ to MQ until an item with frequency less than 2 is found or MQ is full. If MQ is full, it reduces the frequency of items in MQ until an item with zero frequency is found and evicts it. If SQ is not full, it calculates eviction probabilities for all items based on access frequency and recency, and evicts the item with the highest probability.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    evict_key = None
    # Check if SQ exceeds its capacity
    if cache_snapshot.size + obj.size > cache_snapshot.capacity * SQ_CAPACITY:
        # Move items from SQ to MQ
        sq_keys = [key for key, data in cache_metadata.items() if data['queue'] == 'SQ']
        mq_keys = [key for key, data in cache_metadata.items() if data['queue'] == 'MQ']
        
        for key in sq_keys:
            if len(mq_keys) >= cache_snapshot.capacity * MQ_CAPACITY:
                # MQ is full, reduce frequencies
                for mq_key in mq_keys:
                    cache_metadata[mq_key]['frequency'] -= 1
                    if cache_metadata[mq_key]['frequency'] <= 0:
                        evict_key = mq_key
                        break
            else:
                if cache_metadata[key]['frequency'] < 2:
                    evict_key = key
                    break
                cache_metadata[key]['queue'] = 'MQ'
                mq_keys.append(key)
                if len(sq_keys) > 1:
                    sq_keys.remove(key)
        
        if evict_key is None:
            evict_key = mq_keys[0] if mq_keys else sq_keys[0]

    else:
        # Calculate eviction probabilities for items
        for key, metadata in cache_metadata.items():
            recency_factor = cache_snapshot.access_count - metadata['recency']
            eviction_score = metadata['frequency'] / (recency_factor + 1)
            cache_metadata[key]['eviction_score'] = eviction_score

        # Evict item with highest eviction probability score
        evict_key = max(cache_metadata.items(), key=lambda item: item[1]['eviction_score'])[0]

    return evict_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increases the access frequency by 1 if it is less than 3, updates the recency timestamp, recalculates the probabilistic eviction score, and checks if multiple copies are needed based on updated access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    if cache_metadata[key]['frequency'] < 3:
        cache_metadata[key]['frequency'] += 1
    cache_metadata[key]['recency'] = cache_snapshot.access_count
    recency_factor = cache_snapshot.access_count - cache_metadata[key]['recency']
    cache_metadata[key]['eviction_score'] = cache_metadata[key]['frequency'] / (recency_factor + 1)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy sets its access frequency to 1, initializes its recency timestamp, calculates an initial probabilistic eviction score, and places it in SQ. If the object was in GQ, it is placed in MQ instead and removed from GQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    cache_metadata[key] = {
        'frequency': 1,
        'recency': cache_snapshot.access_count,
        'eviction_score': 1.0 / (cache_snapshot.access_count + 1),
        'queue': 'SQ'
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy updates the metadata to reflect the removal, places the evicted item in GQ, and adjusts the count of remaining copies if the item had multiple copies. It recalculates eviction probabilities for the remaining items.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    if key in cache_metadata:
        cache_metadata.pop(key)
    
    # Place evicted object in GQ with updated metadata
    cache_metadata[key] = {
        'frequency': 0,
        'recency': cache_snapshot.access_count,
        'eviction_score': 0.0,
        'queue': 'GQ'
    }

    # Calculate eviction probabilities for remaining items
    for key, metadata in cache_metadata.items():
        if metadata['queue'] != 'GQ':
            recency_factor = cache_snapshot.access_count - metadata['recency']
            metadata['eviction_score'] = metadata['frequency'] / (recency_factor + 1)