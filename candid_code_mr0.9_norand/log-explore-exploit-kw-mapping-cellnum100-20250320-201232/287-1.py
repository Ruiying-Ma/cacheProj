# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
MAX_CANDIDATES = 5  # Number of candidates to consider for eviction
ALPHA = 0.7  # Weightage factor for priority score
BETA = 0.3  # Weightage factor for recency

# Put the metadata specifically maintained by the policy below. The policy maintains a hierarchical structure with metadata for access frequency, recency, computational cost, priority score, and dynamic eviction probabilities. It also tracks workload characteristics and a list of heuristics for eviction voting.
cache_metadata = {
    'frequency': {},  # Object access frequency
    'recency': {},  # Recent access timestamp
    'priority': {},  # Priority score for each object
    'computational_cost': {},  # Computational cost for each object
    'level': {},  # Hierarchical level
    'heuristics': {},  # Heuristics and dynamic parameters
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evaluates multiple eviction candidates in parallel, using a combination of hierarchical prioritization, heuristic voting, and dynamically adjusted probability scores. Higher levels use stricter criteria, while lower levels use adaptive strategies with probability adjustments.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    
    victim_candidates = sorted(
        cache_snapshot.cache.keys(), 
        key=lambda k: (
            cache_metadata['priority'][k],
            cache_metadata['recency'][k],
            cache_snapshot.cache[k].size
        )
    )
    
    for candidate in victim_candidates[:MAX_CANDIDATES]:
        # Heuristic voting to select eviction candidate
        # Assuming lower priority score is better for eviction
        if candid_obj_key is None or cache_metadata['priority'][candidate] < cache_metadata['priority'][candid_obj_key]:
            candid_obj_key = candidate
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency, recency, and priority score of the accessed object. It adjusts the object's position in the hierarchy and recalculates its computational cost. The dynamic parameters and heuristics are also updated to reflect the new state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    freq = cache_metadata['frequency'].get(obj.key, 0) + 1
    recency = cache_snapshot.access_count
    
    cache_metadata['frequency'][obj.key] = freq
    cache_metadata['recency'][obj.key] = recency

    # Update priority score
    priority_score = ALPHA * freq + BETA * (1 / (recency + 1))
    cache_metadata['priority'][obj.key] = priority_score

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its access frequency, recency, computational cost, and priority score. The object is placed in the appropriate level based on its initial priority, and the dynamic parameters and heuristics are adjusted to reflect the new workload characteristics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    cache_metadata['frequency'][obj.key] = 1
    cache_metadata['recency'][obj.key] = cache_snapshot.access_count
    cache_metadata['computational_cost'][obj.key] = obj.size  # Simplified computational cost
    priority_score = ALPHA * 1 + BETA * (1 / (cache_snapshot.access_count + 1))
    cache_metadata['priority'][obj.key] = priority_score
    cache_metadata['level'][obj.key] = 0  # Initial level, could be adjusted based on policy

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the evicted object's metadata and updates the hierarchical structure. It recalculates the computational cost distribution, updates the dynamic parameters, and adjusts the eviction probability scores and heuristics to optimize future evictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    if evicted_obj.key in cache_metadata['frequency']:
        del cache_metadata['frequency'][evicted_obj.key]
    if evicted_obj.key in cache_metadata['recency']:
        del cache_metadata['recency'][evicted_obj.key]
    if evicted_obj.key in cache_metadata['priority']:
        del cache_metadata['priority'][evicted_obj.key]
    if evicted_obj.key in cache_metadata['computational_cost']:
        del cache_metadata['computational_cost'][evicted_obj.key]
    if evicted_obj.key in cache_metadata['level']:
        del cache_metadata['level'][evicted_obj.key]