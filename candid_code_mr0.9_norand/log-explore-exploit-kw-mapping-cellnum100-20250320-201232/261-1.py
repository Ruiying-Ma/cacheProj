# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
LRU_WEIGHT = 0.5
FREQUENCY_WEIGHT = 0.3
WORKLOAD_WEIGHT = 0.2

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency, group identifiers, dynamic scores, and overall cache hit/miss patterns and workload characteristics.
cache_metadata = {
    "access_frequency": {},  # Dictionary to track access frequencies of objects
    "recency": {},            # Dictionary to track recency of objects
    "group_id": {},           # Dictionary to track group identifiers of objects
    "dynamic_score": {},      # Dictionary to track dynamic scores of objects
    "overall_pattern": {}     # Metadata related to workload characteristics
}

def get_dynamic_score(key):
    frequency = cache_metadata["access_frequency"][key]
    recency = cache_metadata["recency"][key]
    workload_characteristic = cache_metadata["overall_pattern"].get(key, 0)
    return (FREQUENCY_WEIGHT * frequency) - (LRU_WEIGHT * recency) + (WORKLOAD_WEIGHT * workload_characteristic)

def evict(cache_snapshot, obj):
    candid_obj_key = None
    lru_group = None
    min_group_id = float('inf')
    
    # Determine the least recently used group
    for key in cache_snapshot.cache:
        group_id = cache_metadata["group_id"].get(key, 0)
        if group_id < min_group_id:
            min_group_id = group_id
            lru_group = group_id

    min_dynamic_score = float('inf')
    
    # In the least recently used group, find the object with the lowest dynamic score
    for key in cache_snapshot.cache:
        if cache_metadata["group_id"][key] == lru_group:
            dynamic_score = get_dynamic_score(key)
            if dynamic_score < min_dynamic_score:
                min_dynamic_score = dynamic_score
                candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    key = obj.key
    
    # Update recency
    cache_metadata["recency"][key] = cache_snapshot.access_count
    
    # Update access frequency
    if key in cache_metadata["access_frequency"]:
        cache_metadata["access_frequency"][key] += 1
    else:
        cache_metadata["access_frequency"][key] = 1
    
    # Update dynamic score
    cache_metadata["dynamic_score"][key] = get_dynamic_score(key)
    
    # Optionally adjust group identifier based on some logic, here we just keep it simple
    if key not in cache_metadata["group_id"]:
        cache_metadata["group_id"][key] = 0  # Initialize group ID if not present
    
    cache_metadata["overall_pattern"][key] = cache_metadata["overall_pattern"].get(key, 0) + 1

def update_after_insert(cache_snapshot, obj):
    key = obj.key
    
    # Initialize access frequency
    cache_metadata["access_frequency"][key] = 1
    
    # Initialize recency
    cache_metadata["recency"][key] = cache_snapshot.access_count
    
    # Initialize dynamic score
    cache_metadata["dynamic_score"][key] = get_dynamic_score(key)
    
    # Initialize group identifier
    cache_metadata["group_id"][key] = 0
    
    # Update overall access pattern
    cache_metadata["overall_pattern"][key] = 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    evicted_key = evicted_obj.key
    
    # Remove evicted object metadata
    if evicted_key in cache_metadata["access_frequency"]:
        del cache_metadata["access_frequency"][evicted_key]
    
    if evicted_key in cache_metadata["recency"]:
        del cache_metadata["recency"][evicted_key]
    
    if evicted_key in cache_metadata["group_id"]:
        del cache_metadata["group_id"][evicted_key]
    
    if evicted_key in cache_metadata["dynamic_score"]:
        del cache_metadata["dynamic_score"][evicted_key]
    
    if evicted_key in cache_metadata["overall_pattern"]:
        del cache_metadata["overall_pattern"][evicted_key]
    
    # Update dynamic scores of all objects if needed
    for key in cache_snapshot.cache:
        cache_metadata["dynamic_score"][key] = get_dynamic_score(key)

    # Optionally re-evaluate group identifiers or workload characteristics if needed, here we keep it simple