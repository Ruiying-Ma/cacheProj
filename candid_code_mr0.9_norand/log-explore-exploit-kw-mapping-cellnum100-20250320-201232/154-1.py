# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
WEIGHT_ACCESS_FREQUENCY = 0.5
WEIGHT_RECENCY = 0.3
WEIGHT_WAITING_TIME = 0.2

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cached object, including access frequency, recency of access, and the time the object has been in the cache.
metadata = {
    # key (obj.key): (access_frequency (int), recency (int), waiting_time (time))
}

def calculate_priority_score(access_freq, recency, waiting_time):
    return WEIGHT_ACCESS_FREQUENCY * access_freq + WEIGHT_RECENCY * recency + WEIGHT_WAITING_TIME * waiting_time

def evict(cache_snapshot, obj):
    candid_obj_key = None
    min_priority_score = float('inf')
    
    current_time = cache_snapshot.access_count

    for key, cached_obj in cache_snapshot.cache.items():
        access_freq, recency, waiting_time = metadata[key]
        waiting_time = current_time - recency  # Update waiting time to current snapshot
        
        priority_score = calculate_priority_score(access_freq, recency, waiting_time)
        
        if priority_score < min_priority_score:
            min_priority_score = priority_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    current_time = cache_snapshot.access_count
    key = obj.key
    
    if key in metadata:
        access_freq, _, _ = metadata[key]
        metadata[key] = (access_freq + 1, current_time, 0)

def update_after_insert(cache_snapshot, obj):
    current_time = cache_snapshot.access_count
    key = obj.key
    
    metadata[key] = (1, current_time, 0)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    evicted_key = evicted_obj.key
    
    if evicted_key in metadata:
        del metadata[evicted_key]
    
    # Recalculate priority scores for remaining objects
    current_time = cache_snapshot.access_count
    for key in metadata:
        access_freq, recency, _ = metadata[key]
        waiting_time = current_time - recency
        metadata[key] = (access_freq, recency, waiting_time)