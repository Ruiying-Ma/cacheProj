# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
ALPHA = 0.75
BETA = 0.25

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, last access time, and a relevance score for each cached item. It also tracks overall access patterns and workload characteristics to dynamically adjust its strategy.
metadata = {}
overall_access_patterns = {
    'total_accesses': 0,
    'total_relevance': 0.0,
    'object_count': 0
}

def evict(cache_snapshot, obj):
    # This function defines how the policy chooses the eviction victim.
    # The policy chooses the eviction victim by evaluating a combination of low access frequency, older last access time, and low relevance score. Items that contribute the least to the overall data representation are prioritized for eviction.
    candid_obj_key = None
    min_score = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        frequency = metadata[key]['frequency']
        last_access_time = metadata[key]['last_access_time']
        relevance_score = metadata[key]['relevance_score']

        # Calculate the criterion score
        score = ALPHA * frequency + BETA * (cache_snapshot.access_count - last_access_time) + (1 - relevance_score)

        # Choose the item with the lowest score
        if score < min_score:
            min_score = score
            candid_obj_key = key
            
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    # This function defines how the policy update the metadata it maintains immediately after a cache hit.
    crucial_metadata = metadata[obj.key]
    crucial_metadata['frequency'] += 1
    crucial_metadata['last_access_time'] = cache_snapshot.access_count

    # Update relevance based on current access patterns
    crucial_metadata['relevance_score'] = crucial_metadata['frequency'] / overall_access_patterns['total_accesses']

def update_after_insert(cache_snapshot, obj):
    # This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    metadata[obj.key] = {
        'frequency': 1,
        'last_access_time': cache_snapshot.access_count,
        'relevance_score': 1.0 / (overall_access_patterns['object_count'] + 1)
    }
    
    overall_access_patterns['total_accesses'] += 1
    overall_access_patterns['object_count'] += 1
    overall_access_patterns['total_relevance'] += metadata[obj.key]['relevance_score']

def update_after_evict(cache_snapshot, obj, evicted_obj):
    # This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    evicted_metadata = metadata.pop(evicted_obj.key)
    
    overall_access_patterns['total_accesses'] -= evicted_metadata['frequency']
    overall_access_patterns['total_relevance'] -= evicted_metadata['relevance_score']
    overall_access_patterns['object_count'] -= 1

    if overall_access_patterns['object_count'] > 0:
        for key in metadata:
            metadata[key]['relevance_score'] = metadata[key]['frequency'] / overall_access_patterns['total_accesses']
    else:
        overall_access_patterns['total_relevance'] = 0