# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
K_LEVELS = 3  # Number of levels in the multi-level structure

# Put the metadata specifically maintained by the policy below. The policy maintains a multi-level structure with each level having an LFU queue with recency as the tie breaker, a frequency counter, an LRU queue, a circular pointer, and a priority score based on access frequency and age.
class CachePolicy:
    def __init__(self):
        self.levels = [{} for _ in range(K_LEVELS)]  # LFU caches and metadata for each level
        self.recency = {}  # Recency timestamp for each object
        self.frequency = {}  # Frequency counter for each object
        self.pointer = 0  # Circular pointer for cache eviction
        self.mru_order = []  # Keys in the most-recently-used order

    def evict(self, cache_snapshot, obj):
        candid_obj_key = None
        obj_size = obj.size
        pointer_level = 0
        total_evict_size = 0
        
        while total_evict_size < obj_size:
            pointer = self.pointer
            found = False
            for level in range(K_LEVELS):
                if pointer in self.levels[level]:
                    if self.frequency[pointer] == 0:
                        candid_obj_key = pointer
                        total_evict_size += cache_snapshot.cache[candid_obj_key].size
                        del self.levels[level][pointer]
                        del self.recency[candid_obj_key]
                        del self.frequency[candid_obj_key]
                        self.mru_order.remove(candid_obj_key)
                        found = True
                        pointer_level = level
                        break
                pointer = (pointer + 1) % len(self.levels[level])
            if found:
                self.pointer = pointer
                break
            for level in range(K_LEVELS):
                if len(self.levels[level]) > 0:
                    if pointer in self.levels[level]:
                        self.frequency[pointer] = 0
                        pointer = (pointer + 1) % len(self.levels[level])
            pointer_level = K_LEVELS - 1

        if total_evict_size < obj_size and pointer_level > 0:
            for level in range(pointer_level, -1, -1):
                if len(self.levels[level]) > 0:
                    recency_sorted = sorted(self.levels[level].items(), key=lambda item: item[1]['recency'])
                    for key, value in recency_sorted:
                        if total_evict_size >= obj_size:
                            break
                        candid_obj_key = key
                        total_evict_size += cache_snapshot.cache[candid_obj_key].size
                        del self.levels[level][candid_obj_key]
                        del self.recency[candid_obj_key]
                        del self.frequency[candid_obj_key]
                        self.mru_order.remove(candid_obj_key)

        return candid_obj_key

    def update_after_hit(self, cache_snapshot, obj):
        current_time = cache_snapshot.access_count
        obj_key = obj.key

        self.frequency[obj_key] += 1
        self.recency[obj_key] = current_time
        
        for level in self.levels:
            if obj_key in level:
                level[obj_key]['recency'] = current_time
                self.mru_order.remove(obj_key)
                self.mru_order.append(obj_key)
                break
        
    def update_after_insert(self, cache_snapshot, obj):
        current_time = cache_snapshot.access_count
        obj_key = obj.key

        self.frequency[obj_key] = 1
        self.recency[obj_key] = current_time
        self.mru_order.append(obj_key)
        self.pointer = (self.pointer + 1) % len(self.mru_order)

        self.levels[0][obj_key] = {
            'frequency': self.frequency[obj_key],
            'recency': current_time,
            'age': 0,
            'access_step': cache_snapshot.access_count,
            'priority_score': self.frequency[obj_key] + cache_snapshot.access_count - self.recency[obj_key]
        }

    def update_after_evict(self, cache_snapshot, obj, evicted_obj):
        evicted_obj_key = evicted_obj.key
        
        for level in self.levels:
            if evicted_obj_key in level:
                del level[evicted_obj_key]
                break
        
        if evicted_obj_key in self.recency:
            del self.recency[evicted_obj_key]
        
        if evicted_obj_key in self.frequency:
            del self.frequency[evicted_obj_key]
        
        if evicted_obj_key in self.mru_order:
            self.mru_order.remove(evicted_obj_key)
        
        for level in self.levels:
            for obj_key in level.keys():
                level[obj_key]['priority_score'] = self.frequency[obj_key] + cache_snapshot.access_count - self.recency[obj_key]

cache_policy = CachePolicy()