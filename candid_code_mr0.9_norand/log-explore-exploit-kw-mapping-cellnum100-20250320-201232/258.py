# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
INITIAL_PRIORITY = 1
INITIAL_IMPORTANCE = 1
INITIAL_ACCESS_FREQUENCY = 0

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cached object, including access frequency, importance score, and a priority level. It also tracks recent access patterns to predict future accesses and monitors the current workload to adapt the strategy dynamically.
metadata = {
    'access_frequency': {},  # obj.key -> access frequency
    'importance_score': {},  # obj.key -> importance score
    'priority_level': {},    # obj.key -> priority level
    'last_access_time': {}   # obj.key -> last access time
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by first identifying objects with the lowest priority level, then among those, selecting the object with the lowest predicted future access probability. If a tie occurs, it evicts the least recently used object.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    min_priority = float('inf')
    min_future_access_prob = float('inf')
    oldest_access_time = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        priority = metadata['priority_level'][key]
        future_access_prob = 1 / (metadata['access_frequency'][key] + 1)  # Simplified prediction
        last_access_time = metadata['last_access_time'][key]

        if (priority < min_priority or
            (priority == min_priority and future_access_prob < min_future_access_prob) or
            (priority == min_priority and future_access_prob == min_future_access_prob and last_access_time < oldest_access_time)):
            min_priority = priority
            min_future_access_prob = future_access_prob
            oldest_access_time = last_access_time
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the access frequency of the object, recalculates its importance score, and adjusts its priority level accordingly. It also updates the access pattern data to improve future predictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    metadata['access_frequency'][key] += 1
    metadata['importance_score'][key] = metadata['access_frequency'][key]  # Simplified importance calculation
    metadata['priority_level'][key] = metadata['importance_score'][key]  # Simplified priority calculation
    metadata['last_access_time'][key] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its access frequency, importance score, and priority level. It also updates the access pattern data to reflect the new object's insertion and adjusts the workload monitoring data.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    metadata['access_frequency'][key] = INITIAL_ACCESS_FREQUENCY
    metadata['importance_score'][key] = INITIAL_IMPORTANCE
    metadata['priority_level'][key] = INITIAL_PRIORITY
    metadata['last_access_time'][key] = cache_snapshot.access_count

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the metadata of the evicted object, recalculates the priority levels of remaining objects if necessary, and updates the workload monitoring data to reflect the change in the cache's state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_key = evicted_obj.key
    del metadata['access_frequency'][evicted_key]
    del metadata['importance_score'][evicted_key]
    del metadata['priority_level'][evicted_key]
    del metadata['last_access_time'][evicted_key]
    
    # Optionally, recalculate priority levels of remaining objects if necessary
    # This is a simplified example and may not be needed in all implementations
    for key in cache_snapshot.cache:
        metadata['priority_level'][key] = metadata['importance_score'][key]  # Simplified recalculation