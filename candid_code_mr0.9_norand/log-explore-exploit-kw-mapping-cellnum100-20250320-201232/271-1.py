# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
LFU_SCALING_FACTOR = 100  # Example scaling factor for LFU weight
RECENCY_SCALING_FACTOR = 5  # Example scaling factor for recency weight
CONNECTIVITY_SCALING_FACTOR = 20  # Example scaling factor for connectivity weight

# Put the metadata specifically maintained by the policy below.
from collections import defaultdict, deque
import time

# LRU Queue: Key -> Recency Order
lru_queue = deque()

# Frequency count: Key -> Frequency Count
frequency_count = defaultdict(int)

# Last access timestamp: Key -> Timestamp
last_access_timestamp = {}

# Miss ratio tracker
miss_ratio_tracker = {'hit_count': 0, 'miss_count': 0}

# Current strategy indicator
current_strategy = 'LRU'

# Relationship graph: Key -> (Adjacency List, Connectivity Score)
relationship_graph = defaultdict(lambda: ({}, 0))

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by combining the current strategy (LRU, LFU, FIFO) with the relationship graph. It identifies the item with the lowest combined score of priority, connectivity, and the current strategy's criteria. Items with weaker connections, lower access frequency/recency, and fitting the current strategy are prioritized for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_priority_score = float('inf')
    
    current_time = cache_snapshot.access_count
    
    for key, cached_obj in cache_snapshot.cache.items():
        # Calculate LRU score (Lower is more recently used)
        lru_score = current_time - last_access_timestamp[key]
        
        # Calculate LFU score (Lower is less frequently used)
        lfu_score = frequency_count[key]
        
        # Use Connectivity score from relationship graph
        connectivity_score = relationship_graph[key][1]
        
        # Combine the scores
        combined_score = (RECENCY_SCALING_FACTOR * lru_score) + \
                         (LFU_SCALING_FACTOR / (lfu_score + 1)) + \
                         (CONNECTIVITY_SCALING_FACTOR * connectivity_score)
        
        # Select the object with the lowest combined score
        if combined_score < min_priority_score:
            min_priority_score = combined_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the frequency count, updates the last access timestamp, sets the item's recency to the current timestamp, moves it to the most-recently-used end of the LRU queue, updates the priority score, and strengthens the edges between this item and other recently accessed items. The miss ratio tracker is recalculated to determine if a strategy switch is needed.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key
    
    # Increment frequency count
    frequency_count[key] += 1
    
    # Update last access timestamp
    last_access_timestamp[key] = current_time
    
    # Move obj to the end of LRU queue
    if key in lru_queue:
        lru_queue.remove(key)
    lru_queue.append(key)
    
    # Update the priority score
    # Since priority score is not explicitly stored, 
    # it is calculated dynamically when required in `evict`
    
    # Strengthen the edges between this item and other recently accessed items
    # We'll consider recent accesses in the last N activities to be relevant; here N=10
    N = 10
    recent_access_keys = list(lru_queue)[-N:]
    adj_list, connectivity_score = relationship_graph[key]
    
    for other_key in recent_access_keys:
        if other_key == key:
            continue
        if other_key in adj_list:
            adj_list[other_key] += 1
        else:
            adj_list[other_key] = 1
        
        other_adj_list, other_connectivity_score = relationship_graph[other_key]
        if key in other_adj_list:
            other_adj_list[key] += 1
        else:
            other_adj_list[key] = 1
        
        relationship_graph[key] = (adj_list, sum(adj_list.values()))
        relationship_graph[other_key] = (other_adj_list, sum(other_adj_list.values()))
    
    # Update miss ratio tracker
    miss_ratio_tracker['hit_count'] += 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the frequency count, records the current timestamp, sets the item's recency to the current timestamp, places it at the most-recently-used end of the LRU queue, initializes its priority and connectivity scores, and creates edges to other recently accessed items, adjusting their weights based on access patterns. The miss ratio tracker is updated to reflect the new state of the cache, and the strategy indicator may be adjusted based on the updated miss ratio.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key
    
    # Initialize frequency count
    frequency_count[key] = 1
    
    # Record the current timestamp
    last_access_timestamp[key] = current_time
    
    # Set item's recency to the current timestamp and place it at the end of LRU queue
    lru_queue.append(key)
    
    # Initialize priority and connectivity scores in the relationship graph
    relationship_graph[key] = ({}, 0)
    
    # Create edges to other recently accessed items and adjust weights
    recent_access_keys = list(lru_queue)[-10:]
    adj_list, connectivity_score = relationship_graph[key]
    
    for other_key in recent_access_keys:
        if other_key == key:
            continue
        adj_list[other_key] = 1
        other_adj_list, other_connectivity_score = relationship_graph[other_key]
        other_adj_list[key] = 1
        relationship_graph[other_key] = (other_adj_list, sum(other_adj_list.values()))
    
    relationship_graph[key] = (adj_list, sum(adj_list.values()))
    
    # Update miss ratio tracker
    miss_ratio_tracker['miss_count'] += 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy removes the frequency count and timestamp of the evicted item, removes the item from the LRU queue, removes the node and its edges from the relationship graph, recalculates the connectivity scores of the remaining connected items, and updates the miss ratio tracker. The strategy indicator is reassessed to ensure optimal performance based on the current workload.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    
    # Remove frequency count and timestamp
    if evicted_key in frequency_count:
        del frequency_count[evicted_key]
    if evicted_key in last_access_timestamp:
        del last_access_timestamp[evicted_key]
    
    # Remove item from the LRU queue
    if evicted_key in lru_queue:
        lru_queue.remove(evicted_key)
    
    # Remove node and its edges from the relationship graph
    if evicted_key in relationship_graph:
        adj_nodes, connectivity_score = relationship_graph[evicted_key]
        for other_key in adj_nodes:
            other_adj_nodes, other_connectivity_score = relationship_graph[other_key]
            if evicted_key in other_adj_nodes:
                del other_adj_nodes[evicted_key]
            relationship_graph[other_key] = (other_adj_nodes, sum(other_adj_nodes.values()))
        del relationship_graph[evicted_key]
    
    # Update miss ratio tracker
    miss_ratio_tracker['miss_count'] += 1
    
    # Strategy indicator can be reassessed if necessary, based on miss/hit ratio or cache workloads
    # For instance, switching between LRU, LFU or FIFO.
    # Here, it's kept minimal for simplicity.
    current_ratio = miss_ratio_tracker['hit_count'] / (miss_ratio_tracker['hit_count'] + miss_ratio_tracker['miss_count'])
    if current_ratio > 0.8:
        current_strategy = 'LFU'
    elif current_ratio < 0.2:
        current_strategy = 'FIFO'
    else:
        current_strategy = 'LRU'