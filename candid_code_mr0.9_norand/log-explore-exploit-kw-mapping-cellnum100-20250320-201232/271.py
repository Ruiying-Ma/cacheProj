# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque, defaultdict
import time

# Put tunable constant parameters below
# For simplicity, we can define some constants for the strategy switch thresholds
MISS_RATIO_THRESHOLD = 0.2

# Put the metadata specifically maintained by the policy below. The policy maintains an LRU queue, a frequency count, a timestamp of the last access, a miss ratio tracker, a current strategy indicator, and a relationship graph with nodes representing cached items and edges representing access correlations. Each node has a priority score based on access frequency and recency, and a connectivity score based on the number of edges and their weights.
lru_queue = deque()
frequency_count = defaultdict(int)
last_access_timestamp = {}
miss_ratio_tracker = []
current_strategy = 'LRU'  # Can be 'LRU', 'LFU', or 'FIFO'
relationship_graph = defaultdict(lambda: defaultdict(int))
priority_scores = defaultdict(int)
connectivity_scores = defaultdict(int)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by combining the current strategy (LRU, LFU, FIFO) with the relationship graph. It identifies the item with the lowest combined score of priority, connectivity, and the current strategy's criteria. Items with weaker connections, lower access frequency/recency, and fitting the current strategy are prioritized for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        if current_strategy == 'LRU':
            strategy_score = cache_snapshot.access_count - last_access_timestamp[key]
        elif current_strategy == 'LFU':
            strategy_score = frequency_count[key]
        elif current_strategy == 'FIFO':
            strategy_score = last_access_timestamp[key]
        
        combined_score = priority_scores[key] + connectivity_scores[key] + strategy_score
        
        if combined_score < min_score:
            min_score = combined_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the frequency count, updates the last access timestamp, sets the item's recency to the current timestamp, moves it to the most-recently-used end of the LRU queue, updates the priority score, and strengthens the edges between this item and other recently accessed items. The miss ratio tracker is recalculated to determine if a strategy switch is needed.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    frequency_count[obj.key] += 1
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    if obj.key in lru_queue:
        lru_queue.remove(obj.key)
    lru_queue.append(obj.key)
    
    priority_scores[obj.key] = frequency_count[obj.key] + (cache_snapshot.access_count - last_access_timestamp[obj.key])
    
    for other_key in lru_queue:
        if other_key != obj.key:
            relationship_graph[obj.key][other_key] += 1
            relationship_graph[other_key][obj.key] += 1
            connectivity_scores[obj.key] += relationship_graph[obj.key][other_key]
            connectivity_scores[other_key] += relationship_graph[other_key][obj.key]
    
    miss_ratio = cache_snapshot.miss_count / (cache_snapshot.hit_count + cache_snapshot.miss_count)
    miss_ratio_tracker.append(miss_ratio)
    
    if len(miss_ratio_tracker) > 10:
        miss_ratio_tracker.pop(0)
    
    avg_miss_ratio = sum(miss_ratio_tracker) / len(miss_ratio_tracker)
    
    if avg_miss_ratio > MISS_RATIO_THRESHOLD:
        current_strategy = 'LFU'
    else:
        current_strategy = 'LRU'

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the frequency count, records the current timestamp, sets the item's recency to the current timestamp, places it at the most-recently-used end of the LRU queue, initializes its priority and connectivity scores, and creates edges to other recently accessed items, adjusting their weights based on access patterns. The miss ratio tracker is updated to reflect the new state of the cache, and the strategy indicator may be adjusted based on the updated miss ratio.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    frequency_count[obj.key] = 1
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    lru_queue.append(obj.key)
    
    priority_scores[obj.key] = frequency_count[obj.key] + (cache_snapshot.access_count - last_access_timestamp[obj.key])
    connectivity_scores[obj.key] = 0
    
    for other_key in lru_queue:
        if other_key != obj.key:
            relationship_graph[obj.key][other_key] += 1
            relationship_graph[other_key][obj.key] += 1
            connectivity_scores[obj.key] += relationship_graph[obj.key][other_key]
            connectivity_scores[other_key] += relationship_graph[other_key][obj.key]
    
    miss_ratio = cache_snapshot.miss_count / (cache_snapshot.hit_count + cache_snapshot.miss_count)
    miss_ratio_tracker.append(miss_ratio)
    
    if len(miss_ratio_tracker) > 10:
        miss_ratio_tracker.pop(0)
    
    avg_miss_ratio = sum(miss_ratio_tracker) / len(miss_ratio_tracker)
    
    if avg_miss_ratio > MISS_RATIO_THRESHOLD:
        current_strategy = 'LFU'
    else:
        current_strategy = 'LRU'

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy removes the frequency count and timestamp of the evicted item, removes the item from the LRU queue, removes the node and its edges from the relationship graph, recalculates the connectivity scores of the remaining connected items, and updates the miss ratio tracker. The strategy indicator is reassessed to ensure optimal performance based on the current workload.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    del frequency_count[evicted_obj.key]
    del last_access_timestamp[evicted_obj.key]
    lru_queue.remove(evicted_obj.key)
    
    for other_key in relationship_graph[evicted_obj.key]:
        del relationship_graph[other_key][evicted_obj.key]
        connectivity_scores[other_key] -= relationship_graph[evicted_obj.key][other_key]
    
    del relationship_graph[evicted_obj.key]
    del priority_scores[evicted_obj.key]
    del connectivity_scores[evicted_obj.key]
    
    miss_ratio = cache_snapshot.miss_count / (cache_snapshot.hit_count + cache_snapshot.miss_count)
    miss_ratio_tracker.append(miss_ratio)
    
    if len(miss_ratio_tracker) > 10:
        miss_ratio_tracker.pop(0)
    
    avg_miss_ratio = sum(miss_ratio_tracker) / len(miss_ratio_tracker)
    
    if avg_miss_ratio > MISS_RATIO_THRESHOLD:
        current_strategy = 'LFU'
    else:
        current_strategy = 'LRU'