# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

from collections import deque, defaultdict

# Put tunable constant parameters below
SQ_CAPACITY = 10
MQ_CAPACITY = 20
T1_CAPACITY = 40
T2_CAPACITY = 40
GQ_CAPACITY = 10
B1_CAPACITY = 10
B2_CAPACITY = 10

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency, dependency score, combined score, and positions in FIFO (SQ, MQ) and LRU (T1, T2) queues. It also tracks ghost queues (GQ, B1, B2) for evicted items.

access_frequency = defaultdict(int)
recency = {}
dependency_score = {}
combined_score = {}
SQ = deque()
MQ = deque()
T1 = deque()
T2 = deque()
GQ = deque()
B1 = deque()
B2 = deque()

def calculate_dependency_score(key):
    # Example calculation - update with appropriate logic
    return 1 + access_frequency[key] * 0.5

def calculate_combined_score(key):
    return access_frequency[key] + recency[key] + dependency_score[key]

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects an eviction candidate based on the combined score, which integrates access frequency, recency, and dependency score. If SQ exceeds its capacity, items are moved to MQ. If MQ is full, frequencies are reduced until an item with zero frequency is found and evicted. Otherwise, the item with the lowest combined score is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Handle SQ overflow:
    if len(SQ) > SQ_CAPACITY:
        for _ in range(len(SQ) - SQ_CAPACITY):
            key = SQ.popleft()
            MQ.append(key)
    
    # Handle MQ full:
    while len(MQ) >= MQ_CAPACITY:
        for key in MQ:
            access_frequency[key] -= 1
            if access_frequency[key] == 0:
                MQ.remove(key)
                candid_obj_key = key
                break
        if candid_obj_key:
            break

    # Calculate combined score and find eviction candidate:
    if not candid_obj_key:
        lowest_score = float('inf')
        for key in list(SQ) + list(MQ):
            cur_score = combined_score[key]
            if cur_score < lowest_score:
                lowest_score = cur_score
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the access frequency is incremented by 1, recency is updated to the current timestamp, and the dependency score is recalculated. The combined score is updated. The item is moved to the most-recently-used end of T2.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    access_frequency[obj.key] += 1
    recency[obj.key] = cache_snapshot.access_count
    dependency_score[obj.key] = calculate_dependency_score(obj.key)
    combined_score[obj.key] = calculate_combined_score(obj.key)

    if obj.key in T2:
        T2.remove(obj.key)
    T2.append(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its access frequency is set to 1, recency to the current timestamp, and dependency score is calculated. The combined score is computed. If it was in ghost queues, it is placed in T2 and T2's capacity is expanded by preempting T1. Otherwise, it is placed in SQ or T1.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    access_frequency[obj.key] = 1
    recency[obj.key] = cache_snapshot.access_count
    dependency_score[obj.key] = calculate_dependency_score(obj.key)
    combined_score[obj.key] = calculate_combined_score(obj.key)
    
    if obj.key in GQ:
        GQ.remove(obj.key)
        T2.append(obj.key)
        if len(T2) > T2_CAPACITY:
            T1.appendleft(T2.popleft())
    else:
        if len(SQ) < SQ_CAPACITY:
            SQ.append(obj.key)
        elif len(T1) < T1_CAPACITY:
            T1.append(obj.key)
        else:
            SQ.append(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, if evicted from SQ, the item is moved to GQ. If from T1, to B1. If from T2, to B2. The dependency scores of remaining items are updated, and their combined scores are recalculated. Redundant items are removed from the front of GQ, B1, or B2 if full.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    if evicted_obj.key in SQ:
        SQ.remove(evicted_obj.key)
        GQ.append(evicted_obj.key)
        if len(GQ) > GQ_CAPACITY:
            GQ.popleft()
    elif evicted_obj.key in T1:
        T1.remove(evicted_obj.key)
        B1.append(evicted_obj.key)
        if len(B1) > B1_CAPACITY:
            B1.popleft()
    elif evicted_obj.key in T2:
        T2.remove(evicted_obj.key)
        B2.append(evicted_obj.key)
        if len(B2) > B2_CAPACITY:
            B2.popleft()
    
    for key in cache_snapshot.cache.keys():
        dependency_score[key] = calculate_dependency_score(key)
        combined_score[key] = calculate_combined_score(key)