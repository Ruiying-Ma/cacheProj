# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below

# Parameters for the eviction probability calculation
FREQUENCY_WEIGHT = 0.5
RECENCY_WEIGHT = 0.5

# Put the metadata specifically maintained by the policy below. The policy maintains a dependency graph where nodes represent cached objects and edges represent dependencies between them. Each object also has an access frequency counter and a recency timestamp.

access_frequency = {}  # Dictionary to maintain access frequency of objects
recency_timestamp = {}  # Dictionary to maintain recency timestamp of objects
dependencies = {}  # Dictionary to maintain dependencies: {key: set of dependent keys}

def calculate_eviction_probability(access_count, access_freq, recency_time, current_time, dependency_count):
    age = current_time - recency_time
    normalized_frequency = access_freq / (access_count + 1)
    normalized_recency = age / (current_time + 1)
    dependency_factor = 1 / (dependency_count + 1)
    
    eviction_score = (FREQUENCY_WEIGHT * normalized_frequency) + (RECENCY_WEIGHT * normalized_recency)
    
    return eviction_score * dependency_factor

def evict(cache_snapshot, obj):
    candid_obj_key = None
    lowest_eviction_score = float('inf')
    current_time = cache_snapshot.access_count

    for key in cache_snapshot.cache:
        access_freq = access_frequency.get(key, 0)
        recency_time = recency_timestamp.get(key, 0)
        dependency_count = len(dependencies.get(key, []))
        
        eviction_score = calculate_eviction_probability(cache_snapshot.access_count, access_freq, recency_time, current_time, dependency_count)
        if eviction_score < lowest_eviction_score:
            lowest_eviction_score = eviction_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    current_time = cache_snapshot.access_count
    
    # Increment the access frequency counter
    if obj.key in access_frequency:
        access_frequency[obj.key] += 1
    else:
        access_frequency[obj.key] = 1
    
    # Update the recency timestamp
    recency_timestamp[obj.key] = current_time

    # Update dependencies if necessary (stub for illustration, detail handling is context-specific)
    # This can include updating the dependency graph based on new hits or changes in relationship context

def update_after_insert(cache_snapshot, obj):
    current_time = cache_snapshot.access_count
    
    # Initialize frequency counter and recency timestamp
    access_frequency[obj.key] = 1
    recency_timestamp[obj.key] = current_time
    
    # Initialize dependencies (stub for illustration, detail handling is context-specific)
    dependencies[obj.key] = set()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    evicted_key = evicted_obj.key
    
    # Remove the evicted object from metadata
    if evicted_key in access_frequency:
        del access_frequency[evicted_key]
    if evicted_key in recency_timestamp:
        del recency_timestamp[evicted_key]
    if evicted_key in dependencies:
        del dependencies[evicted_key]

    # Update `dependencies` for all remaining objects
    for key in dependencies:
        if evicted_key in dependencies[key]:
            dependencies[key].remove(evicted_key)
            # Perform additional updates such as adjusting other metadata if they were dependent on the evicted object