# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections
import time

# Put tunable constant parameters below
ALPHA = 0.5 # Tuning parameter for calculating eviction probability

# Put the metadata specifically maintained by the policy below. The policy maintains two LRU queues (T1 and T2) with dynamic capacities, two FIFO ghost queues (B1 and B2), a graph with nodes representing cached items and edges representing access patterns, and global statistics on access patterns and workload characteristics. Each cached item has a threshold value, an activation level, a probability of eviction, and counters for access frequency and recency.
T1 = collections.OrderedDict()
T2 = collections.OrderedDict()
B1 = collections.OrderedDict()
B2 = collections.OrderedDict()
cache_graph = collections.defaultdict(lambda: {'freq': 0, 'edges': set()}) # Node: {freq: int, edges: set}
global_stats = {'access_patterns': {}, 'workload': {}}

def recalculate_probability_of_eviction(activation_level, threshold, access_freq, recency, current_time):
    return ALPHA * ((activation_level - threshold) / (access_freq + 1)) + (1 - ALPHA) * (current_time - recency)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first identifies items with activation levels below their threshold values. Among these, it selects the item with the highest probability of eviction, which is dynamically adjusted based on access frequency and recency. If no such item exists, it evicts from the least-recently-used end of T1 if not empty, otherwise from T2. The graph is used to identify the node with the lowest connection score and access frequency for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    lowest_probability = float('inf')
    current_time = cache_snapshot.access_count
    
    for key, cached_obj in T1.items():
        if cached_obj['activation_level'] < cached_obj['threshold']:
            probability = recalculate_probability_of_eviction(
                cached_obj['activation_level'],
                cached_obj['threshold'],
                cached_obj['access_freq'],
                cached_obj['recency'],
                current_time
            )
            if probability < lowest_probability:
                lowest_probability = probability
                candid_obj_key = key
    
    if candid_obj_key is None:
        for key, cached_obj in T2.items():
            if cached_obj['activation_level'] < cached_obj['threshold']:
                probability = recalculate_probability_of_eviction(
                    cached_obj['activation_level'],
                    cached_obj['threshold'],
                    cached_obj['access_freq'],
                    cached_obj['recency'],
                    current_time
                )
                if probability < lowest_probability:
                    lowest_probability = probability
                    candid_obj_key = key
    
    if candid_obj_key is None:
        if T1:
            candid_obj_key = next(iter(T1))
        else:
            candid_obj_key = next(iter(T2))
    
    # Remove node with lowest connection score and access frequency from graph
    if candid_obj_key is None:
        lowest_score_key = None
        lowest_score = float('inf')
        for key, node in cache_graph.items():
            score = node['freq'] + len(node['edges'])
            if score < lowest_score:
                lowest_score = score
                lowest_score_key = key
        if lowest_score_key:
            candid_obj_key = lowest_score_key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the object's recency is updated to the current timestamp, and it is moved to the most-recently-used end of T2. The access frequency and recency counters are incremented, the activation level is increased, and the probability of eviction is recalculated. The access frequency of the corresponding node in the graph is incremented, and the connection score is updated based on recent access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    if obj.key in T1:
        cached_item = T1.pop(obj.key)
    elif obj.key in T2:
        cached_item = T2.pop(obj.key)
    cached_item['recency'] = current_time
    cached_item['access_freq'] += 1
    cached_item['activation_level'] += 1
    cached_item['prob_of_eviction'] = recalculate_probability_of_eviction(
        cached_item['activation_level'],
        cached_item['threshold'],
        cached_item['access_freq'],
        cached_item['recency'],
        current_time
    )
    T2[obj.key] = cached_item
    cache_graph[obj.key]['freq'] += 1
    # Update the connection score here if required

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its recency is set to the current timestamp. If it was in B1 or B2, it is moved to the most-recently-used end of T2; otherwise, it is placed at the most-recently-used end of T1. Its initial threshold value and activation level are set based on global access patterns, and the probability of eviction is initialized. A new node is created in the graph with an initial access frequency of 1, and edges are added based on recent access patterns. Global statistics are updated to reflect the new insertion.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    initial_threshold = global_stats['access_patterns'].get('threshold', 5)
    initial_activation_level = 1

    if obj.key in B1:
        B1.pop(obj.key)
        T2[obj.key] = {
            'recency': current_time,
            'access_freq': 1,
            'activation_level': initial_activation_level,
            'threshold': initial_threshold,
            'prob_of_eviction': recalculate_probability_of_eviction(initial_activation_level, initial_threshold, 1, current_time, current_time)
        }
    elif obj.key in B2:
        B2.pop(obj.key)
        T2[obj.key] = {
            'recency': current_time,
            'access_freq': 1,
            'activation_level': initial_activation_level,
            'threshold': initial_threshold,
            'prob_of_eviction': recalculate_probability_of_eviction(initial_activation_level, initial_threshold, 1, current_time, current_time)
        }
    else:
        T1[obj.key] = {
            'recency': current_time,
            'access_freq': 1,
            'activation_level': initial_activation_level,
            'threshold': initial_threshold,
            'prob_of_eviction': recalculate_probability_of_eviction(initial_activation_level, initial_threshold, 1, current_time, current_time)
        }

    cache_graph[obj.key] = {'freq': 1, 'edges': set()}
    # Add edges based on recent access patterns here if needed

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the evicted object is moved to the rear of B1 if from T1, or B2 if from T2. The corresponding node and its edges are removed from the graph, and connection scores of remaining nodes are recalculated if necessary. Global statistics are updated to reflect the eviction, and the thresholds and probabilities for remaining items may be adjusted based on the updated workload characteristics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    if evicted_obj.key in T1:
        T1.pop(evicted_obj.key)
        B1[evicted_obj.key] = evicted_obj
    elif evicted_obj.key in T2:
        T2.pop(evicted_obj.key)
        B2[evicted_obj.key] = evicted_obj
    
    # Remove from graph
    if evicted_obj.key in cache_graph:
        del cache_graph[evicted_obj.key]

    # Recalculate connection scores here if needed
    # Adjust thresholds and probabilities for remaining items if needed
    # Update global statistics based on eviction