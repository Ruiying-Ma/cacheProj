# Import useful libraries
from collections import defaultdict, deque

# Put tunable constant parameters below
EVICTION_PERIOD = 10

# Put the metadata specifically maintained by the policy below. The policy maintains an LRU queue,
# a frequency count, a timestamp of the last access, a dynamic priority score, a miss ratio tracker,
# and a current strategy indicator (LRU, LFU, FIFO, LIFO).
lru_queue = deque()
frequency_count = defaultdict(int)
last_access_timestamp = {}
priority_score = {}
miss_ratio_tracker = [0]
strategy_indicator = 'LRU'

def compute_priority_score(key, strategy):
    '''
    Compute the priority score for a cache entry given a strategy.
    '''
    if strategy == 'LRU':
        return last_access_timestamp[key]
    elif strategy == 'LFU':
        return frequency_count[key]
    elif strategy == 'FIFO':
        return -last_access_timestamp[key]
    elif strategy == 'LIFO':
        return last_access_timestamp[key]
    else:
        raise ValueError(f"Unknown strategy: {strategy}")

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy periodically scans the cache and evicts the object with the lowest dynamic priority score,
    which is calculated based on a combination of LRU, LFU, FIFO, and LIFO principles.
    The strategy is dynamically adjusted based on the miss ratio tracker.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global strategy_indicator
    current_time = cache_snapshot.access_count

    # Update the strategy dynamically based on miss ratio
    miss_ratio = cache_snapshot.miss_count / max(1, cache_snapshot.access_count)
    miss_ratio_tracker.append(miss_ratio)
    if len(miss_ratio_tracker) > EVICTION_PERIOD:
        miss_ratio_tracker.pop(0)
        # Adjust strategy based on the pattern
        avg_miss_ratio = sum(miss_ratio_tracker) / len(miss_ratio_tracker)
        if avg_miss_ratio > 0.5:
            strategy_indicator = 'LFU'
        elif 0.2 < avg_miss_ratio <= 0.5:
            strategy_indicator = 'LRU'
        else:
            strategy_indicator = 'LIFO' if current_time % 2 else 'FIFO'

    # Find the entry with the lowest priority score based on current strategy
    candid_obj_key = min(cache_snapshot.cache.keys(),
                         key=lambda key: (compute_priority_score(key, strategy_indicator), key))
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the frequency count of the accessed item is incremented, the last access timestamp is updated,
    the item's recency is set to the current timestamp, it is moved to the most-recently-used end of the LRU queue,
    and the priority score is recalculated. The miss ratio tracker is updated to determine if a strategy switch is needed.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global strategy_indicator
    current_time = cache_snapshot.access_count
    obj_key = obj.key
    
    # Increment frequency count
    frequency_count[obj_key] += 1
    
    # Update last access timestamp
    last_access_timestamp[obj_key] = current_time
    
    # Move the object to the most-recently-used end of the LRU queue
    if obj_key in lru_queue:
        lru_queue.remove(obj_key)
    lru_queue.append(obj_key)
    
    # Recalculate priority score
    priority_score[obj_key] = compute_priority_score(obj_key, strategy_indicator)
    
    # Update the miss ratio tracker
    miss_ratio_tracker.append(cache_snapshot.miss_count / max(1, cache_snapshot.access_count))

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the frequency count is initialized, the current timestamp is recorded as the last access and insertion time,
    the item's recency is set to the current timestamp, it is placed at the most-recently-used end of the LRU queue, 
    a base priority score is assigned, and the miss ratio tracker is updated to reflect the new state of the cache.
    The strategy indicator may be adjusted based on the updated miss ratio.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global strategy_indicator
    current_time = cache_snapshot.access_count
    obj_key = obj.key
    
    # Initialize frequency count
    frequency_count[obj_key] = 1
    
    # Record the current timestamp as the last access and insertion time
    last_access_timestamp[obj_key] = current_time
    
    # Place the item at the MRU end of the LRU queue
    lru_queue.append(obj_key)
    
    # Assign a base priority score
    priority_score[obj_key] = compute_priority_score(obj_key, strategy_indicator)
    
    # Update the miss ratio tracker
    miss_ratio_tracker.append(cache_snapshot.miss_count / max(1, cache_snapshot.access_count))

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the frequency count, timestamp, and priority score of the evicted item are removed,
    the item is removed from the LRU queue, and the miss ratio tracker is updated.
    The strategy indicator is reassessed to ensure optimal performance based on the current workload.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global strategy_indicator
    evicted_key = evicted_obj.key
    
    # Remove the metadata associated with the evicted item
    if evicted_key in frequency_count:
        del frequency_count[evicted_key]
    if evicted_key in last_access_timestamp:
        del last_access_timestamp[evicted_key]
    if evicted_key in priority_score:
        del priority_score[evicted_key]
    if evicted_key in lru_queue:
        lru_queue.remove(evicted_key)
    
    # Update the miss ratio tracker
    miss_ratio_tracker.append(cache_snapshot.miss_count / max(1, cache_snapshot.access_count))