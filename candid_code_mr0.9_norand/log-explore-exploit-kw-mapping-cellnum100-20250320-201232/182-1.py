# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections

# Put tunable constant parameters below
ALGO1_WEIGHT = 0.5  # Weight for algorithm 1 (e.g., LRU)
ALGO2_WEIGHT = 0.5  # Weight for algorithm 2 (e.g., LFU)

# Put the metadata specifically maintained by the policy below. The policy maintains a log of eviction reasons, access frequency, recency of access, and a score for each algorithm's success rate in predicting the best eviction candidate.
access_freq = collections.defaultdict(int)
access_recency = collections.defaultdict(int)
algo_success_scores = {
    'algorithm1': collections.defaultdict(int),  # Recency-based (LRU)
    'algorithm2': collections.defaultdict(int),  # Frequency-based (LFU)
}
eviction_reasons_log = []


def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by evaluating the access frequency, recency, and the success scores of competing algorithms, selecting the item with the lowest combined score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global access_freq, access_recency, algo_success_scores
    
    candid_obj_key = None
    lowest_score = float('inf')
    current_time = cache_snapshot.access_count

    for key, cached_obj in cache_snapshot.cache.items():
        freq_score = ALGO2_WEIGHT * access_freq[key]
        recency_score = ALGO1_WEIGHT * (current_time - access_recency[key])
        combined_score = freq_score + recency_score

        # Choose object with the lowest combined score
        if combined_score < lowest_score:
            lowest_score = combined_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access frequency and recency for the accessed item, and adjusts the success scores of the algorithms based on their predictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global access_freq, access_recency, algo_success_scores
    
    current_time = cache_snapshot.access_count
    key = obj.key
    
    # Update access frequency and recency
    access_freq[key] += 1
    access_recency[key] = current_time

    # Adjust success scores based on predictions (example logic)
    algo_success_scores['algorithm2'][key] += 1  # Assuming LFU correctly predicted a hit
    algo_success_scores['algorithm1'][key] += 0  # Assuming LRU correctly predicted a hit for access by time

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its access frequency and recency, and logs the insertion reason, while also updating the success scores of the algorithms.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global access_freq, access_recency, algo_success_scores, eviction_reasons_log
    
    current_time = cache_snapshot.access_count
    key = obj.key

    # Initialize metadata
    access_freq[key] = 1
    access_recency[key] = current_time
    
    # Log insertion reason (example)
    eviction_reasons_log.append((key, "new_insertion"))

    # Update success scores (example logic)
    algo_success_scores['algorithm2'][key] = 0  # Initial scores for new insertions
    algo_success_scores['algorithm1'][key] = 0

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy logs the eviction reason, updates the success scores of the algorithms based on their predictions, and adjusts the access frequency and recency of remaining items if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global access_freq, access_recency, algo_success_scores, eviction_reasons_log
    
    evicted_key = evicted_obj.key

    # Log eviction reason (example)
    eviction_reasons_log.append((evicted_key, "eviction_due_to_insertion"))

    # Update success scores based on predictions (example logic)
    algo_success_scores['algorithm2'][evicted_key] += 1  # Assuming LFU positively predicted eviction
    algo_success_scores['algorithm1'][evicted_key] += 0  # Assuming LRU positively predicted eviction

    # Clean up metadata for the evicted item
    del access_freq[evicted_key]
    del access_recency[evicted_key]
    del algo_success_scores['algorithm2'][evicted_key]
    del algo_success_scores['algorithm1'][evicted_key]