# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import heapq
import time

# Put tunable constant parameters below
GQ_CAPACITY = 5  # Capacity for the ghost queue
B2_CAPACITY = 5  # Capacity for the T2 ghost queue
SUBSET_SIZE = 2  # The size of the subset of candidates to evaluate for eviction

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency timestamp, fitness score, and queue membership (SQ or T2) for each cached object. It also maintains ghost queues GQ and B2 with predetermined capacities.
metadata = {}
GQ = []
B2 = []

class CacheObjectMetadata:
    def __init__(self, frequency=1, access_time=0, queue="SQ"):
        self.frequency = frequency
        self.access_time = access_time
        self.queue = queue
        self.fitness = self.calculate_fitness()

    def calculate_fitness(self):
        return self.frequency / (time.time() - self.access_time + 1)  # Prevent division by zero

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy periodically evaluates all cached objects and probabilistically selects a subset of candidates based on their fitness scores. The least fit object from this subset is chosen for eviction. If the object is from SQ, it is moved to GQ; if from T2, it is moved to B2.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Select a subset of candidates based on fitness scores
    candidates = heapq.nsmallest(SUBSET_SIZE, cache_snapshot.cache, key=lambda k: metadata[k].fitness)
    candid_obj_key = candidates[-1]  # Choose the least fit object from the subset
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the access frequency of the object is incremented if it is less than 3, the recency timestamp is updated to the current time, and the fitness score is recalculated. If the object is in T2, it is moved to the most-recently-used end of T2.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    meta = metadata[obj.key]
    if meta.frequency < 3:
        meta.frequency += 1
    meta.access_time = cache_snapshot.access_count
    meta.fitness = meta.calculate_fitness()
    if meta.queue == "T2":
        # Move to MRU end of T2 (already in T2, just update access time)
        metadata[obj.key] = meta

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its access frequency is set to 1, its recency timestamp is set to the current time, and its fitness score is calculated. If the object was in GQ, it is moved to the rear of T2; otherwise, it is inserted at the rear of SQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    if obj.key in metadata and metadata[obj.key].queue == "GQ":
        metadata[obj.key].queue = "T2"
        B2.append(obj.key)
        if len(B2) > B2_CAPACITY:
            B2.pop(0)
    else:
        metadata[obj.key] = CacheObjectMetadata(access_time=cache_snapshot.access_count, queue="SQ")

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy recalculates the fitness scores of the remaining objects. The evicted object is moved to GQ if it was from SQ, or to B2 if it was from T2. The front object is removed from GQ or B2 if they are full.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_meta = metadata.pop(evicted_obj.key)
    if evicted_meta.queue == "SQ":
        GQ.append(evicted_obj.key)
        if len(GQ) > GQ_CAPACITY:
            GQ.pop(0)
    elif evicted_meta.queue == "T2":
        B2.append(evicted_obj.key)
        if len(B2) > B2_CAPACITY:
            B2.pop(0)

    # Recalculate fitness scores for remaining objects
    for key, meta in metadata.items():
        meta.fitness = meta.calculate_fitness()