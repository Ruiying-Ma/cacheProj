# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

from collections import defaultdict, deque

# Put tunable constant parameters below
ALPHA = 0.7  # Weight for frequency
BETA = 0.3   # Weight for recency
GAMMA = 1.0  # Priority score weight

EVICT_CANDIDATE_COUNT = 5

# Put the metadata specifically maintained by the policy below. The policy maintains a hierarchical structure with metadata for access frequency, recency, computational cost, priority score, and dynamic eviction probabilities. It also tracks workload characteristics and a list of heuristics for eviction voting.
access_frequency = defaultdict(int)
recency = defaultdict(int)
priority_score = defaultdict(float)
computational_cost = defaultdict(float)

dynamic_eviction_score = defaultdict(float)
workload_characteristics = {'total_accesses': 0, 'total_size': 0}
heuristics = []

def calculate_priority(obj):
    # Calculate the priority score for an object
    freq = access_frequency[obj.key]
    rec = recency[obj.key]
    cost = computational_cost[obj.key]
    return GAMMA * (ALPHA * freq - BETA * rec + cost)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evaluates multiple eviction candidates in parallel, using a combination of hierarchical prioritization, heuristic voting, and dynamically adjusted probability scores. Higher levels use stricter criteria, while lower levels use adaptive strategies with probability adjustments.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None

    # Identify EVICT_CANDIDATE_COUNT candidate objects based on priority score, heuristics, and dynamic eviction scores
    current_cache = cache_snapshot.cache
    current_time = cache_snapshot.access_count

    candidates = sorted(current_cache.values(), 
                        key=lambda o: (priority_score[o.key], -dynamic_eviction_score[o.key]))[:EVICT_CANDIDATE_COUNT]

    # Choose the candidate with the lowest priority score and highest eviction score
    selected_candidates = sorted(candidates, key=lambda o: (priority_score[o.key], dynamic_eviction_score[o.key]))
    
    if selected_candidates:
        candid_obj_key = selected_candidates[0].key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit. 
    Upon a cache hit, the policy updates the access frequency, recency, and priority score of the accessed object. 
    It adjusts the object's position in the hierarchy and recalculates its computational cost. 
    The dynamic parameters and heuristics are also updated to reflect the new state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    access_frequency[obj.key] += 1
    recency[obj.key] = cache_snapshot.access_count
    priority_score[obj.key] = calculate_priority(obj)

    # Heuristic update for dynamic parameters
    workload_characteristics['total_accesses'] += 1
    
    # Example update heuristic for dynamic eviction score (more sophisticated functions can be used)
    dynamic_eviction_score[obj.key] = workload_characteristics['total_size'] / workload_characteristics['total_accesses']

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache. 
    After inserting a new object, the policy initializes its access frequency, recency, computational cost, and priority score. 
    The object is placed in the appropriate level based on its initial priority, and the dynamic parameters and heuristics are adjusted to reflect the new workload characteristics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    access_frequency[obj.key] = 1
    recency[obj.key] = cache_snapshot.access_count
    computational_cost[obj.key] = obj.size  # Example of using size as computational cost
    priority_score[obj.key] = calculate_priority(obj)
    
    # Heuristic update for dynamic parameters
    workload_characteristics['total_size'] += obj.size

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the evicted object's metadata and updates the hierarchical structure.
    It recalculates the computational cost distribution, updates the dynamic parameters, and adjusts the eviction probability scores and heuristics to optimize future evictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    if evicted_obj.key in access_frequency:
        del access_frequency[evicted_obj.key]
        del recency[evicted_obj.key]
        del priority_score[evicted_obj.key]
        del computational_cost[evicted_obj.key]
        del dynamic_eviction_score[evicted_obj.key]
    
    workload_characteristics['total_size'] -= evicted_obj.size