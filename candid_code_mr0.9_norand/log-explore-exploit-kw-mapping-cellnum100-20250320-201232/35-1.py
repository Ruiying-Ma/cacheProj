# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
# e.g., number of groups
NUM_GROUPS = 4

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cache entry, including access frequency, last access time, and a group identifier. It also keeps global statistics on hit/miss rates and group access patterns.
metadata = {
    'access_frequency': {},  # maps obj.key to the frequency of access
    'last_access_time': {},  # maps obj.key to the last access time
    'group_identifier': {},  # maps obj.key to a group identifier
    'group_access_patterns': {i: 0 for i in range(NUM_GROUPS)},  # track accesses per group
    'global_statistics': {    # track global stats
        'hit_rate': 0,
        'miss_rate': 0,
    }
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim. The policy chooses 
    the eviction victim by first identifying the least frequently accessed group based 
    on collective access patterns. Within that group, it selects the least recently accessed entry for eviction.
    
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None

    # Identify the least frequently accessed group
    least_accessed_group = min(metadata['group_access_patterns'], key=metadata['group_access_patterns'].get)
    
    # Find the least recently accessed entry within that group
    candidate_keys = [key for key, group in metadata['group_identifier'].items() if group == least_accessed_group]
    if candidate_keys:
        candid_obj_key = min(candidate_keys, key=lambda key: metadata['last_access_time'][key])

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency and last access time for the accessed entry. 
    It also updates the global hit rate statistics and adjusts the group access pattern data.
    
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key

    # Update access frequency and last access time
    metadata['access_frequency'][key] += 1
    metadata['last_access_time'][key] = cache_snapshot.access_count

    # Update global hit rate statistics
    metadata['global_statistics']['hit_rate'] = cache_snapshot.hit_count / (cache_snapshot.hit_count + cache_snapshot.miss_count)

    # Update group access pattern
    group = metadata['group_identifier'][key]
    metadata['group_access_patterns'][group] += 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy assigns it to a group based on its access pattern. 
    It initializes the access frequency and last access time metadata and updates the global miss rate statistics.
    
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key

    # Assign a group based on a simple round-robin policy (for illustration purposes)
    group = min(metadata['group_access_patterns'], key=metadata['group_access_patterns'].get)
    metadata['group_identifier'][key] = group

    # Initialize access frequency and last access time
    metadata['access_frequency'][key] = 1
    metadata['last_access_time'][key] = cache_snapshot.access_count

    # Update global miss rate statistics
    metadata['global_statistics']['miss_rate'] = cache_snapshot.miss_count / (cache_snapshot.hit_count + cache_snapshot.miss_count)

    # Update group access pattern
    metadata['group_access_patterns'][group] += 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an entry, the policy updates the group access pattern data to reflect the removal. 
    It also adjusts the global statistics on hit/miss rates and re-evaluates group associations if necessary.
    
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Update group access pattern to reflect removal
    group = metadata['group_identifier'][evicted_key]
    del metadata['group_identifier'][evicted_key]
    del metadata['access_frequency'][evicted_key]
    del metadata['last_access_time'][evicted_key]
    metadata['group_access_patterns'][group] -= 1

    # Re-evaluate global statistics if necessary
    total_accesses = cache_snapshot.hit_count + cache_snapshot.miss_count
    metadata['global_statistics']['hit_rate'] = cache_snapshot.hit_count / total_accesses
    metadata['global_statistics']['miss_rate'] = cache_snapshot.miss_count / total_accesses