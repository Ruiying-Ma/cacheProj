# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections

# Put tunable constant parameters below
PARTITION_COUNT = 4

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, age, access sequence, priority score, partition information, hierarchical access paths, discovery timestamps, and LRU queue positions for each cached object.
metadata = {
    'access_frequency': collections.defaultdict(int),
    'age': collections.defaultdict(int),
    'access_step': collections.defaultdict(int),
    'priority_score': collections.defaultdict(float),
    'partition_info': collections.defaultdict(int),
    'hierarchical_paths': {},
    'discovery_timestamp': collections.defaultdict(int),
    'lru_queues': [collections.OrderedDict() for _ in range(PARTITION_COUNT)]
}
access_counter = 0

def calculate_priority(obj):
    return metadata['access_frequency'][obj.key] / (metadata['age'][obj.key] + 1) + 1 / (metadata['access_step'][obj.key] + 1)

def evict(cache_snapshot, obj):
    candid_obj_key = None
    min_priority_score = float('inf')
    partition_to_eviction_candidates = min(metadata['partition_info'].values(), default=0)
    
    for key, value in cache_snapshot.cache.items():
        if metadata['partition_info'][key] == partition_to_eviction_candidates:
            priority_score = calculate_priority(value)
            if priority_score < min_priority_score:
                min_priority_score = priority_score
                candid_obj_key = key

    if candid_obj_key is None:
        min_combined_score = float('inf')
        for key, value in cache_snapshot.cache.items():
            combined_score = metadata['age'][key] + metadata['priority_score'][key]
            if combined_score < min_combined_score:
                min_combined_score = combined_score
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    access_counter = cache_snapshot.access_count
    metadata['access_frequency'][obj.key] += 1
    metadata['age'][obj.key] = 0
    metadata['access_step'][obj.key] = access_counter
    metadata['priority_score'][obj.key] = calculate_priority(obj)
    lru_queue = metadata['lru_queues'][metadata['partition_info'][obj.key]]
    if obj.key in lru_queue:
        del lru_queue[obj.key]
    lru_queue[obj.key] = obj
    metadata['hierarchical_paths'][obj.key] = access_counter
    metadata['discovery_timestamp'][obj.key] = access_counter

def update_after_insert(cache_snapshot, obj):
    access_counter = cache_snapshot.access_count
    metadata['access_frequency'][obj.key] = 1
    metadata['age'][obj.key] = 0
    metadata['access_step'][obj.key] = access_counter
    metadata['priority_score'][obj.key] = calculate_priority(obj)
    metadata['lru_queues'][0][obj.key] = obj
    metadata['partition_info'][obj.key] = 0
    metadata['hierarchical_paths'][obj.key] = access_counter
    metadata['discovery_timestamp'][obj.key] = access_counter

def update_after_evict(cache_snapshot, obj, evicted_obj):
    del metadata['access_frequency'][evicted_obj.key]
    del metadata['age'][evicted_obj.key]
    del metadata['access_step'][evicted_obj.key]
    del metadata['priority_score'][evicted_obj.key]
    del metadata['partition_info'][evicted_obj.key]
    del metadata['hierarchical_paths'][evicted_obj.key]
    del metadata['discovery_timestamp'][evicted_obj.key]
    lru_queue = metadata['lru_queues'][metadata['partition_info'][evicted_obj.key]]
    if evicted_obj.key in lru_queue:
        del lru_queue[evicted_obj.key]