# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections
import math

# Put tunable constant parameters below
GROUP_SIZE = 10  # Example, this can be tuned.

# Put the metadata specifically maintained by the policy below. The policy maintains a fitness score for each cache entry, which is calculated based on access frequency, recency of access, and a trend factor indicating whether the access frequency is increasing or decreasing. Additionally, it keeps a combined access frequency for groups of cache lines.
access_freq = collections.defaultdict(int)
recency = collections.defaultdict(int)
trend = collections.defaultdict(float)
group_access_freq = collections.defaultdict(int)
fitness_score = collections.defaultdict(float)

def compute_fitness(key):
    # Example formula for fitness score computation, can be tuned
    AF_weight = 1.0
    R_weight = 0.5
    T_weight = 0.2
    return AF_weight * access_freq[key] + R_weight * (1 / (recency[key] + 1)) + T_weight * trend[key]

def get_group_key(key):
    # Example function to get the group for a cache key. This implementation assumes a hash approach.
    return hash(key) % GROUP_SIZE

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the cache entry with the lowest fitness score for eviction.
    If multiple entries have the same fitness score, it considers the combined access frequency of groups of cache lines and evicts the entry from the group with the lowest combined access frequency.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_fitness = float('inf')
    min_group_access_freq = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        group_key = get_group_key(key)
        fitness = fitness_score[key]
        group_freq = group_access_freq[group_key]

        if fitness < min_fitness or (fitness == min_fitness and group_freq < min_group_access_freq):
            min_fitness = fitness
            min_group_access_freq = group_freq
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increases the access frequency and updates the recency of access for the hit entry.
    It also recalculates the trend factor based on the change in access frequency and updates the combined access frequency for the group to which the entry belongs.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    prev_freq = access_freq[key]
    
    access_freq[key] += 1
    recency[key] = cache_snapshot.access_count
    trend[key] = access_freq[key] - prev_freq

    group_key = get_group_key(key)
    group_access_freq[group_key] += 1
    fitness_score[key] = compute_fitness(key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its fitness score, access frequency, recency of access, and trend factor. It also updates the combined access frequency for the group to which the new entry is added.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    access_freq[key] = 1
    recency[key] = cache_snapshot.access_count
    trend[key] = 0.0
    fitness_score[key] = compute_fitness(key)

    group_key = get_group_key(key)
    group_access_freq[group_key] += 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the evicted entry's metadata and recalculates the combined access frequency for the group from which the entry was evicted. It also adjusts the fitness scores of remaining entries if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    group_key = get_group_key(evicted_key)

    # Remove evicted entry's metadata
    del access_freq[evicted_key]
    del recency[evicted_key]
    del trend[evicted_key]
    del fitness_score[evicted_key]

    # Recalculate combined access frequency for the group
    group_access_freq[group_key] = sum(access_freq[key] for key in cache_snapshot.cache if get_group_key(key) == group_key)