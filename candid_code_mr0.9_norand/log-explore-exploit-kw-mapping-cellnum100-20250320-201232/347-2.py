# Import anything you need below. You must not use any randomness. For example, you cannot import random. Also, you cannot use any function in numpy that uses randomness, such as the functions in numpy.random.
import time

# Put tunable constant parameters below
LRU_WEIGHT = 1
LFU_WEIGHT = 1
MRU_WEIGHT = 1

# Put the metadata specifically maintained by the policy below. The policy maintains a FIFO queue, access timestamps, access frequencies, MRU flags, and a dynamic weight vector for LRU, LFU, and MRU strategies. It also keeps a list of potential eviction candidates and a feedback mechanism to track hit and miss rates.
fifo_queue = []
access_timestamps = {}
access_frequencies = {}
mru_flags = {}
dynamic_weights = {
    'LRU': LRU_WEIGHT,
    'LFU': LFU_WEIGHT,
    'MRU': MRU_WEIGHT
}
potential_eviction_candidates = set()
hit_rate = 0

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects eviction candidates based on a weighted combination of LRU, LFU, and MRU scores, with an additional consideration for the FIFO order. The final eviction victim is chosen from the candidates by evaluating real-time access patterns, system state, and FIFO position.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    for key in potential_eviction_candidates:
        lru_score = cache_snapshot.access_count - access_timestamps.get(key, 0)
        lfu_score = access_frequencies.get(key, 0)
        mru_score = 1 if mru_flags.get(key, False) else 0
        
        # Weighted score
        total_score = (dynamic_weights['LRU'] * lru_score) + \
                      (dynamic_weights['LFU'] * lfu_score) + \
                      (dynamic_weights['MRU'] * mru_score)
        
        if total_score < min_score:
            min_score = total_score
            candid_obj_key = key
            
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access timestamp for LRU, increments the access frequency for LFU, sets the MRU flag, and adjusts the strategy weights based on the hit rate feedback mechanism. No change is made to the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    obj_key = obj.key
    
    # Update LRU timestamp
    access_timestamps[obj_key] = cache_snapshot.access_count
    
    # Update LFU frequency
    access_frequencies[obj_key] = access_frequencies.get(obj_key, 0) + 1
    
    # Update MRU flag
    mru_flags[obj_key] = True
    
    # Adjust weights based on hit rate
    global hit_rate
    hits = cache_snapshot.hit_count
    accesses = cache_snapshot.access_count
    current_hit_rate = hits / accesses if accesses != 0 else 0
    if current_hit_rate > hit_rate:
        dynamic_weights['LRU'] += 1
        dynamic_weights['LFU'] += 1
    else:
        dynamic_weights['MRU'] += 1
    hit_rate = current_hit_rate

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the access timestamp, access frequency, and MRU flag for the new entry. It also updates the list of potential eviction candidates, adjusts the strategy weights based on the current system state, and places the new object at the rear of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    obj_key = obj.key
    
    # Initialize LRU timestamp
    access_timestamps[obj_key] = cache_snapshot.access_count
    
    # Initialize LFU frequency
    access_frequencies[obj_key] = 1
    
    # Initialize MRU flag
    mru_flags[obj_key] = True
    
    # Update eviction candidates
    potential_eviction_candidates.add(obj_key)
    
    # Adjust weights based on system state
    dynamic_weights['LRU'] = max(dynamic_weights['LRU'], access_timestamps[obj_key])
    dynamic_weights['LFU'] = max(dynamic_weights['LFU'], access_frequencies[obj_key])
    
    # Place new object at rear of FIFO queue
    fifo_queue.append(obj_key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the metadata of the evicted object, updates the list of potential eviction candidates, adjusts the strategy weights based on the miss rate feedback mechanism, and removes the evicted object from the front of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_obj_key = evicted_obj.key
    
    # Remove metadata of evicted object
    if evicted_obj_key in access_timestamps:
        del access_timestamps[evicted_obj_key]
    if evicted_obj_key in access_frequencies:
        del access_frequencies[evicted_obj_key]
    if evicted_obj_key in mru_flags:
        del mru_flags[evicted_obj_key]
    
    # Update eviction candidates
    potential_eviction_candidates.discard(evicted_obj_key)
    
    # Adjust weights based on miss rate
    global hit_rate
    misses = cache_snapshot.miss_count
    accesses = cache_snapshot.access_count
    current_miss_rate = misses / accesses if accesses != 0 else 0
    if current_miss_rate > (1 - hit_rate):
        dynamic_weights['LRU'] -= 1
        dynamic_weights['LFU'] -= 1
    else:
        dynamic_weights['MRU'] -= 1
    
    # Remove evicted object from the front of FIFO queue
    if fifo_queue and fifo_queue[0] == evicted_obj_key:
        fifo_queue.pop(0)