# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections

# Put tunable constant parameters below
INITIAL_PRIORITY_SCORE = 1

# Put the metadata specifically maintained by the policy below. The policy maintains a priority score, partition identifier, sequence of access steps, system load metrics, a machine learning model for predicting future access patterns, a statistical model for calculating access likelihood, a decision tree for conditional checks, and a proximity matrix for access frequency in relation to recent accesses.
priority_scores = collections.defaultdict(lambda: INITIAL_PRIORITY_SCORE)
partitions = collections.defaultdict(list)
access_sequence = []
system_load_metrics = {'total_accesses': 0, 'total_hits': 0, 'total_misses': 0}
ml_model = {}  # Placeholder for ML model
stat_model = {}  # Placeholder for statistical model
decision_tree = {}  # Placeholder for decision tree
proximity_matrix = collections.defaultdict(lambda: collections.defaultdict(int))

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first selects the partition with the least critical access pattern, then uses the ML model to predict future access patterns within that partition, calculates the likelihood of future access, evaluates access frequency, recency, and data importance using the decision tree, and finally considers the proximity matrix to ensure items accessed together are retained before evicting the item with the lowest priority score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    # Select the partition with the least critical access pattern
    least_critical_partition = min(partitions, key=lambda p: sum(priority_scores[o.key] for o in partitions[p]))
    
    # Predict future access patterns within that partition using the ML model (placeholder logic)
    future_access_predictions = {o.key: ml_model.get(o.key, 0) for o in partitions[least_critical_partition]}
    
    # Calculate the likelihood of future access (placeholder logic)
    access_likelihood = {o.key: stat_model.get(o.key, 0) for o in partitions[least_critical_partition]}
    
    # Evaluate access frequency, recency, and data importance using the decision tree (placeholder logic)
    decision_tree_evaluation = {o.key: decision_tree.get(o.key, 0) for o in partitions[least_critical_partition]}
    
    # Consider the proximity matrix to ensure items accessed together are retained
    proximity_evaluation = {o.key: sum(proximity_matrix[o.key].values()) for o in partitions[least_critical_partition]}
    
    # Combine all evaluations to determine the item with the lowest priority score
    combined_scores = {o.key: (priority_scores[o.key] + future_access_predictions[o.key] + access_likelihood[o.key] + decision_tree_evaluation[o.key] - proximity_evaluation[o.key]) for o in partitions[least_critical_partition]}
    
    # Select the object with the lowest combined score for eviction
    candid_obj_key = min(combined_scores, key=combined_scores.get)
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy increases the priority score based on recency and frequency, updates the sequence of access steps, adjusts system load metrics, updates the ML model with new access data, recalculates the likelihood of future access, updates the decision tree with latest access frequency and recency, and adjusts the proximity matrix to reflect the new access pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    priority_scores[obj.key] += 1
    access_sequence.append(obj.key)
    system_load_metrics['total_accesses'] += 1
    system_load_metrics['total_hits'] += 1
    
    # Update ML model, statistical model, decision tree, and proximity matrix (placeholder logic)
    ml_model[obj.key] = ml_model.get(obj.key, 0) + 1
    stat_model[obj.key] = stat_model.get(obj.key, 0) + 1
    decision_tree[obj.key] = decision_tree.get(obj.key, 0) + 1
    
    for other_key in access_sequence[-10:]:  # Consider last 10 accesses for proximity
        if other_key != obj.key:
            proximity_matrix[obj.key][other_key] += 1
            proximity_matrix[other_key][obj.key] += 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy assigns an initial priority score, places the object in the appropriate partition, initializes its sequence of access steps, updates system load metrics, updates the ML model with new object data, recalculates the likelihood of future access for all items, updates the decision tree to include the new object, and adjusts the proximity matrix to incorporate new access relationships.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    priority_scores[obj.key] = INITIAL_PRIORITY_SCORE
    partitions['default'].append(obj)
    access_sequence.append(obj.key)
    system_load_metrics['total_accesses'] += 1
    system_load_metrics['total_misses'] += 1
    
    # Update ML model, statistical model, decision tree, and proximity matrix (placeholder logic)
    ml_model[obj.key] = 0
    stat_model[obj.key] = 0
    decision_tree[obj.key] = 0
    
    for other_key in access_sequence[-10:]:  # Consider last 10 accesses for proximity
        if other_key != obj.key:
            proximity_matrix[obj.key][other_key] += 1
            proximity_matrix[other_key][obj.key] += 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy recalculates the priority scores of remaining items in the affected partition, updates the sequence of access steps, adjusts system load metrics, updates the ML model to remove the evicted item, recalculates the likelihood of future access for remaining items, updates the decision tree to exclude the evicted item, and adjusts the proximity matrix to remove the evicted item's access relationships.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    partition = next(p for p in partitions if evicted_obj in partitions[p])
    partitions[partition].remove(evicted_obj)
    
    # Recalculate priority scores for remaining items in the affected partition (placeholder logic)
    for o in partitions[partition]:
        priority_scores[o.key] = max(priority_scores[o.key] - 1, INITIAL_PRIORITY_SCORE)
    
    access_sequence.append(obj.key)
    system_load_metrics['total_accesses'] += 1
    
    # Update ML model, statistical model, decision tree, and proximity matrix (placeholder logic)
    if evicted_obj.key in ml_model:
        del ml_model[evicted_obj.key]
    if evicted_obj.key in stat_model:
        del stat_model[evicted_obj.key]
    if evicted_obj.key in decision_tree:
        del decision_tree[evicted_obj.key]
    
    if evicted_obj.key in proximity_matrix:
        del proximity_matrix[evicted_obj.key]
    for other_key in proximity_matrix:
        if evicted_obj.key in proximity_matrix[other_key]:
            del proximity_matrix[other_key][evicted_obj.key]