# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
DYNAMIC_THRESHOLD_INITIAL = 0.5

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cache item, including access frequency, recency, last update timestamp, and a dynamic threshold score. It also tracks the current access pattern to select the best eviction strategy from an ensemble of LRU, LFU, and FIFO.
metadata = {}
dynamic_threshold_score = DYNAMIC_THRESHOLD_INITIAL
access_pattern = {'LRU': 0, 'LFU': 0, 'FIFO': 0}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by first evaluating items below the dynamic threshold score. It then applies the selected eviction strategy (LRU, LFU, or FIFO) based on the current access pattern to determine the best candidate for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    # First, filter items below the dynamic threshold score
    candidates = [key for key, meta in metadata.items() if meta['score'] < dynamic_threshold_score]
    
    # If no candidates, consider all items
    if not candidates:
        candidates = list(metadata.keys())
    
    # Determine the eviction strategy based on the current access pattern
    strategy = max(access_pattern, key=access_pattern.get)
    
    if strategy == 'LRU':
        # Least Recently Used
        candid_obj_key = min(candidates, key=lambda k: metadata[k]['last_access'])
    elif strategy == 'LFU':
        # Least Frequently Used
        candid_obj_key = min(candidates, key=lambda k: metadata[k]['frequency'])
    elif strategy == 'FIFO':
        # First In First Out
        candid_obj_key = min(candidates, key=lambda k: metadata[k]['insertion_time'])
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency, recency, and last update timestamp of the accessed item. It also adjusts the dynamic threshold score based on the updated access pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    metadata[key]['frequency'] += 1
    metadata[key]['last_access'] = cache_snapshot.access_count
    metadata[key]['score'] = metadata[key]['frequency'] / (cache_snapshot.access_count - metadata[key]['insertion_time'] + 1)
    
    # Update access pattern
    access_pattern['LRU'] += 1
    access_pattern['LFU'] += 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its metadata (access frequency, recency, last update timestamp) and recalculates the dynamic threshold score. It also updates the current access pattern to reflect the new insertion.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    metadata[key] = {
        'frequency': 1,
        'last_access': cache_snapshot.access_count,
        'insertion_time': cache_snapshot.access_count,
        'score': 1 / (cache_snapshot.access_count + 1)
    }
    
    # Update access pattern
    access_pattern['FIFO'] += 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the metadata of the evicted item and recalculates the dynamic threshold score. It also updates the current access pattern to ensure the most suitable eviction strategy is selected for future decisions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_key = evicted_obj.key
    if evicted_key in metadata:
        del metadata[evicted_key]
    
    # Recalculate dynamic threshold score
    if metadata:
        dynamic_threshold_score = sum(meta['score'] for meta in metadata.values()) / len(metadata)
    else:
        dynamic_threshold_score = DYNAMIC_THRESHOLD_INITIAL
    
    # Update access pattern
    access_pattern['LRU'] = 0
    access_pattern['LFU'] = 0
    access_pattern['FIFO'] = 0