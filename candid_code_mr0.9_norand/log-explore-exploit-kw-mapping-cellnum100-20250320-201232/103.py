# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
CRITICALITY_WEIGHT = 1.0
SENSITIVITY_WEIGHT = 1.0
LATENCY_REDUCTION_WEIGHT = 1.0

# Put the metadata specifically maintained by the policy below. The policy maintains a doubly linked list of cached objects, access frequency counters, latency reduction metrics, and a priority score for each object based on its criticality and sensitivity.
class CacheMetadata:
    def __init__(self):
        self.access_frequency = defaultdict(int)
        self.latency_reduction = defaultdict(float)
        self.priority_score = defaultdict(float)
        self.doubly_linked_list = deque()

cache_metadata = CacheMetadata()

def calculate_priority_score(obj):
    return (CRITICALITY_WEIGHT * cache_metadata.access_frequency[obj.key] +
            SENSITIVITY_WEIGHT * cache_metadata.latency_reduction[obj.key])

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the object with the lowest priority score, considering access frequency, latency reduction, and criticality. If multiple objects have the same score, the least recently used object is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_priority_score = float('inf')
    
    for cached_obj_key in cache_metadata.doubly_linked_list:
        priority_score = calculate_priority_score(cache_snapshot.cache[cached_obj_key])
        if priority_score < min_priority_score:
            min_priority_score = priority_score
            candid_obj_key = cached_obj_key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the access frequency counter, updates the latency reduction metric, and moves the object to the front of the doubly linked list to mark it as most recently used.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    cache_metadata.access_frequency[obj.key] += 1
    cache_metadata.latency_reduction[obj.key] += 1.0  # Example increment, adjust as needed
    cache_metadata.priority_score[obj.key] = calculate_priority_score(obj)
    
    # Move the object to the front of the doubly linked list
    cache_metadata.doubly_linked_list.remove(obj.key)
    cache_metadata.doubly_linked_list.appendleft(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its access frequency counter, latency reduction metric, and priority score, and places it at the front of the doubly linked list.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    cache_metadata.access_frequency[obj.key] = 1
    cache_metadata.latency_reduction[obj.key] = 1.0  # Example initial value, adjust as needed
    cache_metadata.priority_score[obj.key] = calculate_priority_score(obj)
    
    # Place the object at the front of the doubly linked list
    cache_metadata.doubly_linked_list.appendleft(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy removes it from the doubly linked list and adjusts the priority scores of remaining objects if necessary to reflect the change in the cache's composition.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Remove the evicted object from the metadata
    del cache_metadata.access_frequency[evicted_obj.key]
    del cache_metadata.latency_reduction[evicted_obj.key]
    del cache_metadata.priority_score[evicted_obj.key]
    cache_metadata.doubly_linked_list.remove(evicted_obj.key)
    
    # Adjust priority scores of remaining objects if necessary
    for cached_obj_key in cache_metadata.doubly_linked_list:
        cache_metadata.priority_score[cached_obj_key] = calculate_priority_score(cache_snapshot.cache[cached_obj_key])