# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
WEIGHT_ACCESS_FREQUENCY = 0.4
WEIGHT_LAST_ACCESS_TIME = 0.3
WEIGHT_RELIABILITY_SCORE = 0.2
WEIGHT_CONTEXT_TAGS = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, last access time, context tags associated with each data item, and a reliability score. It also keeps track of collaborative information shared between caches, such as shared access patterns and usage statistics.
metadata = {}
collaborative_info = {}

def calculate_score(cache_snapshot, key):
    '''
    Calculates weighted eviction score for an object in the cache based on metadata.
    Lower scores indicate better candidates for eviction.
    '''
    obj_metadata = metadata[key]
    access_freq_score = obj_metadata['access_frequency']
    last_access_time_score = cache_snapshot.access_count - obj_metadata['last_access_time']
    reliability_score = obj_metadata['reliability_score']
    context_relevance = obj_metadata['context_tags']

    weighted_score = (
        WEIGHT_ACCESS_FREQUENCY * access_freq_score +
        WEIGHT_LAST_ACCESS_TIME * last_access_time_score +
        WEIGHT_RELIABILITY_SCORE * reliability_score +
        WEIGHT_CONTEXT_TAGS * context_relevance
    )
    return weighted_score

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by evaluating a weighted score that combines infrequent access, low reliability, and
    lack of contextual relevance to recent access patterns. It also considers collaborative information from
    other caches to avoid redundant data eviction.
    '''
    candid_obj_key = None
    min_score = float('inf')

    for key in cache_snapshot.cache.keys():
        score = calculate_score(cache_snapshot, key)
        if score < min_score:
            min_score = score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    Upon a cache hit, the policy updates the access frequency, last access time, and context tags of the accessed data.
    It also adjusts the reliability score based on the success of the access and updates collaborative information to reflect
    the recent access.
    '''
    if obj.key not in metadata:
        metadata[obj.key] = {
            'access_frequency': 0,
            'last_access_time': 0,
            'context_tags': 0,
            'reliability_score': 0.5
        }
    
    metadata[obj.key]['access_frequency'] += 1
    metadata[obj.key]['last_access_time'] = cache_snapshot.access_count
    metadata[obj.key]['context_tags'] += 1  # Adjust according to context which is a placeholder here
    metadata[obj.key]['reliability_score'] += 0.1  # Adjust increment according to use case
    
    collaborative_info[obj.key] = metadata[obj.key]

def update_after_insert(cache_snapshot, obj):
    '''
    After inserting a new object, the policy initializes its access frequency, last access time, context tags, and reliability score.
    It also updates collaborative information to include the new object and its initial metadata.
    '''
    metadata[obj.key] = {
        'access_frequency': 1,
        'last_access_time': cache_snapshot.access_count,
        'context_tags': 1,  # Initialize with base context value
        'reliability_score': 0.5  # Base reliability score
    }
    
    collaborative_info[obj.key] = metadata[obj.key]

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After evicting a victim, the policy removes its metadata from the cache and updates collaborative information to reflect the eviction.
    It also adjusts the context tags and reliability scores of remaining objects based on the eviction decision.
    '''
    if evicted_obj.key in metadata:
        del metadata[evicted_obj.key]
    
    if evicted_obj.key in collaborative_info:
        del collaborative_info[evicted_obj.key]

    # Adjust context tags and reliability scores (this is a placeholder logic and may be refined based on context)
    for key in cache_snapshot.cache.keys():
        metadata[key]['context_tags'] -= 1  # Adjust according to context relevance
        metadata[key]['reliability_score'] -= 0.1  # Adjust decrement according to use case