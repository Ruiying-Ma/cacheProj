# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
INITIAL_GROUP_ID = 0  # Starting group id.
ZERO_FREQUENCY = 0  # Used for resetting frequency.

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency, group identifiers, and a FIFO queue with a circular pointer. It also tracks overall cache hit/miss patterns.
metadata = {
    'frequencies': {},  # Tracks access frequencies of objects.
    'recency': {},  # Tracks access times of objects.
    'group_ids': {},  # Tracks group ids of objects.
    'fifo_queue': [],  # FIFO queue of objects.
    'circular_pointer': 0,  # Circular pointer in the FIFO queue.
    'hit_patterns': {'hits': 0, 'misses': 0},  # Tracking overall cache hit/miss patterns.
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the least recently used group of items for eviction. Within the chosen group, it evicts the item with the lowest access frequency. If groups are equally used, it evicts based on the oldest access time. The circular pointer is used to reset frequencies to zero until an item with zero frequency is found.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    
    # First, reset frequencies using the circular pointer until a zero frequency is found.
    while metadata['frequencies'][metadata['fifo_queue'][metadata['circular_pointer']]] != ZERO_FREQUENCY:
        metadata['frequencies'][metadata['fifo_queue'][metadata['circular_pointer']]] = ZERO_FREQUENCY
        metadata['circular_pointer'] = (metadata['circular_pointer'] + 1) % len(metadata['fifo_queue'])
        
    # Find the LRU group
    min_group_id = min(metadata['group_ids'].values())
    lru_group_items = [k for k, v in metadata['group_ids'].items() if v == min_group_id]
    
    # Within LRU group, find the LFU item
    min_frequency = min(metadata['frequencies'][k] for k in lru_group_items)
    candidates = [k for k in lru_group_items if metadata['frequencies'][k] == min_frequency]
    
    # If multiple candidates, choose the oldest access time
    oldest_time = min(metadata['recency'][k] for k in candidates)
    for k in candidates:
        if metadata['recency'][k] == oldest_time:
            candid_obj_key = k
            break
            
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency to 1, updates the recency metadata to the current time, and adjusts the group identifier if needed. The item remains in its position in the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    obj_key = obj.key
    current_time = cache_snapshot.access_count
    
    # Update frequency and recency
    metadata['frequencies'][obj_key] = 1
    metadata['recency'][obj_key] = current_time
    
    # Adjust group identifier if required (this example does not specify details)
    # Assume we can update based on a predefined condition or analysis.

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy assigns an initial group identifier based on the current access pattern, sets the access frequency to 1, updates the recency metadata to the current time, and places the object at the rear of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    obj_key = obj.key
    current_time = cache_snapshot.access_count
    
    # Set initial group id, frequency, recency
    metadata['group_ids'][obj_key] = INITIAL_GROUP_ID
    metadata['frequencies'][obj_key] = 1
    metadata['recency'][obj_key] = current_time
    
    # Place object at the rear of the FIFO queue
    metadata['fifo_queue'].append(obj_key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the evicted object from the FIFO queue, re-evaluates the group identifiers and access patterns, and updates the overall cache hit/miss statistics. The circular pointer is moved to the next position.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    
    # Remove evicted object from FIFO queue
    metadata['fifo_queue'].remove(evicted_key)
    del metadata['frequencies'][evicted_key]
    del metadata['recency'][evicted_key]
    del metadata['group_ids'][evicted_key]
    
    # Update hit/miss statistics
    metadata['hit_patterns']['misses'] = cache_snapshot.miss_count
    metadata['hit_patterns']['hits'] = cache_snapshot.hit_count
    
    # Move circular pointer
    metadata['circular_pointer'] = (metadata['circular_pointer'] + 1) % len(metadata['fifo_queue'])