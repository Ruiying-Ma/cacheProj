# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
SHARD_COUNT = 4  # Number of shards

# Put the metadata specifically maintained by the policy below. Each cache line maintains a vote count based on access frequency and recency, a waiting time counter for inactivity duration, and a shard identifier. Additionally, each line has scores from multiple heuristics.
metadata = {
    'vote_count': {},  # key -> vote count
    'waiting_time': {},  # key -> waiting time
    'shard_id': {},  # key -> shard id
    'heuristic_scores': {},  # key -> heuristic scores
    'shard_metadata': {i: {'total_waiting_time': 0, 'line_count': 0} for i in range(SHARD_COUNT)}  # shard_id -> metadata
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by first identifying the shard with the highest average waiting time. Within that shard, it selects the line with the fewest votes. If there's a tie, the line with the lowest average heuristic score is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    # Identify the shard with the highest average waiting time
    max_avg_waiting_time = -1
    target_shard_id = None
    for shard_id, shard_data in metadata['shard_metadata'].items():
        if shard_data['line_count'] > 0:
            avg_waiting_time = shard_data['total_waiting_time'] / shard_data['line_count']
            if avg_waiting_time > max_avg_waiting_time:
                max_avg_waiting_time = avg_waiting_time
                target_shard_id = shard_id

    # Within that shard, select the line with the fewest votes
    min_votes = float('inf')
    min_heuristic_score = float('inf')
    for key, obj in cache_snapshot.cache.items():
        if metadata['shard_id'][key] == target_shard_id:
            votes = metadata['vote_count'][key]
            heuristic_score = sum(metadata['heuristic_scores'][key]) / len(metadata['heuristic_scores'][key])
            if votes < min_votes or (votes == min_votes and heuristic_score < min_heuristic_score):
                min_votes = votes
                min_heuristic_score = heuristic_score
                candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the vote count for the accessed line is incremented, its waiting time counter is reset, and its heuristic scores are updated based on the latest access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    metadata['vote_count'][key] += 1
    metadata['waiting_time'][key] = 0
    # Update heuristic scores (example: access count and recency)
    metadata['heuristic_scores'][key] = [metadata['vote_count'][key], cache_snapshot.access_count]

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the new line's vote count is initialized, its waiting time counter starts from zero, and its heuristic scores are calculated. The shard's metadata is updated to reflect the new line.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    shard_id = hash(key) % SHARD_COUNT
    metadata['vote_count'][key] = 0
    metadata['waiting_time'][key] = 0
    metadata['shard_id'][key] = shard_id
    metadata['heuristic_scores'][key] = [0, cache_snapshot.access_count]
    metadata['shard_metadata'][shard_id]['line_count'] += 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a line, the shard's metadata is updated to remove the evicted line's information. The remaining lines in the shard may have their waiting time counters adjusted to reflect the change in the cache state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_key = evicted_obj.key
    shard_id = metadata['shard_id'][evicted_key]
    metadata['shard_metadata'][shard_id]['line_count'] -= 1
    metadata['shard_metadata'][shard_id]['total_waiting_time'] -= metadata['waiting_time'][evicted_key]
    del metadata['vote_count'][evicted_key]
    del metadata['waiting_time'][evicted_key]
    del metadata['shard_id'][evicted_key]
    del metadata['heuristic_scores'][evicted_key]