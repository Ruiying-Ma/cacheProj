# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
TIME_DECAY = 0.9  # decay factor for importance score
ISOLATION_THRESHOLD = 10  # threshold for moving objects to the isolated segment

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cached object, including access frequency, feature significance scores, importance scores, and a flag indicating if the object is in the isolated segment for frequently accessed items.
metadata = {}

def calculate_importance(freq, size, feature_significance):
    return freq / size * feature_significance

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first checks the least frequently accessed group and selects the object with the lowest importance score and least significant features for eviction. If all objects are in the isolated segment, it evicts the one with the lowest combined score of frequency and importance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_importance_score = float('inf')
    min_combined_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        obj_metadata = metadata[key]
        freq = obj_metadata['frequency']
        importance = obj_metadata['importance']
        feature_significance = obj_metadata['feature_significance']
        isolated = obj_metadata['isolated']

        combined_score = freq + importance
        importance_score = calculate_importance(freq, cached_obj.size, feature_significance)

        if not isolated:
            if importance_score < min_importance_score:
                min_importance_score = importance_score
                candid_obj_key = key
        else:
            if combined_score < min_combined_score:
                min_combined_score = combined_score
                candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the access frequency of the object is incremented, its importance score is recalculated, and if it meets the criteria, it is moved to the isolated segment. The feature significance scores are also updated based on the latest access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    obj_metadata = metadata[key]

    # Update frequency
    obj_metadata['frequency'] += 1

    # Update feature significance
    obj_metadata['feature_significance'] = min(cache_snapshot.access_count, ISOLATION_THRESHOLD)

    # Recalculate importance
    obj_metadata['importance'] = calculate_importance(obj_metadata['frequency'], obj.size, obj_metadata['feature_significance'])

    # Update isolated segment flag
    obj_metadata['isolated'] = obj_metadata['frequency'] >= ISOLATION_THRESHOLD

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, its access frequency is initialized, its feature significance and importance scores are calculated, and it is placed in the appropriate group based on its initial access pattern. If it qualifies, it is added to the isolated segment.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata[key] = {
        'frequency': 1,
        'feature_significance': min(cache_snapshot.access_count, ISOLATION_THRESHOLD),
        'importance': calculate_importance(1, obj.size, min(cache_snapshot.access_count, ISOLATION_THRESHOLD)),
        'isolated': False
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy updates the metadata by removing the object's records, recalculating the group thresholds if necessary, and adjusting the isolated segment to ensure it only contains the most frequently accessed items.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    if key in metadata:
        del metadata[key]

    # Adjust isolated segment based on the remaining objects
    for key in metadata:
        obj_metadata = metadata[key]
        obj_metadata['isolated'] = obj_metadata['frequency'] >= ISOLATION_THRESHOLD