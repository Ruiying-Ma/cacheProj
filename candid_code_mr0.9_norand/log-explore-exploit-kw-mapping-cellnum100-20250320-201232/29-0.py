# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque, defaultdict
import hashlib

# Put tunable constant parameters below
MAX_LEVELS = 3

# Put the metadata specifically maintained by the policy below. The policy maintains a circular pointer, access frequency, dynamic priority score, relationship strength score, and an ordered list of items. It also uses a multi-level structure with each level having its own replacement strategy.
cache_metadata = {
    "circular_pointer": 0,
    "access_frequency": defaultdict(int),
    "dynamic_priority_score": {},
    "relationship_strength_score": {},
    "ordered_list": deque(),
    "levels": [set() for _ in range(MAX_LEVELS)]
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy starts by moving the pointer cyclically and setting the frequency of each encountered object to 0 until it finds an object with zero frequency. It then considers the dynamic priority score, relationship strength score, and ordered list to choose the eviction victim, prioritizing the lowest priority score, weakest connections, and least recently used item.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Find object to evict
    while True:
        keys_list = list(cache_snapshot.cache.keys())
        pointer_key = keys_list[cache_metadata["circular_pointer"]]
        cache_metadata["access_frequency"][pointer_key] = 0
        if cache_metadata["access_frequency"][pointer_key] == 0:
            break
        cache_metadata["circular_pointer"] = (cache_metadata["circular_pointer"] + 1) % len(keys_list)
    
    # Consider dynamic priority score, relationship strength score, and ordered list
    evictions_candidates = [
        (cache_metadata["dynamic_priority_score"][k], cache_metadata["relationship_strength_score"][k], cache_metadata["access_frequency"][k], k)
        for k in cache_snapshot.cache.keys()
    ]
    evictions_candidates.sort()
    candid_obj_key = evictions_candidates[0][3]  # Choose the best candidate based on scores

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy sets the hit object's frequency to 1, increases its access frequency, updates its recency, adjusts its relationship strength scores, and moves it to the front of the ordered list. If the item is in a lower level, it may be promoted to a higher level.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    cache_metadata["access_frequency"][key] += 1
    cache_metadata["dynamic_priority_score"][key] = hash(key) % MAX_LEVELS
    cache_metadata["ordered_list"].remove(key)
    cache_metadata["ordered_list"].appendleft(key)
    cache_metadata["circular_pointer"] = cache_snapshot.access_count % len(cache_snapshot.cache)
    current_level = cache_metadata["dynamic_priority_score"][key]
    if key in cache_metadata["levels"][current_level] and current_level > 0:
        cache_metadata["levels"][current_level].remove(key)
        cache_metadata["levels"][current_level - 1].add(key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy sets its frequency to 1, initializes its priority score, sets its relationship strength score based on initial connections, and places it at the front of the ordered list. The item is inserted into the appropriate level based on its initial priority score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    cache_metadata["access_frequency"][key] = 1
    cache_metadata["dynamic_priority_score"][key] = hash(key) % MAX_LEVELS
    cache_metadata["relationship_strength_score"][key] = 1.0  # For simplicity, we start with a constant value
    cache_metadata["ordered_list"].appendleft(key)
    cache_metadata["levels"][cache_metadata["dynamic_priority_score"][key]].add(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy removes its metadata, adjusts the relationship strength scores of remaining items, updates the ordered list to remove the evicted item, and promotes an item from a lower level if the eviction occurred in a higher level.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    cache_metadata["access_frequency"].pop(evicted_key, None)
    cache_metadata["dynamic_priority_score"].pop(evicted_key, None)
    cache_metadata["relationship_strength_score"].pop(evicted_key, None)
    cache_metadata["ordered_list"].remove(evicted_key)
    for level in cache_metadata["levels"]:
        if evicted_key in level:
            level.remove(evicted_key)
            break
    # Promote from lower level if needed
    # For simplicity, we assume a direct promotion logic without reordering within levels