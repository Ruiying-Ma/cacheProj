# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections

# Put tunable constant parameters below
DEFAULT_FEATURE_SIGNIFICANCE_SCORE = 1
DEFAULT_MEMORY_ADDRESS_RANGE = (0, 1000)  # Example range, should be refined based on actual use case.

# Put the metadata specifically maintained by the policy below. The policy maintains metadata for each cached object, including access frequency, memory address range, feature significance scores, and community membership. Additionally, it tracks overall community access patterns and utility scores.
metadata = {
    'object_metadata': {},  # {obj_key: {'access_frequency': int, 'memory_address_range': tuple, 'feature_significance_score': int, 'community': str}}
    'community_metadata': {},  # {community: {'utility_score': int, 'total_access_frequency': int, 'members': set}}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects the eviction victim by first identifying the community with the lowest overall utility score. Within that community, it evicts the object with the lowest access frequency and least significant features within a certain memory address range.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    
    # Find the community with the lowest utility score
    lowest_utility_score = float('inf')
    target_community = None
    for community, data in metadata['community_metadata'].items():
        if data['utility_score'] < lowest_utility_score:
            lowest_utility_score = data['utility_score']
            target_community = community
    
    # Within the target community, find the object with lowest access frequency
    # and least significant features within a certain memory address range
    lowest_access_frequency = float('inf')
    lowest_feature_score = float('inf')
    for obj_key in metadata['community_metadata'][target_community]['members']:
        obj_data = metadata['object_metadata'][obj_key]
        if (obj_data['access_frequency'] < lowest_access_frequency or
            (obj_data['access_frequency'] == lowest_access_frequency and
             obj_data['feature_significance_score'] < lowest_feature_score)):
            lowest_access_frequency = obj_data['access_frequency']
            lowest_feature_score = obj_data['feature_significance_score']
            candid_obj_key = obj_key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency of the object, recalculates its feature significance score, and 
    adjusts the utility score of its community. The memory address range metadata is also updated to reflect the latest access.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    obj_key = obj.key
    community = metadata['object_metadata'][obj_key]['community']
    
    # Update access frequency
    metadata['object_metadata'][obj_key]['access_frequency'] += 1
    # Recalculate feature significance score (this can be updated with a more complex logic)
    metadata['object_metadata'][obj_key]['feature_significance_score'] += 1
    # Update memory address range if needed (based on obj properties, not detailed here)
    # metadata['object_metadata'][obj_key]['memory_address_range'] = new_range
    
    # Adjust community utility score (example logic)
    metadata['community_metadata'][community]['total_access_frequency'] += 1
    metadata['community_metadata'][community]['utility_score'] += 1
  
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy assigns it to a community based on its features and memory address range, initializes its access frequency and feature significance score, and updates the community's utility score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    obj_key = obj.key
    
    # Example logic to determine the community based on features
    community = 'default'  # This can be determined based on actual obj attributes
    if community not in metadata['community_metadata']:
        metadata['community_metadata'][community] = {'utility_score': 0, 'total_access_frequency': 0, 'members': set()}
    
    # Initialize metadata for the new object
    metadata['object_metadata'][obj_key] = {
        'access_frequency': 0,
        'memory_address_range': DEFAULT_MEMORY_ADDRESS_RANGE,
        'feature_significance_score': DEFAULT_FEATURE_SIGNIFICANCE_SCORE,
        'community': community,
    }
    
    # Update community metadata
    metadata['community_metadata'][community]['members'].add(obj_key)
    metadata['community_metadata'][community]['utility_score'] += 1
  
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy removes it from its community, recalculates the community's utility score, and adjusts the overall metadata to reflect the change in the cache's composition.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_obj_key = evicted_obj.key
    community = metadata['object_metadata'][evicted_obj_key]['community']
    
    # Remove the object from its community
    metadata['community_metadata'][community]['members'].remove(evicted_obj_key)
    
    # Recalculate community utility score
    metadata['community_metadata'][community]['utility_score'] -= 1
    metadata['community_metadata'][community]['total_access_frequency'] -= metadata['object_metadata'][evicted_obj_key]['access_frequency']
    
    # Remove the object's metadata
    del metadata['object_metadata'][evicted_obj_key]