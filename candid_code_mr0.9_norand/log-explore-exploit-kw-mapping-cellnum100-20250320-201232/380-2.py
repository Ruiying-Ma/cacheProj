# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections

# Put tunable constant parameters below
OVERFLOW_MAX_SIZE = 10  # Max size of the overflow area

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency of access, priority level, synchronization status, FIFO queue position, and a hierarchical structure for each cached object.
class Metadata:
    def __init__(self, access_freq, recency, priority, sync_status, fifo_pos, cost, hierarchy_level):
        self.access_freq = access_freq
        self.recency = recency
        self.priority = priority
        self.sync_status = sync_status
        self.fifo_pos = fifo_pos
        self.cost = cost
        self.hierarchy_level = hierarchy_level

metadata = {}
overflow_area = collections.deque(maxlen=OVERFLOW_MAX_SIZE)

def calculate_priority(access_freq, recency):
    # Example calculation of priority, the formula can be adjusted
    return access_freq / recency

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    '''
    candid_obj_key = None

    def evaluate_candidate(candidate):
        md = metadata[candidate]
        return (md.hierarchy_level, md.priority, md.recency, md.sync_status)

    sorted_candidates = sorted(cache_snapshot.cache.keys(), key=evaluate_candidate)
    
    if sorted_candidates:
        candid_obj_key = sorted_candidates[0]

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    md = metadata[obj.key]
    md.access_freq = 1
    md.recency = cache_snapshot.access_count
    md.priority = calculate_priority(md.access_freq, md.recency)
    # Update other attributes if applicable
    md.fifo_pos = len(metadata) - 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    access_freq = 1
    recency = cache_snapshot.access_count
    priority = calculate_priority(access_freq, recency)
    sync_status = False
    fifo_pos = len(metadata)
    cost = obj.size
    hierarchy_level = 0  # Starting level

    metadata[obj.key] = Metadata(access_freq, recency, priority, sync_status, fifo_pos, cost, hierarchy_level)
    # Place in overflow area if same item is recently evicted (eviction of older item in the area happens automatically due to maxlen)
    for evicted in overflow_area:
        if evicted[0] == obj.key:
            overflow_area.remove(evicted)
    overflow_area.append((obj.key, metadata[obj.key]))

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_md = metadata[evicted_obj.key]
    overflow_area.append((evicted_obj.key, evicted_md))
    del metadata[evicted_obj.key]

    # Shift FIFO positions
    for key, md in metadata.items():
        if md.fifo_pos > evicted_md.fifo_pos:
            md.fifo_pos -= 1