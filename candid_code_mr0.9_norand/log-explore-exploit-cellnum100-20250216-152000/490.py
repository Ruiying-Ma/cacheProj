# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import numpy as np

# Put tunable constant parameters below
PES_DECAY_FACTOR = 0.9  # Decay factor for Predictive Entropy Score
QCN_STRENGTHEN_FACTOR = 1.1  # Factor to strengthen QCN connections
QCN_WEAKEN_FACTOR = 0.9  # Factor to weaken QCN connections

# Put the metadata specifically maintained by the policy below. The policy maintains a Temporal Fusion Matrix (TFM) to track access patterns over time, a Quantum Coherence Network (QCN) to model the probabilistic relationships between cached items, a Cognitive Load Balancer (CLB) to manage the computational load of the cache, and a Predictive Entropy Score (PES) to estimate the uncertainty of future accesses.
TFM = {}
QCN = {}
CLB = {}
PES = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by identifying the item with the highest Predictive Entropy Score (PES) and the lowest coherence in the Quantum Coherence Network (QCN), ensuring that items with uncertain future accesses and weak relationships are evicted first.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    max_pes = -1
    min_qcn = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        pes = PES.get(key, 0)
        qcn = QCN.get(key, {}).get('strength', 0)
        
        if pes > max_pes or (pes == max_pes and qcn < min_qcn):
            max_pes = pes
            min_qcn = qcn
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the Temporal Fusion Matrix (TFM) is updated to reflect the recent access, the Quantum Coherence Network (QCN) strengthens the connections related to the accessed item, the Cognitive Load Balancer (CLB) adjusts to optimize for the increased load, and the Predictive Entropy Score (PES) is recalculated to reflect the reduced uncertainty.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    TFM[key] = cache_snapshot.access_count
    
    if key in QCN:
        QCN[key]['strength'] *= QCN_STRENGTHEN_FACTOR
    else:
        QCN[key] = {'strength': 1}
    
    CLB[key] = cache_snapshot.access_count
    PES[key] = PES.get(key, 1) * PES_DECAY_FACTOR

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the Temporal Fusion Matrix (TFM) incorporates the new access pattern, the Quantum Coherence Network (QCN) initializes connections for the new item, the Cognitive Load Balancer (CLB) adjusts to accommodate the new item, and the Predictive Entropy Score (PES) is computed for the new item to estimate its future access uncertainty.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    TFM[key] = cache_snapshot.access_count
    QCN[key] = {'strength': 1}
    CLB[key] = cache_snapshot.access_count
    PES[key] = 1  # Initial uncertainty

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the Temporal Fusion Matrix (TFM) removes the evicted item's access pattern, the Quantum Coherence Network (QCN) weakens or removes connections related to the evicted item, the Cognitive Load Balancer (CLB) rebalances the load distribution, and the Predictive Entropy Score (PES) is recalculated for the remaining items to reflect the updated cache state.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in TFM:
        del TFM[evicted_key]
    if evicted_key in QCN:
        del QCN[evicted_key]
    if evicted_key in CLB:
        del CLB[evicted_key]
    if evicted_key in PES:
        del PES[evicted_key]
    
    for key in cache_snapshot.cache:
        PES[key] = PES.get(key, 1) * PES_DECAY_FACTOR