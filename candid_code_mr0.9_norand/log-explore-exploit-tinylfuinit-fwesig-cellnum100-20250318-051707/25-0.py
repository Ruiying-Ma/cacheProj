# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below

# Parameters that control the weight of the replacement score calculation
HIT_RATIO_WEIGHT = 0.5
RESIDENCY_TIME_WEIGHT = 0.3
ACCESS_PATTERN_WEIGHT = 0.2

# Put the metadata specifically maintained by the policy below. The policy maintains a Hash Map for quick access, a Binary Tree for access frequencies, a Linked List for order of access, an Array for cache data, hit ratio tracking, cache residency time, access frequency patterns, and replacement scores.

class CachePolicy:
    def __init__(self):
        self.hash_map = {}
        self.access_frequencies = defaultdict(int)
        self.order_of_access = deque()
        self.cache_array = []
        self.hit_ratios = {}
        self.residency_times = {}
        self.access_patterns = {}
        self.replacement_scores = {}
        
    def calculate_replacement_score(self, key, current_time):
        hit_ratio = self.hit_ratios.get(key, 0)
        residency_time = current_time - self.residency_times.get(key, current_time)
        access_pattern = self.access_patterns.get(key, 0)
        
        replacement_score = (
            HIT_RATIO_WEIGHT * (1 / (hit_ratio + 1)) + 
            RESIDENCY_TIME_WEIGHT * residency_time + 
            ACCESS_PATTERN_WEIGHT * (1 / (access_pattern + 1))
        )
        
        return replacement_score

cache_policy = CachePolicy()

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the item with the lowest replacement score, which is calculated using a combination of low hit ratio, long residency time, and infrequent access patterns. If there are multiple candidates, it uses the Binary Tree to select the least frequently accessed item and the Linked List to select the oldest one among them.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    current_time = cache_snapshot.access_count
    
    for key, cached_obj in cache_snapshot.cache.items():
        replacement_score = cache_policy.calculate_replacement_score(key, current_time)
        if replacement_score < min_score:
            min_score = replacement_score
            candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency in the Binary Tree, moves the accessed item to the front of the Linked List, updates the hit ratio by incrementing the hit count, resets the residency time, updates the access frequency pattern, and updates the corresponding entry in the Hash Map.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    cache_policy.access_frequencies[obj.key] += 1
    
    # Move the accessed item to the front of the Linked List
    if obj.key in cache_policy.order_of_access:
        cache_policy.order_of_access.remove(obj.key)
    cache_policy.order_of_access.appendleft(obj.key)
    
    # Update hit ratio
    if obj.key in cache_policy.hit_ratios:
        cache_policy.hit_ratios[obj.key] = cache_snapshot.hit_count / (cache_snapshot.hit_count + cache_snapshot.miss_count)
        
    # Reset residency time
    cache_policy.residency_times[obj.key] = current_time
    
    # Update access frequency pattern
    cache_policy.access_patterns[obj.key] = cache_policy.access_frequencies[obj.key]
    
    # Update the Hash Map
    cache_policy.hash_map[obj.key] = obj
  
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy adds the object to the Hash Map, inserts it into the Binary Tree with an initial frequency count, appends it to the end of the Linked List, places it in the next available slot in the Array, initializes the hit ratio to zero, sets the residency time to the current time, and starts tracking the access frequency pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    cache_policy.hash_map[obj.key] = obj
    cache_policy.access_frequencies[obj.key] = 1
    cache_policy.order_of_access.append(obj.key)
    cache_policy.cache_array.append(obj.key)
    cache_policy.hit_ratios[obj.key] = 0
    cache_policy.residency_times[obj.key] = current_time
    cache_policy.access_patterns[obj.key] = 1
    
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes the object from the Hash Map, deletes its node from the Binary Tree, removes it from the Linked List, clears its slot in the Array, removes all metadata associated with the evicted cache line, and recalculates the replacement scores for the remaining cache lines.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    
    # Remove from the Hash Map
    if evicted_obj.key in cache_policy.hash_map:
        del cache_policy.hash_map[evicted_obj.key]
    
    # Remove from the access frequencies
    if evicted_obj.key in cache_policy.access_frequencies:
        del cache_policy.access_frequencies[evicted_obj.key]
    
    # Remove from the Linked List
    if evicted_obj.key in cache_policy.order_of_access:
        cache_policy.order_of_access.remove(evicted_obj.key)
    
    # Remove from the Array
    if evicted_obj.key in cache_policy.cache_array:
        cache_policy.cache_array.remove(evicted_obj.key)
    
    # Remove all associated metadata
    if evicted_obj.key in cache_policy.hit_ratios:
        del cache_policy.hit_ratios[evicted_obj.key]
    if evicted_obj.key in cache_policy.residency_times:
        del cache_policy.residency_times[evicted_obj.key]
    if evicted_obj.key in cache_policy.access_patterns:
        del cache_policy.access_patterns[evicted_obj.key]
        
    # Recalculate replacement scores for the remaining cache lines
    for key, cached_obj in cache_snapshot.cache.items():
        cache_policy.replacement_scores[key] = cache_policy.calculate_replacement_score(key, current_time)