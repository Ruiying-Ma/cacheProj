# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
WEIGHT_ACCESS_LATENCY = 0.4
WEIGHT_PREDICTIVE_ACCURACY = 0.3
WEIGHT_ERROR_PROPAGATION = 0.2
WEIGHT_CACHE_COHERENCE = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access latency, predictive accuracy scores for future accesses, error propagation metrics, and cache coherence status for each cache entry.
metadata = {
    # cache_key: {'access_latency': float, 'predictive_accuracy': float, 'error_propagation': float, 'coherence': bool}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on a weighted combination of high access latency, low predictive accuracy, high error propagation, and cache coherence violations. The entry with the highest combined score is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    max_score = -float('inf')

    for key in cache_snapshot.cache:
        meta = metadata[key]
        score = (WEIGHT_ACCESS_LATENCY * meta['access_latency'] -
                 WEIGHT_PREDICTIVE_ACCURACY * meta['predictive_accuracy'] +
                 WEIGHT_ERROR_PROPAGATION * meta['error_propagation'] +
                 WEIGHT_CACHE_COHERENCE * (1 if not meta['coherence'] else 0))

        if score > max_score:
            max_score = score
            candid_obj_key = key
            
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access latency to reflect the recent access time, recalculates predictive accuracy based on the hit, adjusts error propagation metrics, and ensures cache coherence status is up-to-date.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    meta = metadata[obj.key]
    meta['access_latency'] = cache_snapshot.access_count
    # Assuming `meta['predictive_accuracy']` and `meta['error_propagation']` are adjusted based on historical/hit data
    meta['cache_coherence'] = True  # Cache coherence should be validated on hit

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes access latency to a default low value, sets predictive accuracy based on historical data, initializes error propagation metrics, and sets cache coherence status to valid.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    metadata[obj.key] = {
        'access_latency': cache_snapshot.access_count,  # Initial access time is now
        'predictive_accuracy': 1.0,  # Default high accuracy
        'error_propagation': 0.0,    # Default no error
        'coherence': True            # Assume valid on insertion
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes all associated metadata for the evicted entry, recalculates predictive accuracy for remaining entries, adjusts error propagation metrics, and verifies cache coherence for the remaining cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Remove metadata for evicted object
    if evicted_obj.key in metadata:
        del metadata[evicted_obj.key]

    # Adjust predictive accuracy and error propagation for remaining entries
    for key in metadata:
        meta = metadata[key]
        # Example adjustments (presume calculations based on new state)
        meta['predictive_accuracy'] *= 0.95  # Reduce by some factor to simulate decay over time
        meta['error_propagation'] *= 1.05  # Increase by some factor to simulate propagation

    # Verify and ensure cache coherence status
    for key in metadata:
        metadata[key]['coherence'] = True  # Assuming coherence verified during eviction