# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque
import bisect

# Put tunable constant parameters below
HIT_RATIO_WEIGHT = 0.5
RESIDENCY_TIME_WEIGHT = 0.3
ACCESS_PATTERN_WEIGHT = 0.2

# Put the metadata specifically maintained by the policy below. The policy maintains a Hash Map for quick access, a Binary Tree for access frequencies, a Linked List for order of access, an Array for cache data, hit ratio tracking, cache residency time, access frequency patterns, and replacement scores.
hash_map = {}
binary_tree = defaultdict(int)
linked_list = deque()
array = []
hit_ratios = {}
residency_times = {}
access_patterns = defaultdict(int)
replacement_scores = {}

def calculate_replacement_score(key, current_time):
    hit_ratio = hit_ratios.get(key, 0)
    residency_time = current_time - residency_times.get(key, current_time)
    access_pattern = access_patterns.get(key, 0)
    return (HIT_RATIO_WEIGHT * (1 - hit_ratio) +
            RESIDENCY_TIME_WEIGHT * residency_time +
            ACCESS_PATTERN_WEIGHT * (1 - access_pattern))

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the item with the lowest replacement score, which is calculated using a combination of low hit ratio, long residency time, and infrequent access patterns. If there are multiple candidates, it uses the Binary Tree to select the least frequently accessed item and the Linked List to select the oldest one among them.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    current_time = cache_snapshot.access_count

    for key in cache_snapshot.cache:
        score = calculate_replacement_score(key, current_time)
        if score < min_score:
            min_score = score
            candid_obj_key = key
        elif score == min_score:
            if binary_tree[key] < binary_tree[candid_obj_key]:
                candid_obj_key = key
            elif binary_tree[key] == binary_tree[candid_obj_key]:
                if linked_list.index(key) < linked_list.index(candid_obj_key):
                    candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency in the Binary Tree, moves the accessed item to the front of the Linked List, updates the hit ratio by incrementing the hit count, resets the residency time, updates the access frequency pattern, and updates the corresponding entry in the Hash Map.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update access frequency in the Binary Tree
    binary_tree[key] += 1

    # Move the accessed item to the front of the Linked List
    linked_list.remove(key)
    linked_list.appendleft(key)

    # Update the hit ratio
    hit_ratios[key] = (hit_ratios.get(key, 0) * cache_snapshot.hit_count + 1) / (cache_snapshot.hit_count + 1)

    # Reset the residency time
    residency_times[key] = current_time

    # Update the access frequency pattern
    access_patterns[key] += 1

    # Update the corresponding entry in the Hash Map
    hash_map[key] = obj

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy adds the object to the Hash Map, inserts it into the Binary Tree with an initial frequency count, appends it to the end of the Linked List, places it in the next available slot in the Array, initializes the hit ratio to zero, sets the residency time to the current time, and starts tracking the access frequency pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Add the object to the Hash Map
    hash_map[key] = obj

    # Insert it into the Binary Tree with an initial frequency count
    binary_tree[key] = 1

    # Append it to the end of the Linked List
    linked_list.append(key)

    # Place it in the next available slot in the Array
    array.append(key)

    # Initialize the hit ratio to zero
    hit_ratios[key] = 0

    # Set the residency time to the current time
    residency_times[key] = current_time

    # Start tracking the access frequency pattern
    access_patterns[key] = 1

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes the object from the Hash Map, deletes its node from the Binary Tree, removes it from the Linked List, clears its slot in the Array, removes all metadata associated with the evicted cache line, and recalculates the replacement scores for the remaining cache lines.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key

    # Remove the object from the Hash Map
    del hash_map[key]

    # Delete its node from the Binary Tree
    del binary_tree[key]

    # Remove it from the Linked List
    linked_list.remove(key)

    # Clear its slot in the Array
    array.remove(key)

    # Remove all metadata associated with the evicted cache line
    del hit_ratios[key]
    del residency_times[key]
    del access_patterns[key]

    # Recalculate the replacement scores for the remaining cache lines
    current_time = cache_snapshot.access_count
    for key in cache_snapshot.cache:
        replacement_scores[key] = calculate_replacement_score(key, current_time)