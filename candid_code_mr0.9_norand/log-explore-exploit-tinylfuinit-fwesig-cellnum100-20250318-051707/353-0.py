# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import OrderedDict, deque
from sortedcontainers import SortedDict

# Put tunable constant parameters below
SQ_CAPACITY = 5  # Capacity of the SQ queue
MQ_CAPACITY = 10  # Capacity of the MQ queue
GQ_CAPACITY = 15  # Capacity of the GQ queue

# Put the metadata specifically maintained by the policy below. The policy maintains a Hash Map for quick access, a Binary Tree for access frequencies, a Linked List for access order, an Array for cache data, and three FIFO queues (SQ, MQ, GQ) for managing cache objects and their frequencies.
hash_map = {}                       # Mapping from object key to object
binary_tree = SortedDict()          # Mapping from frequency to OrderedDict of objects
linked_list = OrderedDict()         # Tracking access order
array = []                          # Cache represented as list of objects
SQ = deque()                        # FIFO queue SQ
MQ = deque()                        # FIFO queue MQ
GQ = deque()                        # FIFO queue GQ
object_frequencies = {}             # Tracking frequencies of objects

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first checks if SQ exceeds its capacity. If so, it moves objects from SQ to MQ until an object with frequency less than 2 is found or MQ is full. If MQ is full, it evicts the least frequently accessed item from the Binary Tree, using the Linked List to select the oldest among candidates.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    while len(SQ) > SQ_CAPACITY:
        if len(MQ) >= MQ_CAPACITY:
            break
        move_obj_key = SQ.popleft()
        move_obj_freq = object_frequencies[move_obj_key]
        if move_obj_freq < 2:
            break
        MQ.append(move_obj_key)
    if len(MQ) >= MQ_CAPACITY:
        for freq, odict in binary_tree.items():
            if odict:
                candid_obj_key = list(odict.keys())[0]
                break
    elif len(SQ) > 0:
        candid_obj_key = SQ.popleft()
    else:
        candid_obj_key = MQ.popleft()
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency in the Binary Tree, moves the accessed item to the front of the Linked List, updates the Hash Map, and increases the object's frequency by 1 if it is less than 3.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    obj_key = obj.key
    obj_freq = object_frequencies.get(obj_key, 0)
    new_freq = min(3, obj_freq + 1)
    object_frequencies[obj_key] = new_freq

    if obj_freq in binary_tree:
        if obj_key in binary_tree[obj_freq]:
            del binary_tree[obj_freq][obj_key]
            if not binary_tree[obj_freq]:
                del binary_tree[obj_freq]
    
    if new_freq not in binary_tree:
        binary_tree[new_freq] = OrderedDict()
    
    binary_tree[new_freq][obj_key] = obj
    if obj_key in linked_list:
        del linked_list[obj_key]
    linked_list[obj_key] = obj

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy adds it to the Hash Map, inserts it into the Binary Tree with an initial frequency count, appends it to the end of the Linked List, places it in the next available slot in the Array, and puts it at the rear of SQ or MQ based on its presence in GQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    obj_key = obj.key
    hash_map[obj_key] = obj
    object_frequencies[obj_key] = 1
    if 1 not in binary_tree:
        binary_tree[1] = OrderedDict()
    binary_tree[1][obj_key] = obj
    linked_list[obj_key] = obj
    array.append(obj)
    if obj_key in GQ:
        MQ.append(obj_key)
    else:
        SQ.append(obj_key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes the object from the Hash Map, deletes its node from the Binary Tree, removes it from the Linked List, clears its slot in the Array, and places the evicted object at the rear of GQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_obj_key = evicted_obj.key
    if evicted_obj_key in hash_map:
        del hash_map[evicted_obj_key]
    evicted_obj_freq = object_frequencies.pop(evicted_obj_key, None)
    if evicted_obj_freq and evicted_obj_freq in binary_tree:
        if evicted_obj_key in binary_tree[evicted_obj_freq]:
            del binary_tree[evicted_obj_freq][evicted_obj_key]
            if not binary_tree[evicted_obj_freq]:
                del binary_tree[evicted_obj_freq]
    if evicted_obj_key in linked_list:
        del linked_list[evicted_obj_key]
    array.remove(evicted_obj)
    GQ.append(evicted_obj_key)