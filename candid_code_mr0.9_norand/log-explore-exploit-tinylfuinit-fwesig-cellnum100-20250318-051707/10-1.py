# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
WEIGHT_FREQUENCY = 0.4
WEIGHT_RECENCY = 0.4
WEIGHT_COHERENCE = 0.2

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, recency of access, prefetching hints, and coherence status for each cache entry.
metadata = {
    "frequency": {},  # {key: access frequency}
    "recency": {},    # {key: last access time}
    "coherence": {},  # {key: coherence status, True means to-be-invalidated}
    "prefetching": {} # {key: prefetching hint}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on a weighted combination of least frequently used, least recently accessed, and entries marked for invalidation due to coherence issues.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_weighted_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        frequency = metadata["frequency"].get(key, 0)
        recency = cache_snapshot.access_count - metadata["recency"].get(key, 0)
        coherence = 1 if metadata["coherence"].get(key, False) else 0
        
        weighted_score = (WEIGHT_FREQUENCY * frequency) + \
                         (WEIGHT_RECENCY * recency) + \
                         (WEIGHT_COHERENCE * coherence)
        
        if weighted_score < min_weighted_score:
            min_weighted_score = weighted_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access frequency and recency of access for the hit entry, and adjusts prefetching hints based on access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    metadata["frequency"][key] = metadata["frequency"].get(key, 0) + 1
    metadata["recency"][key] = cache_snapshot.access_count
    # Assuming some prefetching adjustment based on access patterns
    metadata["prefetching"][key] = "hint_based_on_access_patterns"

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the access frequency and recency of access, sets prefetching hints based on the object's context, and ensures coherence status is up-to-date.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata["frequency"][key] = 1
    metadata["recency"][key] = cache_snapshot.access_count
    metadata["prefetching"][key] = "init_hint_based_on_context"
    metadata["coherence"][key] = False  # Assuming coherence is up-to-date by default

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy recalculates the weighted criteria for remaining entries, updates prefetching hints to reflect the new cache state, and ensures coherence status is maintained.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    if key in metadata["frequency"]:
        del metadata["frequency"][key]
    if key in metadata["recency"]:
        del metadata["recency"][key]
    if key in metadata["prefetching"]:
        del metadata["prefetching"][key]
    if key in metadata["coherence"]:
        del metadata["coherence"][key]

    # Recalculate conditions based on the new cache state
    for key in cache_snapshot.cache:
        metadata["prefetching"][key] = "updated_based_on_cache_state"
        metadata["coherence"][key] = False  # Ensure coherence status updated