# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
WEIGHT_LRU = 0.5
WEIGHT_LFU = 0.5

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, recency of access, prefetching hints, coherence status, and a Hash Map for quick access to cache entries. It also uses a Binary Tree for access frequencies, a Linked List for access order, and an Array for actual cache data.
hash_map = {}  # key -> object
frequency_tree = defaultdict(int)  # key -> frequency count
linked_list = deque()  # order of keys based on access
array_data = []  # storing the objects
recency_map = defaultdict(int)  # key -> recency (access count at last access)
coherence_status = defaultdict(bool)  # key -> coherence status (True if valid, False if invalid)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on a weighted combination of least frequently used and least recently accessed entries, using the Binary Tree and Linked List. Entries marked for invalidation due to coherence issues are prioritized for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_cost = float('inf')

    for key in linked_list:
        if not coherence_status[key]:
            return key

        frequency_cost = frequency_tree[key]
        recency_cost = cache_snapshot.access_count - recency_map[key]
        cost = WEIGHT_LFU * frequency_cost + WEIGHT_LRU * recency_cost

        if cost < min_cost:
            min_cost = cost
            candid_obj_key = key
            
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access frequency in the Binary Tree, moves the accessed item to the front of the Linked List, updates the corresponding entry in the Hash Map, adjusts prefetching hints based on access patterns, and ensures coherence status is up-to-date.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    frequency_tree[key] += 1
    recency_map[key] = cache_snapshot.access_count
    if key in linked_list:
        linked_list.remove(key)
    linked_list.appendleft(key)
    hash_map[key] = obj
    coherence_status[key] = True

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy adds the object to the Hash Map, inserts it into the Binary Tree with an initial frequency count, appends it to the end of the Linked List, places it in the next available slot in the Array, initializes access frequency and recency of access, sets prefetching hints based on the object's context, and ensures coherence status is up-to-date.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    hash_map[key] = obj
    frequency_tree[key] = 1
    recency_map[key] = cache_snapshot.access_count
    linked_list.appendleft(key)
    array_data.append(obj)
    coherence_status[key] = True

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes the object from the Hash Map, deletes its node from the Binary Tree, removes it from the Linked List, clears its slot in the Array, recalculates the weighted criteria for remaining entries, updates prefetching hints to reflect the new cache state, and ensures coherence status is maintained.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    del hash_map[key]
    del frequency_tree[key]
    del recency_map[key]
    linked_list.remove(key)
    array_data.remove(evicted_obj)
    del coherence_status[key]