# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import numpy as np

# Put tunable constant parameters below
TCN_WINDOW_SIZE = 10  # Size of the window for the temporal convolutional network
PRIVACY_NOISE_LEVEL = 0.1  # Level of differential privacy noise

# Put the metadata specifically maintained by the policy below. The policy maintains a graph structure where nodes represent cached objects and edges represent temporal access patterns. Each node has a temporal convolutional network (TCN) to capture access patterns over time. Differential privacy mechanisms are applied to the metadata to ensure privacy. Quantum supremacy principles are used to optimize the graph structure and TCN parameters.
class CacheMetadata:
    def __init__(self):
        self.graph = {}  # Graph structure: {key: {'tcn': TCN, 'edges': set()}}
        self.access_history = {}  # Access history for TCN updates: {key: [timestamps]}
    
    def add_node(self, key):
        self.graph[key] = {'tcn': np.zeros(TCN_WINDOW_SIZE), 'edges': set()}
        self.access_history[key] = []
    
    def remove_node(self, key):
        if key in self.graph:
            del self.graph[key]
        if key in self.access_history:
            del self.access_history[key]
        for node in self.graph.values():
            node['edges'].discard(key)
    
    def update_tcn(self, key, timestamp):
        if key in self.access_history:
            self.access_history[key].append(timestamp)
            if len(self.access_history[key]) > TCN_WINDOW_SIZE:
                self.access_history[key].pop(0)
            self.graph[key]['tcn'] = np.convolve(self.access_history[key], np.ones(TCN_WINDOW_SIZE), 'valid') + PRIVACY_NOISE_LEVEL

cache_metadata = CacheMetadata()

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy uses the graph neural network to predict the least likely accessed node in the near future, considering both temporal patterns and privacy-preserving noise. The node with the lowest predicted access probability is chosen as the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    min_access_prob = float('inf')
    for key, node in cache_metadata.graph.items():
        access_prob = np.mean(node['tcn'])
        if access_prob < min_access_prob:
            min_access_prob = access_prob
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the TCN of the accessed node is updated to reflect the new access pattern. The graph structure is adjusted to strengthen the edges connected to the accessed node. Differential privacy noise is recalibrated to maintain privacy guarantees.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    timestamp = cache_snapshot.access_count
    cache_metadata.update_tcn(obj.key, timestamp)
    for key in cache_snapshot.cache:
        if key != obj.key:
            cache_metadata.graph[obj.key]['edges'].add(key)
            cache_metadata.graph[key]['edges'].add(obj.key)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, a new node is added to the graph with an initial TCN. Edges are created based on recent access patterns. Differential privacy parameters are initialized for the new node to ensure privacy.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    cache_metadata.add_node(obj.key)
    timestamp = cache_snapshot.access_count
    cache_metadata.update_tcn(obj.key, timestamp)
    for key in cache_snapshot.cache:
        cache_metadata.graph[obj.key]['edges'].add(key)
        cache_metadata.graph[key]['edges'].add(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a node, the graph structure is updated to remove the node and its associated edges. The TCNs of remaining nodes are recalibrated to account for the change. Differential privacy noise is adjusted to maintain overall privacy guarantees.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    cache_metadata.remove_node(evicted_obj.key)
    for key in cache_snapshot.cache:
        cache_metadata.update_tcn(key, cache_snapshot.access_count)