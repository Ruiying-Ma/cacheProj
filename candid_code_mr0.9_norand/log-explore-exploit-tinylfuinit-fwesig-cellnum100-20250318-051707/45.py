# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

from collections import deque

# Put tunable constant parameters below
K = 3  # Number of LRU queues

# Put the metadata specifically maintained by the policy below. The system maintains a FIFO queue and k LRU queues (L1, L2, ..., Lk). Each object has a recency timestamp and a frequency counter. The sum of the capacities of the FIFO queue and the LRU queues equals the cache capacity.
fifo_queue = deque()
lru_queues = [deque() for _ in range(K)]
recency = {}
frequency = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The system first checks the FIFO queue for an object with zero frequency and evicts it. If no such object is found, it evicts the least-recently-used object from the non-empty LRU queue with the smallest subscript.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Check FIFO queue for an object with zero frequency
    for key in fifo_queue:
        if frequency[key] == 0:
            candid_obj_key = key
            break
    
    # If no such object is found, evict the least-recently-used object from the non-empty LRU queue with the smallest subscript
    if candid_obj_key is None:
        for lru_queue in lru_queues:
            if lru_queue:
                candid_obj_key = lru_queue[0]
                break
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Set the hit object's recency as the current timestamp and increment its frequency by 1. If it is in Li, move it to the most-recently-used end of the queue with subscript j = min(i+1, k). If Lj is full, flush the least-recently-used object in Lj to the most-recently-used end of Li.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    recency[key] = cache_snapshot.access_count
    frequency[key] += 1
    
    for i in range(K):
        if key in lru_queues[i]:
            lru_queues[i].remove(key)
            j = min(i + 1, K - 1)
            lru_queues[j].append(key)
            
            if len(lru_queues[j]) > cache_snapshot.capacity // (K + 1):
                flushed_key = lru_queues[j].popleft()
                lru_queues[i].append(flushed_key)
            break

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    Set the inserted object's recency as the current timestamp and its frequency as 1. Put it at the most-recently-used end of L1. If L1 is full, flush the least-recently-used object in L1 to the rear of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    recency[key] = cache_snapshot.access_count
    frequency[key] = 1
    lru_queues[0].append(key)
    
    if len(lru_queues[0]) > cache_snapshot.capacity // (K + 1):
        flushed_key = lru_queues[0].popleft()
        fifo_queue.append(flushed_key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Remove the evicted object from its queue. Move all remaining objects behind the evicted object in the FIFO queue one step forward to fill the vacancy. The evicted object's recency and frequency are no longer tracked.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in fifo_queue:
        fifo_queue.remove(evicted_key)
    else:
        for lru_queue in lru_queues:
            if evicted_key in lru_queue:
                lru_queue.remove(evicted_key)
                break
    
    del recency[evicted_key]
    del frequency[evicted_key]