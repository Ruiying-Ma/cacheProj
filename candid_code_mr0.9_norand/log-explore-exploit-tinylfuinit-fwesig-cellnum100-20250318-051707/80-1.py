# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
WINDOW_CACHE_SIZE = 10
CBF_DECAY_INTERVAL = 100

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, last access time, write status, data locality score, memory bandwidth usage, cache coherence state, packet inspection results, page size, and a Count Bloom Filter (CBF) for frequency estimation.
class Metadata:
    def __init__(self):
        self.frequency = defaultdict(int)
        self.last_access_time = {}
        self.write_status = {}
        self.data_locality_score = {}
        self.memory_bandwidth_usage = {}
        self.packet_inspection_results = {}
        self.cache_coherence_state = {}
        self.page_size = {}
        self.cbf = defaultdict(int)
        self.eviction_count = 0

metadata = Metadata()
window_cache = deque()

def composite_score(obj):
    # Calculate composite weighted score based on the attributes
    freq = metadata.frequency[obj.key]
    last_access = metadata.last_access_time[obj.key]
    locality_score = metadata.data_locality_score[obj.key]
    write_status = metadata.write_status[obj.key]
    bandwidth_usage = metadata.memory_bandwidth_usage[obj.key]
    packet_inspection = metadata.packet_inspection_results[obj.key]
    
    # Weights are hypothetical, tune them based on requirements
    return (0.3 * freq - 0.2 * last_access +
            0.1 * locality_score + 0.1 * write_status -
            0.2 * bandwidth_usage + 0.1 * packet_inspection)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy selects a victim based on a composite weighted score derived from access frequency, last access time, data locality score, write status, memory bandwidth usage, and packet inspection results, with a preference for clean entries and ensuring cache coherence. It uses a two-part cache structure with a small window cache (W) using LRU and a larger main cache (M) with the composite score-based eviction policy. The least recently used object from W is compared with an object from M using CBF frequency, and the higher frequency object is retained.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    if window_cache:
        # Evicting from window cache (W)
        evict_candidate = window_cache.popleft()
        if evict_candidate in cache_snapshot.cache:
            candid_obj_key = evict_candidate
    else:
        # Select a candidate from main cache (M) based on composite score
        min_score = float('inf')
        for key in cache_snapshot.cache:
            candidate = cache_snapshot.cache[key]
            score = composite_score(candidate)
            if (score < min_score or 
                (score == min_score and metadata.write_status[key] == 'clean')):
                min_score = score
                candid_obj_key = key

        # Ensure cache coherence
        # This part would involve updating states of related objects in a real implementation

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Immediately after a hit, the policy increments the access frequency, updates the last access time to the current time, recalculates the data locality score, adjusts memory bandwidth usage and packet inspection results based on the latest access patterns, increases the hit object's frequency in CBF, and ensures cache coherence by updating states of related objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    metadata.frequency[obj.key] += 1
    metadata.last_access_time[obj.key] = cache_snapshot.access_count
    metadata.data_locality_score[obj.key] = 0  # Placeholder for actual calculation
    metadata.memory_bandwidth_usage[obj.key] = 0  # Placeholder for actual calculation
    metadata.packet_inspection_results[obj.key] = 0  # Placeholder for actual calculation
    metadata.cbf[obj.key] += 1

    # Ensure cache coherence here

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    Immediately after inserting a new object, the policy initializes the access frequency to 1, sets the last access time to the current time, marks the write status as clean, calculates an initial data locality score, records initial memory bandwidth usage, performs packet inspection, notes the page size, increases the inserted object's frequency in CBF, and adds the object to W.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    metadata.frequency[obj.key] = 1
    metadata.last_access_time[obj.key] = cache_snapshot.access_count
    metadata.write_status[obj.key] = 'clean'
    metadata.data_locality_score[obj.key] = 0  # Placeholder for actual calculation
    metadata.memory_bandwidth_usage[obj.key] = 0  # Placeholder for actual calculation
    metadata.packet_inspection_results[obj.key] = 0  # Placeholder for actual calculation
    metadata.page_size[obj.key] = obj.size

    metadata.cbf[obj.key] += 1

    # Add the object to window cache (W)
    window_cache.append(obj.key)
    if len(window_cache) > WINDOW_CACHE_SIZE:
        window_cache.popleft()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Immediately after evicting a victim, the policy removes all associated metadata for the evicted entry, adjusts the data locality scores of remaining entries if influenced, recalculates memory bandwidth usage for remaining objects, decays CBF every K evictions, and ensures cache coherence by updating states of related objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    key = evicted_obj.key
    if key in metadata.frequency:
        del metadata.frequency[key]
    if key in metadata.last_access_time:
        del metadata.last_access_time[key]
    if key in metadata.write_status:
        del metadata.write_status[key]
    if key in metadata.data_locality_score:
        del metadata.data_locality_score[key]
    if key in metadata.memory_bandwidth_usage:
        del metadata.memory_bandwidth_usage[key]
    if key in metadata.packet_inspection_results:
        del metadata.packet_inspection_results[key]
    if key in metadata.page_size:
        del metadata.page_size[key]
    if key in metadata.cbf:
        del metadata.cbf[key]

    metadata.eviction_count += 1
    if metadata.eviction_count % CBF_DECAY_INTERVAL == 0:
        for k in metadata.cbf:
            metadata.cbf[k] = max(0, metadata.cbf[k] - 1)

    # Ensure cache coherence here