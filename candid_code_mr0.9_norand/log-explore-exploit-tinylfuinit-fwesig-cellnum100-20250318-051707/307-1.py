# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import numpy as np

# Put tunable constant parameters below
ACCESS_PATTERN_SMOOTHING = 0.8
INITIAL_ACCESS_PATTERN_SCORE = 1.0
EDGE_NODE_PROXIMITY = 1

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, last access timestamp, machine learning-based access pattern score, quantum encryption key for secure metadata storage, and edge computing node proximity.
metadata = {}

def initialize_metadata(obj, time):
    key = obj.key
    metadata[key] = {
        'access_frequency': 0,
        'last_access_timestamp': time,
        'access_pattern_score': INITIAL_ACCESS_PATTERN_SCORE,
        'quantum_encryption_key': None,  # Placeholder for quantum encryption key handling
        'edge_node_proximity': EDGE_NODE_PROXIMITY
    }

def update_metadata_on_access(obj, time):
    key = obj.key
    if key in metadata:
        metadata[key]['access_frequency'] += 1
        metadata[key]['last_access_timestamp'] = time
        score = metadata[key]['access_pattern_score']
        metadata[key]['access_pattern_score'] = ACCESS_PATTERN_SMOOTHING * score + (1 - ACCESS_PATTERN_SMOOTHING) * metadata[key]['access_frequency']

def evict(cache_snapshot, obj):
    candid_obj_key = None
    # Your code below
    victim_score = float('inf')
    for cached_key, cached_obj in cache_snapshot.cache.items():
        score = metadata[cached_key]['access_pattern_score']
        if score < victim_score:
            victim_score = score
            candid_obj_key = cached_key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    # Your code below
    update_metadata_on_access(obj, cache_snapshot.access_count)
    # Ensure metadata is securely updated with the quantum encryption key (handled separately)

def update_after_insert(cache_snapshot, obj):
    # Your code below
    initialize_metadata(obj, cache_snapshot.access_count)
    # Securely store the metadata using quantum encryption key (handled separately)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    # Your code below
    for cached_key in cache_snapshot.cache.keys():
        cached_obj = cache_snapshot.cache[cached_key]
        update_metadata_on_access(cached_obj, cache_snapshot.access_count)
    # Ensure metadata integrity and privacy with quantum encryption keys and zero-knowledge proof (handled separately)