# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

from collections import deque, defaultdict

# Put tunable constant parameters below
K = 3  # represents the number of LRU queues

# Put the metadata specifically maintained by the policy below. The system maintains k LRU queues, L1, L2,..., Lk, each with a predetermined capacity, and a single FIFO queue. It tracks the recency and access frequency of each cached object. The sum of the capacities of the LRU queues and the FIFO queue equals the cache capacity.
fifo_queue = deque()  # FIFO queue for newly inserted objects
lru_queues = [deque() for _ in range(K)]  # k LRU queues
object_data = {}  # Dictionary to store the metadata (recency and frequency) of each object

# Helper functions

def get_total_fifo_capacity(cache_snapshot):
    return cache_snapshot.capacity // (K + 1)

def prune_queue(q):
    while len(q) > 0 and q[0] not in object_data:
        q.popleft()

def move_to_mru(queue, obj_key):
    queue.remove(obj_key)
    queue.append(obj_key)

def evict_from_fifo():
    prune_queue(fifo_queue)
    for obj_key in fifo_queue:
        if object_data[obj_key]['freq'] == 0:
            fifo_queue.remove(obj_key)
            return obj_key
    return None

def evict_from_lru():
    for i in range(K):
        prune_queue(lru_queues[i])
        if len(lru_queues[i]) > 0:
            return lru_queues[i].popleft()
    return None

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    During eviction, the system first checks the FIFO queue. If it finds an object with zero frequency, it evicts that object. If no such object is found, it evicts the object at the least-recently-used end of the non-empty LRU queue with the smallest subscript.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = evict_from_fifo()
    if candid_obj_key is None:
        candid_obj_key = evict_from_lru()
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after a cache hit.
    Immediately after a hit, set the hit object's recency as the current timestamp and its frequency as 1. If it is in Li, move it to the most-recently-used end of the queue with subscript j = min(i+1, k). If Lj is consequently full, flush the least-recently-used object in Lj to the most-recently-used end of Li.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    obj_key = obj.key
    object_data[obj_key]['recency'] = cache_snapshot.access_count
    object_data[obj_key]['freq'] = 1

    for i in range(K):
        if obj_key in lru_queues[i]:
            lru_queues[i].remove(obj_key)
            j = min(i + 1, K - 1)
            lru_queues[j].append(obj_key)
            if len(lru_queues[j]) > cache_snapshot.capacity // (K + 1):
                lru_queues[i].appendleft(lru_queues[j].popleft())
            return

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    Immediately after insertion, set the inserted object's recency as the current timestamp and its frequency as 1. Put it at the most-recently-used end of the L1. If L1 is full, flush the least-recently-used object in L1 to the rear of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    obj_key = obj.key
    object_data[obj_key] = {
        'recency': cache_snapshot.access_count,
        'freq': 1
    }
    lru_queues[0].append(obj_key)
    if len(lru_queues[0]) > cache_snapshot.capacity // (K + 1):
        flushed_key = lru_queues[0].popleft()
        fifo_queue.append(flushed_key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Immediately after eviction, remove the evicted object from the queue it resides in. Its recency and frequency are no longer tracked by the system. Move all the remaining objects behind this evicted object in the FIFO queue one step front to occupy the evicted position, so that the FIFO queue has no vacancy in the middle.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_obj_key = evicted_obj.key
    if evicted_obj_key in fifo_queue:
        fifo_queue.remove(evicted_obj_key)
    else:
        for i in range(K):
            if evicted_obj_key in lru_queues[i]:
                lru_queues[i].remove(evicted_obj_key)
                break
    if evicted_obj_key in object_data:
        del object_data[evicted_obj_key]