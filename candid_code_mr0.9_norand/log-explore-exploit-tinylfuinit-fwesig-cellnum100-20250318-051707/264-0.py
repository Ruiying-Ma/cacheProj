# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections

# Put tunable constant parameters below
DP_NOISE_LEVEL = 1.0  # Differential privacy noise level
INITIAL_DATA_LOCALITY_SCORE = 1.0  # Initial score when a new object is inserted
TCN_TIMESTAMPS = 5  # Number of recent access times to keep for TCN

# Put the metadata specifically maintained by the policy below. The policy maintains access frequency, last access time, write status, data locality score, and a graph structure with nodes representing cached objects and edges representing temporal access patterns. Each node has a temporal convolutional network (TCN) to capture access patterns over time, with differential privacy mechanisms applied to ensure privacy.

class Metadata:
    def __init__(self):
        self.access_frequency = collections.defaultdict(int)
        self.last_access_time = collections.defaultdict(int)
        self.write_status = collections.defaultdict(lambda: 'clean')
        self.data_locality_score = collections.defaultdict(float)
        self.tcn = collections.defaultdict(list)
        self.graph = collections.defaultdict(set)

meta = Metadata()

def calculate_composite_score(obj_key, current_time):
    """Calculate the composite score for evicting an object."""
    frequency = meta.access_frequency[obj_key]
    last_access = meta.last_access_time[obj_key]
    locality = meta.data_locality_score[obj_key]
    tcn_predict = predict_access_probability(obj_key)

    # Calculate score: higher is more likely to be evicted
    score = (1 / (frequency + 1)) + (current_time - last_access) + (1 / (locality + 1)) + (1 / (tcn_predict + 1))
    # Prefer clean entries
    if meta.write_status[obj_key] == 'dirty':
        score += 10  # arbitrary high weight for dirty items
    return score

def predict_access_probability(obj_key):
    """Predicts access probability from TCN, placeholder for actual TCN-based model."""
    # Simple heuristic: more recent access means higher probability
    if not meta.tcn[obj_key]:
        return 0
    recent_timestamps = meta.tcn[obj_key][-TCN_TIMESTAMPS:]
    # Favor more recent accesses
    return sum(1 / (i + 1) for i in recent_timestamps[::-1])

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy uses a composite score derived from access frequency, last access time, data locality score, and predicted access probability from the graph neural network to choose the eviction victim. Preference is given to clean entries to minimize write-backs.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    current_time = cache_snapshot.access_count

    # Identify the eviction victim based on composite score
    min_score = float('inf')
    for obj_key in cache_snapshot.cache:
        score = calculate_composite_score(obj_key, current_time)
        if score < min_score:
            min_score = score
            candid_obj_key = obj_key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the access frequency, updates the last access time, recalculates the data locality score, updates the TCN of the accessed node, strengthens the edges connected to the accessed node, and recalibrates differential privacy noise.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    obj_key = obj.key
    current_time = cache_snapshot.access_count

    meta.access_frequency[obj_key] += 1
    meta.last_access_time[obj_key] = current_time
    # Simulate recalculation of data locality score
    meta.data_locality_score[obj_key] = INITIAL_DATA_LOCALITY_SCORE  # Placeholder for actual calculation

    # Update TCN
    if len(meta.tcn[obj_key]) >= TCN_TIMESTAMPS:
        meta.tcn[obj_key].pop(0)
    meta.tcn[obj_key].append(current_time)

    # Strengthen graph edges
    for node in meta.graph:
        if node != obj_key:
            meta.graph[node].add(obj_key)
            meta.graph[obj_key].add(node)

    # Recalibrate differential privacy noise
    meta.data_locality_score[obj_key] += DP_NOISE_LEVEL

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the access frequency to 1, sets the last access time, marks the write status as clean, calculates an initial data locality score, adds a new node to the graph with an initial TCN, creates edges based on recent access patterns, and initializes differential privacy parameters.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    obj_key = obj.key
    current_time = cache_snapshot.access_count

    meta.access_frequency[obj_key] = 1
    meta.last_access_time[obj_key] = current_time
    meta.write_status[obj_key] = 'clean'
    meta.data_locality_score[obj_key] = INITIAL_DATA_LOCALITY_SCORE
    meta.tcn[obj_key] = [current_time]
    meta.graph[obj_key] = set()

    # Initialize graph connections and DP parameters
    for node in cache_snapshot.cache:
        if node != obj_key:
            meta.graph[node].add(obj_key)
            meta.graph[obj_key].add(node)
    meta.data_locality_score[obj_key] += DP_NOISE_LEVEL

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes all associated metadata, updates the graph structure to remove the node and its edges, recalibrates the TCNs of remaining nodes, adjusts data locality scores of remaining entries, and recalibrates differential privacy noise.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key

    # Remove all associated metadata
    del meta.access_frequency[evicted_key]
    del meta.last_access_time[evicted_key]
    del meta.write_status[evicted_key]
    del meta.data_locality_score[evicted_key]
    del meta.tcn[evicted_key]
    del meta.graph[evicted_key]

    # Remove graph edges
    for node in meta.graph:
        if evicted_key in meta.graph[node]:
            meta.graph[node].remove(evicted_key)

    # Recalibrate remaining metadata
    for node in meta.graph:
        meta.data_locality_score[node] += DP_NOISE_LEVEL