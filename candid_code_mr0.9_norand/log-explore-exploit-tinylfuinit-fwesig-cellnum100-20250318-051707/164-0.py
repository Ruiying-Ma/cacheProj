# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import collections
import time

# Put tunable constant parameters below
FETCH_COST_WEIGHT = 0.1
RECENCY_WEIGHT = 0.5
FREQUENCY_WEIGHT = 0.3
REPLACEMENT_SCORE_WEIGHT = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains a Hash Map for quick access, a Binary Tree for access frequencies, a Linked List for order of access, an Array for cache data, hit ratio tracking, cache residency time, access frequency patterns, replacement scores, fetch cost score, and queue positions (FIFO or LRU).
class CacheMetadata:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.access_frequency = collections.defaultdict(int)
        self.linked_list = collections.OrderedDict()
        self.array = []
        self.hit_ratio = collections.defaultdict(float)
        self.residency_time = {}
        self.access_patterns = collections.defaultdict(list)
        self.replacement_scores = collections.defaultdict(float)
        self.fetch_cost = collections.defaultdict(float)
        self.queue_positions = collections.defaultdict(int)
        self.LRU_queues = [collections.OrderedDict() for _ in range(5)]

metadata = CacheMetadata(capacity=1000)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first checks the FIFO queue (LRU_queues[0]) for an object with zero frequency and evicts it.
    If no such object is found, it calculates a combined score based on low access frequency, low recency of access, high fetch cost, and low replacement score, and evicts the object with the lowest score from the non-empty LRU queue with the smallest subscript.
    '''
    candid_obj_key = None

    # Check FIFO queue for zero frequency object to evict
    for key, value in metadata.LRU_queues[0].items():
        if metadata.access_frequency[key] == 0:
            candid_obj_key = key
            break

    if candid_obj_key is None:
        min_score = float('inf')
        for queue in metadata.LRU_queues:
            for key in queue:
                score = metadata.replacement_scores[key]
                if score < min_score:
                    min_score = score
                    candid_obj_key = key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    '''
    key = obj.key
    metadata.access_frequency[key] += 1
    if key in metadata.linked_list:
        metadata.linked_list.move_to_end(key)
    metadata.hit_ratio[key] = cache_snapshot.hit_count / cache_snapshot.access_count
    metadata.residency_time[key] = cache_snapshot.access_count
    metadata.access_patterns[key].append(cache_snapshot.access_count)
    metadata.fetch_cost[key] -= 0.01  # Slightly decrease the fetch cost score
    queue_pos = metadata.queue_positions[key]
    if queue_pos < len(metadata.LRU_queues) - 1:
        del metadata.LRU_queues[queue_pos][key]
        metadata.LRU_queues[queue_pos + 1][key] = obj
        metadata.queue_positions[key] += 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    key = obj.key
    metadata.cache[key] = obj
    metadata.access_frequency[key] = 1
    metadata.linked_list[key] = obj
    metadata.array.append(obj)
    metadata.hit_ratio[key] = 0
    metadata.residency_time[key] = cache_snapshot.access_count
    metadata.access_patterns[key] = [cache_snapshot.access_count]
    metadata.fetch_cost[key] = obj.size / 100.0  # Initial fetch cost based on object size
    metadata.replacement_scores[key] = 0.0
    metadata.queue_positions[key] = 0
    metadata.LRU_queues[0][key] = obj

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    evicted_key = evicted_obj.key
    del metadata.cache[evicted_key]
    del metadata.access_frequency[evicted_key]
    del metadata.linked_list[evicted_key]
    metadata.array.remove(evicted_obj)
    del metadata.hit_ratio[evicted_key]
    del metadata.residency_time[evicted_key]
    del metadata.access_patterns[evicted_key]
    del metadata.replacement_scores[evicted_key]
    del metadata.fetch_cost[evicted_key]
    queue_pos = metadata.queue_positions[evicted_key]
    del metadata.LRU_queues[queue_pos][evicted_key]
    del metadata.queue_positions[evicted_key]

    # Recalculate replacement scores for remaining items
    for key in metadata.cache.keys():
        freq_score = FREQUENCY_WEIGHT * metadata.access_frequency[key]
        recency_score = RECENCY_WEIGHT * (cache_snapshot.access_count - metadata.residency_time[key])
        fetch_cost_score = FETCH_COST_WEIGHT * metadata.fetch_cost[key]
        replacement_score = REPLACEMENT_SCORE_WEIGHT * metadata.replacement_scores[key]
        metadata.replacement_scores[key] = freq_score + recency_score + fetch_cost_score - replacement_score