# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

from collections import defaultdict, deque

# Put tunable constant parameters below
RESIDENCY_TIME_WEIGHT = 0.4  # Weight for residency time in the replacement score
HIT_RATIO_WEIGHT = 0.4       # Weight for hit ratio in the replacement score
ACCESS_FREQ_WEIGHT = 0.2     # Weight for access frequency in the replacement score

# Put the metadata specifically maintained by the policy below. The policy maintains hit ratio tracking for each cache line, cache residency time, access frequency patterns, and a replacement score for each cache line.

metadata = {
    "hit_ratios": defaultdict(lambda: 0),
    "residency_times": defaultdict(lambda: 0),
    "access_frequencies": defaultdict(lambda: 0),
    "access_times": defaultdict(lambda: deque(maxlen=10))  # Stores recent access times for frequency tracking
}

def calculate_replacement_score(key, current_time):
    hit_ratio = metadata['hit_ratios'][key]
    residency_time = current_time - metadata['residency_times'][key]
    access_frequency = metadata['access_frequencies'][key]
    
    return (
        (1 - hit_ratio) * HIT_RATIO_WEIGHT +
        residency_time * RESIDENCY_TIME_WEIGHT +
        (10 - access_frequency) * ACCESS_FREQ_WEIGHT
    )

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on the lowest replacement score, which is calculated using a combination of low hit ratio, long residency time, and infrequent access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    lowest_score = float('inf')
    current_time = cache_snapshot.access_count
    
    for key in cache_snapshot.cache:
        score = calculate_replacement_score(key, current_time)
        if score < lowest_score:
            lowest_score = score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the hit ratio by incrementing the hit count, resets the residency time, and updates the access frequency pattern to reflect the recent access.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key
    
    # Update hit ratio
    metadata['hit_ratios'][key] += 1
    
    # Reset residency time
    metadata['residency_times'][key] = current_time
    
    # Update access frequency pattern
    metadata['access_times'][key].append(current_time)
    metadata['access_frequencies'][key] = len(metadata['access_times'][key])

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the hit ratio to zero, sets the residency time to the current time, and starts tracking the access frequency pattern from the moment of insertion.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key
    
    # Initialize hit ratio
    metadata['hit_ratios'][key] = 0
    
    # Set residency time
    metadata['residency_times'][key] = current_time
    
    # Initialize access frequency pattern
    metadata['access_frequencies'][key] = 0
    metadata['access_times'][key] = deque(maxlen=10)
    metadata['access_times'][key].append(current_time)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes all metadata associated with the evicted cache line and recalculates the replacement scores for the remaining cache lines to ensure accurate future evictions.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    
    # Remove all metadata associated with the evicted cache line
    del metadata['hit_ratios'][evicted_key]
    del metadata['residency_times'][evicted_key]
    del metadata['access_frequencies'][evicted_key]
    del metadata['access_times'][evicted_key]
    
    # No need to recalculate the replacement scores for the remaining cache lines,
    # as they will be recalculated dynamically during the next eviction process.