# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Utility imports
from collections import defaultdict

# Put tunable constant parameters below
LATENCY_IMPACT_WEIGHT = 0.4
MEM_BANDWIDTH_WEIGHT = 0.3
PAGE_RANK_WEIGHT = 0.2
ERROR_CORRECTION_WEIGHT = 0.1

# Put the metadata specifically maintained by the policy below. The policy maintains hit ratio, residency time, access frequency, recency of access, spatial locality score, memory scheduling priority, write-back status, latency impact score, last access timestamp, memory bandwidth usage, page ranking score, and error correction code status for each cache entry.
metadata = defaultdict(lambda: {
    "hit_ratio": 0,
    "residency_time": 0,
    "access_freq": 0,
    "recency_timestamp": 0,
    "spatial_loc_score": 0,
    "memory_sched_priority": 0,
    "write_back_status": 'clean',
    "latency_impact_score": 0,
    "last_access_timestamp": 0,
    "memory_bandwidth_usage": 0,
    "page_ranking_score": 0,
    "error_correction_code_status": 'ok'
})

def calculate_replacement_score(meta):
    return (LATENCY_IMPACT_WEIGHT * meta["latency_impact_score"] +
            MEM_BANDWIDTH_WEIGHT * meta["memory_bandwidth_usage"] +
            PAGE_RANK_WEIGHT * meta["page_ranking_score"] +
            ERROR_CORRECTION_WEIGHT * (0 if meta["error_correction_code_status"] == 'ok' else 1))

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim based on a composite score derived from the lowest replacement score, page ranking algorithm, memory bandwidth usage, and error correction code status, prioritizing entries with the lowest combined score and higher error rates.
    '''
    candid_obj_key = None
    lowest_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        score = calculate_replacement_score(metadata[key])
        if score < lowest_score:
            lowest_score = score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after a cache hit.
    '''
    meta = metadata[obj.key]
    current_time = cache_snapshot.access_count
    
    meta["hit_ratio"] += 1
    meta["access_freq"] += 1
    meta["residency_time"] = current_time
    meta["recency_timestamp"] = current_time
    meta["spatial_loc_score"] += 1  # Assume some recalculated value
    meta["memory_sched_priority"] += 1  # Assume some adjusted value
    meta["last_access_timestamp"] = current_time
    meta["latency_impact_score"] += 1  # Assume recalculated value
    meta["page_ranking_score"] += 1  # Assume recalculated value
    
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    '''
    meta = metadata[obj.key]
    current_time = cache_snapshot.access_count
    
    meta.update({
        "hit_ratio": 0,
        "residency_time": current_time,
        "access_freq": 0,
        "recency_timestamp": current_time,
        "spatial_loc_score": 0,  # Assume an initial score
        "memory_sched_priority": 0,  # Default priority
        "write_back_status": 'clean',
        "latency_impact_score": 0,  # Initial score
        "last_access_timestamp": current_time,
        "memory_bandwidth_usage": 0,  # Initial bandwidth usage
        "page_ranking_score": 0,  # Initial page ranking score
        "error_correction_code_status": 'ok'
    })

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    '''
    if evicted_obj.key in metadata:
        del metadata[evicted_obj.key]
    
    for key, cached_obj in cache_snapshot.cache.items():
        meta = metadata[key]
        # Assume recalculations and optimizations here
        meta["latency_impact_score"] += 1  # Recalculated value
        meta["memory_sched_priority"] += 1  # Adjusted value
        meta["page_ranking_score"] += 1  # Recalculated score
        meta["memory_bandwidth_usage"] += 1  # Adjusted stats
        meta["error_correction_code_status"] = 'ok'  # Reset or check status