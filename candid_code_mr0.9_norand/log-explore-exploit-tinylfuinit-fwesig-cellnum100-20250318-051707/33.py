# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque

# Put tunable constant parameters below
k = 3  # Number of LRU queues
lru_capacities = [10, 20, 30]  # Capacities of L1, L2, ..., Lk
fifo_capacity = 40  # Capacity of the FIFO queue

# Put the metadata specifically maintained by the policy below. The system maintains k LRU queues, L1, L2,..., Lk, each with a predetermined capacity, and a single FIFO queue. It tracks the recency and access frequency of each cached object. The sum of the capacities of the LRU queues and the FIFO queue equals the cache capacity.
lru_queues = [deque() for _ in range(k)]
fifo_queue = deque()
recency = {}
frequency = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    During eviction, the system first checks the FIFO queue. If it finds an object with zero frequency, it evicts that object. If no such object is found, it evicts the object at the least-recently-used end of the non-empty LRU queue with the smallest subscript.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Check FIFO queue for zero frequency object
    for fifo_obj in fifo_queue:
        if frequency[fifo_obj.key] == 0:
            candid_obj_key = fifo_obj.key
            break
    # If no zero frequency object in FIFO, check LRU queues
    if candid_obj_key is None:
        for i in range(k):
            if lru_queues[i]:
                candid_obj_key = lru_queues[i][0].key
                break
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Immediately after a hit, set the hit object's recency as the current timestamp and its frequency as 1. If it is in Li, move it to the most-recently-used end of the queue with subscript j = min(i+1, k). If Lj is consequently full, flush the least-recently-used object in Lj to the most-recently-used end of Li.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    recency[obj.key] = cache_snapshot.access_count
    frequency[obj.key] = 1
    for i in range(k):
        if obj in lru_queues[i]:
            lru_queues[i].remove(obj)
            j = min(i + 1, k - 1)
            lru_queues[j].append(obj)
            if len(lru_queues[j]) > lru_capacities[j]:
                flushed_obj = lru_queues[j].popleft()
                lru_queues[i].append(flushed_obj)
            break

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    Immediately after insertion, set the inserted object's recency as the current timestamp and its frequency as 1. Put it at the most-recently-used end of the L1. If L1 is full, flush the least-recently-used object in L1 to the rear of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    recency[obj.key] = cache_snapshot.access_count
    frequency[obj.key] = 1
    lru_queues[0].append(obj)
    if len(lru_queues[0]) > lru_capacities[0]:
        flushed_obj = lru_queues[0].popleft()
        fifo_queue.append(flushed_obj)
        if len(fifo_queue) > fifo_capacity:
            fifo_queue.popleft()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Immediately after eviction, remove the evicted object from the queue it resides in. Its recency and frequency are no longer tracked by the system. Move all the remaining objects behind this evicted object in the FIFO queue one step front to occupy the evicted position, so that the FIFO queue has no vacancy in the middle.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    if evicted_obj in fifo_queue:
        fifo_queue.remove(evicted_obj)
    else:
        for i in range(k):
            if evicted_obj in lru_queues[i]:
                lru_queues[i].remove(evicted_obj)
                break
    del recency[evicted_obj.key]
    del frequency[evicted_obj.key]