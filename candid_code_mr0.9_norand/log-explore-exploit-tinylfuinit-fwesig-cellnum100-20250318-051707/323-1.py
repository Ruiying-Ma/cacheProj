# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque
import heapq

# Put tunable constant parameters below
MAX_GQ_SIZE = 100
INITIAL_LATENCY_IMPACT = 10

# Put the metadata specifically maintained by the policy below. The policy maintains a Hash Map for quick access, a Binary Tree for access frequencies, a Linked List for access order, an Array for cache data, access frequency, last access timestamp, write-back status, latency impact score, encryption keys, user authentication status, and privacy compliance flags. It also includes a ghost FIFO queue (GQ) for recently evicted objects.

class CacheMetadata:
    def __init__(self):
        self.hash_map = {}
        self.access_frequency = {}
        self.access_order = deque()
        self.cache_data = {}
        self.last_access_timestamp = {}
        self.write_back_status = defaultdict(bool)
        self.latency_impact_score = defaultdict(lambda: INITIAL_LATENCY_IMPACT)
        self.encryption_keys = {}
        self.user_auth_status = {}
        self.privacy_compliance_flags = {}
        self.ghost_fifo_queue = deque()
    
    def reset_object_metadata(self, obj_key):
        self.access_frequency[obj_key] = 0
        self.write_back_status[obj_key] = False
        self.latency_impact_score[obj_key] = INITIAL_LATENCY_IMPACT
        self.encryption_keys[obj_key] = None
        self.user_auth_status[obj_key] = False
        self.privacy_compliance_flags[obj_key] = False

metadata = CacheMetadata()

def evict(cache_snapshot, obj):
    candid_obj_key = None
    # Calculate composite scores for each object in cache
    composite_scores = []
    for key, cache_obj in cache_snapshot.cache.items():
        score = (
            metadata.access_frequency[key] +
            cache_snapshot.access_count - metadata.last_access_timestamp[key] +
            metadata.write_back_status[key] +
            metadata.latency_impact_score[key] +
            (metadata.encryption_keys[key] is None) +
            (not metadata.privacy_compliance_flags[key])
        )
        heapq.heappush(composite_scores, (score, metadata.access_order.index(key), key))

    # Select object with lowest composite score
    if composite_scores:
        _, _, candid_obj_key = heapq.heappop(composite_scores)

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    # Increment access frequency (capped at 3)
    metadata.access_frequency[obj.key] = min(3, metadata.access_frequency[obj.key] + 1)
    # Refresh last access timestamp
    metadata.last_access_timestamp[obj.key] = cache_snapshot.access_count
    # Recalculate latency impact score (Dummy implementation)
    metadata.latency_impact_score[obj.key] = INITIAL_LATENCY_IMPACT
    # Move item to front of access order
    metadata.access_order.remove(obj.key)
    metadata.access_order.appendleft(obj.key)
    # Update Hash Map
    metadata.hash_map[obj.key] = obj
    # Refresh encryption key (Dummy implementation)
    metadata.encryption_keys[obj.key] = "new_key"
    # Verify user authentication status (Dummy implementation)
    metadata.user_auth_status[obj.key] = True
    # Update privacy compliance status (Dummy implementation)
    metadata.privacy_compliance_flags[obj.key] = True

def update_after_insert(cache_snapshot, obj):
    # Initialize access frequency to 0 in Binary Tree
    metadata.access_frequency[obj.key] = 0
    # Set last access timestamp to current access count
    metadata.last_access_timestamp[obj.key] = cache_snapshot.access_count
    # Mark write-back status as clean
    metadata.write_back_status[obj.key] = False
    # Assign initial latency impact score
    metadata.latency_impact_score[obj.key] = INITIAL_LATENCY_IMPACT
    # Append to Linked List (access order)
    metadata.access_order.appendleft(obj.key)
    # Add to cache data array
    metadata.cache_data[obj.key] = obj
    # Update Hash Map
    metadata.hash_map[obj.key] = obj
    # Assign a new encryption key (Dummy implementation)
    metadata.encryption_keys[obj.key] = "new_key"
    # Record user authentication status (Dummy implementation)
    metadata.user_auth_status[obj.key] = True
    # Ensure privacy compliance (Dummy implementation)
    metadata.privacy_compliance_flags[obj.key] = True
    # Put at rear of ghost FIFO queue if not in GQ, otherwise rear of MQ (Dummy implementation)
    if obj.key not in metadata.ghost_fifo_queue:
        metadata.ghost_fifo_queue.append(obj.key)
        if len(metadata.ghost_fifo_queue) > MAX_GQ_SIZE:
            metadata.ghost_fifo_queue.popleft()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    # Remove from Hash Map
    if evicted_obj.key in metadata.hash_map: del metadata.hash_map[evicted_obj.key]
    # Remove from Binary Tree (access_frequency)
    if evicted_obj.key in metadata.access_frequency: del metadata.access_frequency[evicted_obj.key]
    # Remove from Linked List (access order)
    if evicted_obj.key in metadata.access_order: metadata.access_order.remove(evicted_obj.key)
    # Clear from Array (cache_data)
    if evicted_obj.key in metadata.cache_data: del metadata.cache_data[evicted_obj.key]
    # Adjust latency impact scores of other entries (Dummy implementation, assuming no changes required)
    # Remove encryption key
    if evicted_obj.key in metadata.encryption_keys: del metadata.encryption_keys[evicted_obj.key]
    # Reset access frequency
    if evicted_obj.key in metadata.access_frequency: del metadata.access_frequency[evicted_obj.key]
    # Clear user authentication status
    if evicted_obj.key in metadata.user_auth_status: del metadata.user_auth_status[evicted_obj.key]
    # Update privacy compliance records
    if evicted_obj.key in metadata.privacy_compliance_flags: del metadata.privacy_compliance_flags[evicted_obj.key]
    # Place evicted object at rear of GQ
    metadata.ghost_fifo_queue.append(evicted_obj.key)
    if len(metadata.ghost_fifo_queue) > MAX_GQ_SIZE:
        metadata.ghost_fifo_queue.popleft()