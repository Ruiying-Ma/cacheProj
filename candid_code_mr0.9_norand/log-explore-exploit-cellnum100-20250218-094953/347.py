# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import time

# Put tunable constant parameters below
INITIAL_PREDICTIVE_CACHE_INDEX_SCORE = 1.0
INITIAL_HEURISTIC_ADJUSTMENT_FACTOR = 1.0

# Put the metadata specifically maintained by the policy below. The policy maintains a data access log, access frequency, last access time, data size, predictive cache index scores, heuristic adjustment factors for memory optimization, and system load for load balancing across nodes.
data_access_log = {}
access_frequency = {}
last_access_time = {}
data_size = {}
predictive_cache_index_scores = {}
heuristic_adjustment_factors = {}
system_load = 0

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by calculating a composite score for each cached item, factoring in low access frequency, older last access time, larger data size, lower predictive cache index score, and heuristic adjustment factor. Items with the lowest composite scores are selected for eviction, ensuring memory optimization and load balancing.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_composite_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        composite_score = (
            access_frequency[key] * 0.2 +
            (cache_snapshot.access_count - last_access_time[key]) * 0.2 +
            data_size[key] * 0.2 +
            predictive_cache_index_scores[key] * 0.2 +
            heuristic_adjustment_factors[key] * 0.2
        )
        
        if composite_score < min_composite_score:
            min_composite_score = composite_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the data access log, increments the access frequency, refreshes the last access time, recalculates the predictive cache index score, adjusts the heuristic factor for memory optimization, and reassesses the system load for balanced cache usage.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    access_frequency[key] += 1
    last_access_time[key] = cache_snapshot.access_count
    predictive_cache_index_scores[key] = calculate_predictive_cache_index_score(key)
    heuristic_adjustment_factors[key] = calculate_heuristic_adjustment_factor(key)
    reassess_system_load()

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy logs the insertion in the data access log, initializes the access frequency to one, sets the last access time to the current time, assigns an initial predictive cache index score and heuristic adjustment factor based on historical data, and updates the system load to reflect the new addition.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    data_access_log[key] = cache_snapshot.access_count
    access_frequency[key] = 1
    last_access_time[key] = cache_snapshot.access_count
    data_size[key] = obj.size
    predictive_cache_index_scores[key] = INITIAL_PREDICTIVE_CACHE_INDEX_SCORE
    heuristic_adjustment_factors[key] = INITIAL_HEURISTIC_ADJUSTMENT_FACTOR
    reassess_system_load()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the evicted object from the data access log, deletes all associated metadata, recalculates predictive cache index scores and heuristic factors for remaining objects if necessary, and reassesses the system load to ensure balanced cache usage.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    del data_access_log[key]
    del access_frequency[key]
    del last_access_time[key]
    del data_size[key]
    del predictive_cache_index_scores[key]
    del heuristic_adjustment_factors[key]
    reassess_system_load()

def calculate_predictive_cache_index_score(key):
    # Placeholder for actual predictive cache index score calculation
    return INITIAL_PREDICTIVE_CACHE_INDEX_SCORE

def calculate_heuristic_adjustment_factor(key):
    # Placeholder for actual heuristic adjustment factor calculation
    return INITIAL_HEURISTIC_ADJUSTMENT_FACTOR

def reassess_system_load():
    global system_load
    # Placeholder for actual system load reassessment logic
    system_load = sum(data_size.values())