# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
ALPHA = 0.5  # Weight for the recursive temporal coherence score calculation

# Put the metadata specifically maintained by the policy below. The policy maintains a recursive temporal coherence score (RTCS) for each cache entry, a timestamp of the last access, and a reference count. RTCS is calculated using a recursive function that factors in the time since last access and the frequency of access.
metadata = {}

def calculate_rtcs(timestamp, ref_count, current_time):
    time_since_last_access = current_time - timestamp
    return ALPHA * (time_since_last_access / (ref_count + 1))

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the cache entry with the lowest RTCS. If there is a tie, it selects the entry with the oldest timestamp.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_rtcs = float('inf')
    oldest_timestamp = float('inf')

    for key, cached_obj in cache_snapshot.cache.items():
        rtcs = metadata[key]['rtcs']
        timestamp = metadata[key]['timestamp']
        if rtcs < min_rtcs or (rtcs == min_rtcs and timestamp < oldest_timestamp):
            min_rtcs = rtcs
            oldest_timestamp = timestamp
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the timestamp to the current time, increments the reference count, and recalculates the RTCS using the updated timestamp and reference count.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key
    metadata[key]['timestamp'] = current_time
    metadata[key]['ref_count'] += 1
    metadata[key]['rtcs'] = calculate_rtcs(metadata[key]['timestamp'], metadata[key]['ref_count'], current_time)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the timestamp to the current time, sets the reference count to 1, and calculates the initial RTCS based on these values.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    current_time = cache_snapshot.access_count
    key = obj.key
    metadata[key] = {
        'timestamp': current_time,
        'ref_count': 1,
        'rtcs': calculate_rtcs(current_time, 1, current_time)
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy removes the metadata associated with the evicted entry and recalculates the RTCS for the remaining entries to ensure data structure integrity.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in metadata:
        del metadata[evicted_key]
    
    current_time = cache_snapshot.access_count
    for key in cache_snapshot.cache:
        metadata[key]['rtcs'] = calculate_rtcs(metadata[key]['timestamp'], metadata[key]['ref_count'], current_time)