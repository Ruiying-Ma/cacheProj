# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
BASE_QAC = 1
NEUTRAL_PAS = 0

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including Quantum Access Counters (QAC) for each cache line, a Heuristic Latency Score (HLS) for each access pattern, Temporal Synchrony Index (TSI) for tracking access intervals, and a Predictive Anomaly Score (PAS) for detecting unusual access patterns.
metadata = {
    'QAC': {},  # Quantum Access Counters
    'HLS': {},  # Heuristic Latency Score
    'TSI': {},  # Temporal Synchrony Index
    'PAS': {}   # Predictive Anomaly Score
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the cache line with the lowest combined score of QAC, HLS, TSI, and PAS. This ensures that lines with low access frequency, high latency, irregular access intervals, and anomalous patterns are prioritized for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        combined_score = (metadata['QAC'][key] + 
                          metadata['HLS'][key] + 
                          metadata['TSI'][key] + 
                          metadata['PAS'][key])
        if combined_score < min_score:
            min_score = combined_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the QAC for the accessed line is incremented, the HLS is recalculated based on the current access latency, the TSI is updated to reflect the new access interval, and the PAS is adjusted based on the deviation from expected access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count
    
    # Increment QAC
    metadata['QAC'][key] += 1
    
    # Recalculate HLS
    last_access_time = metadata['TSI'][key]
    access_latency = current_time - last_access_time
    metadata['HLS'][key] = access_latency
    
    # Update TSI
    metadata['TSI'][key] = current_time
    
    # Adjust PAS
    expected_access_pattern = metadata['QAC'][key] / current_time
    actual_access_pattern = 1 / access_latency
    metadata['PAS'][key] = abs(expected_access_pattern - actual_access_pattern)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the QAC is initialized to a base value, the HLS is set based on the initial access latency, the TSI is initialized to track the first access interval, and the PAS is set to a neutral value indicating no initial anomaly.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count
    
    # Initialize QAC
    metadata['QAC'][key] = BASE_QAC
    
    # Set HLS based on initial access latency
    metadata['HLS'][key] = 0  # Initial latency is zero since it's the first access
    
    # Initialize TSI
    metadata['TSI'][key] = current_time
    
    # Set PAS to a neutral value
    metadata['PAS'][key] = NEUTRAL_PAS

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy recalibrates the HLS and PAS for the remaining cache lines to account for the removal, and adjusts the TSI to synchronize with the new access patterns. The QAC of the evicted line is reset.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    
    # Reset QAC of the evicted line
    metadata['QAC'].pop(evicted_key, None)
    
    # Recalibrate HLS and PAS for remaining cache lines
    for key in cache_snapshot.cache:
        if key != evicted_key:
            # Recalibrate HLS
            last_access_time = metadata['TSI'][key]
            current_time = cache_snapshot.access_count
            access_latency = current_time - last_access_time
            metadata['HLS'][key] = access_latency
            
            # Adjust PAS
            expected_access_pattern = metadata['QAC'][key] / current_time
            actual_access_pattern = 1 / access_latency
            metadata['PAS'][key] = abs(expected_access_pattern - actual_access_pattern)
    
    # Adjust TSI to synchronize with new access patterns
    for key in cache_snapshot.cache:
        if key != evicted_key:
            metadata['TSI'][key] = cache_snapshot.access_count