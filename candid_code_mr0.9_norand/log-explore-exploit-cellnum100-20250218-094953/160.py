# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
DEFAULT_FRAGMENTATION_SCORE = 1
INITIAL_HEURISTIC_DECAY = 10
INITIAL_PREDICTIVE_SCORE = 5

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including a fragmentation score for each cache block, a heuristic decay factor for access frequency, and a predictive score based on access patterns.
fragmentation_scores = {}
heuristic_decay_factors = {}
predictive_scores = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the cache block with the highest fragmentation score, lowest heuristic decay factor, and lowest predictive score, balancing these factors to optimize cache performance.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    max_fragmentation_score = -1
    min_heuristic_decay = float('inf')
    min_predictive_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        frag_score = fragmentation_scores.get(key, DEFAULT_FRAGMENTATION_SCORE)
        heuristic_decay = heuristic_decay_factors.get(key, INITIAL_HEURISTIC_DECAY)
        predictive_score = predictive_scores.get(key, INITIAL_PREDICTIVE_SCORE)
        
        if (frag_score > max_fragmentation_score or
            (frag_score == max_fragmentation_score and heuristic_decay < min_heuristic_decay) or
            (frag_score == max_fragmentation_score and heuristic_decay == min_heuristic_decay and predictive_score < min_predictive_score)):
            max_fragmentation_score = frag_score
            min_heuristic_decay = heuristic_decay
            min_predictive_score = predictive_score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy decreases the fragmentation score of the accessed block, applies the heuristic decay to its access frequency, and updates the predictive score based on recent access patterns.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    fragmentation_scores[key] = max(0, fragmentation_scores.get(key, DEFAULT_FRAGMENTATION_SCORE) - 1)
    heuristic_decay_factors[key] = max(0, heuristic_decay_factors.get(key, INITIAL_HEURISTIC_DECAY) - 1)
    predictive_scores[key] = predictive_scores.get(key, INITIAL_PREDICTIVE_SCORE) + 1

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes the fragmentation score to a default low value, sets the heuristic decay factor to an initial high value, and calculates an initial predictive score based on the object's access history if available.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    fragmentation_scores[key] = DEFAULT_FRAGMENTATION_SCORE
    heuristic_decay_factors[key] = INITIAL_HEURISTIC_DECAY
    predictive_scores[key] = INITIAL_PREDICTIVE_SCORE

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy recalculates the fragmentation scores of remaining blocks, adjusts the heuristic decay factors to reflect the new cache state, and updates predictive scores to account for the change in cache composition.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_key = evicted_obj.key
    if evicted_key in fragmentation_scores:
        del fragmentation_scores[evicted_key]
    if evicted_key in heuristic_decay_factors:
        del heuristic_decay_factors[evicted_key]
    if evicted_key in predictive_scores:
        del predictive_scores[evicted_key]
    
    for key in cache_snapshot.cache:
        fragmentation_scores[key] = max(0, fragmentation_scores.get(key, DEFAULT_FRAGMENTATION_SCORE) - 1)
        heuristic_decay_factors[key] = max(0, heuristic_decay_factors.get(key, INITIAL_HEURISTIC_DECAY) - 1)
        predictive_scores[key] = predictive_scores.get(key, INITIAL_PREDICTIVE_SCORE) + 1