# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
INITIAL_QUANTUM_EFFICIENCY_SCORE = 1.0

# Put the metadata specifically maintained by the policy below. The policy maintains metadata including access frequency, temporal access patterns, cluster membership of data objects, and a quantum efficiency score that measures the effectiveness of cache usage.
metadata = {
    'access_frequency': {},  # {obj.key: access_count}
    'temporal_access': {},   # {obj.key: last_access_time}
    'cluster_membership': {},  # {obj.key: cluster_id}
    'quantum_efficiency': {},  # {cluster_id: quantum_efficiency_score}
    'clusters': {},  # {cluster_id: set of obj.keys}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by identifying the cluster with the least recent access and the lowest quantum efficiency score, then selecting the least frequently accessed object within that cluster.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    # Identify the cluster with the least recent access and the lowest quantum efficiency score
    least_recent_access_time = float('inf')
    lowest_quantum_efficiency_score = float('inf')
    target_cluster_id = None

    for cluster_id, obj_keys in metadata['clusters'].items():
        if not obj_keys:
            continue
        cluster_last_access_time = min(metadata['temporal_access'][key] for key in obj_keys)
        cluster_quantum_efficiency_score = metadata['quantum_efficiency'][cluster_id]

        if (cluster_last_access_time < least_recent_access_time) or (
            cluster_last_access_time == least_recent_access_time and cluster_quantum_efficiency_score < lowest_quantum_efficiency_score):
            least_recent_access_time = cluster_last_access_time
            lowest_quantum_efficiency_score = cluster_quantum_efficiency_score
            target_cluster_id = cluster_id

    # Select the least frequently accessed object within that cluster
    if target_cluster_id is not None:
        target_cluster_keys = metadata['clusters'][target_cluster_id]
        candid_obj_key = min(target_cluster_keys, key=lambda k: metadata['access_frequency'][k])

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    After a cache hit, the policy updates the access frequency and temporal access pattern of the accessed object, recalculates its quantum efficiency score, and adjusts its cluster membership if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    metadata['access_frequency'][key] += 1
    metadata['temporal_access'][key] = cache_snapshot.access_count

    # Recalculate quantum efficiency score for the cluster
    cluster_id = metadata['cluster_membership'][key]
    cluster_keys = metadata['clusters'][cluster_id]
    total_accesses = sum(metadata['access_frequency'][k] for k in cluster_keys)
    metadata['quantum_efficiency'][cluster_id] = total_accesses / len(cluster_keys)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy assigns it to an initial cluster based on predictive clustering, initializes its access frequency and temporal access pattern, and sets an initial quantum efficiency score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    initial_cluster_id = 0  # For simplicity, we assign all new objects to cluster 0
    if initial_cluster_id not in metadata['clusters']:
        metadata['clusters'][initial_cluster_id] = set()
        metadata['quantum_efficiency'][initial_cluster_id] = INITIAL_QUANTUM_EFFICIENCY_SCORE

    metadata['access_frequency'][key] = 1
    metadata['temporal_access'][key] = cache_snapshot.access_count
    metadata['cluster_membership'][key] = initial_cluster_id
    metadata['clusters'][initial_cluster_id].add(key)

    # Recalculate quantum efficiency score for the cluster
    cluster_keys = metadata['clusters'][initial_cluster_id]
    total_accesses = sum(metadata['access_frequency'][k] for k in cluster_keys)
    metadata['quantum_efficiency'][initial_cluster_id] = total_accesses / len(cluster_keys)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting a victim, the policy updates the cluster metadata to reflect the removal, recalculates the quantum efficiency score for the affected cluster, and adjusts the overall cache usage statistics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_key = evicted_obj.key
    cluster_id = metadata['cluster_membership'][evicted_key]

    # Remove the evicted object from metadata
    del metadata['access_frequency'][evicted_key]
    del metadata['temporal_access'][evicted_key]
    del metadata['cluster_membership'][evicted_key]
    metadata['clusters'][cluster_id].remove(evicted_key)

    # Recalculate quantum efficiency score for the cluster
    if metadata['clusters'][cluster_id]:
        cluster_keys = metadata['clusters'][cluster_id]
        total_accesses = sum(metadata['access_frequency'][k] for k in cluster_keys)
        metadata['quantum_efficiency'][cluster_id] = total_accesses / len(cluster_keys)
    else:
        metadata['quantum_efficiency'][cluster_id] = 0