# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque, defaultdict
import heapq

# Put tunable constant parameters below

# Put the metadata specifically maintained by the policy below. The policy maintains a stack for insertion order, a sequence list for access order, a priority queue for item priorities, a multi-level hierarchy for data frequency, an access frequency counter, a context map for related data access patterns, and metadata for each object including access frequency, recency, size, and cache level.
insertion_stack = deque()
access_sequence = deque()
priority_queue = []
frequency_hierarchy = defaultdict(list)
access_frequency = defaultdict(int)
context_map = defaultdict(set)
metadata = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy identifies the lowest priority level objects using the priority queue and the lowest level of the hierarchy. Among these, it selects the object with the least recent access from the sequence list. If there is a tie, the object with the largest size and least contextual importance is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    while priority_queue:
        _, key = heapq.heappop(priority_queue)
        if key in cache_snapshot.cache:
            candid_obj_key = key
            break
    
    if candid_obj_key is None:
        return None
    
    # Find the least recent access from the sequence list
    for key in access_sequence:
        if key == candid_obj_key:
            break
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    The policy updates the sequence list to move the accessed entry to the most recent position, increments the entry's frequency counter, adjusts its position in the hierarchy and priority queue if necessary, updates the access pattern list with the new access time, adjusts the rhythm tracking, updates the access frequency and recency, and updates the context map to reflect the access pattern.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    if key in access_sequence:
        access_sequence.remove(key)
    access_sequence.append(key)
    
    access_frequency[key] += 1
    frequency_hierarchy[access_frequency[key]].append(key)
    
    heapq.heappush(priority_queue, (access_frequency[key], key))
    
    metadata[key]['recency'] = cache_snapshot.access_count
    metadata[key]['frequency'] = access_frequency[key]
    metadata[key]['context'] = context_map[key]

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    The policy pushes the new object onto the stack, updates the sequence list to include the new entry, places the entry at the appropriate level in the hierarchy and priority queue based on initial access frequency, initializes its access frequency, sets recency to the current time, records its size, places it in the appropriate cache level based on its priority, and updates the context map to include the new entry's relationships.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    key = obj.key
    insertion_stack.append(key)
    access_sequence.append(key)
    
    access_frequency[key] = 1
    frequency_hierarchy[1].append(key)
    
    heapq.heappush(priority_queue, (1, key))
    
    metadata[key] = {
        'recency': cache_snapshot.access_count,
        'frequency': 1,
        'size': obj.size,
        'context': set()
    }
    
    context_map[key] = set()

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    The policy removes the evicted item from the stack, deletes its entry from the sequence list and access pattern list, removes it from the priority queue and hierarchy, removes its metadata, and updates the context map to remove any references to the evicted entry. The policy may adjust the priority levels and hierarchy of remaining objects and potentially demote objects to lower cache levels if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    key = evicted_obj.key
    if key in insertion_stack:
        insertion_stack.remove(key)
    if key in access_sequence:
        access_sequence.remove(key)
    
    if key in access_frequency:
        freq = access_frequency[key]
        if key in frequency_hierarchy[freq]:
            frequency_hierarchy[freq].remove(key)
        del access_frequency[key]
    
    if key in metadata:
        del metadata[key]
    
    if key in context_map:
        del context_map[key]
    
    for k, v in context_map.items():
        if key in v:
            v.remove(key)