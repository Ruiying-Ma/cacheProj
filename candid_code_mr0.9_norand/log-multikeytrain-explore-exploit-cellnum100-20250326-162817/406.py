# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
REGION_COUNT = 4  # Number of regions to classify objects based on access patterns

# Put the metadata specifically maintained by the policy below. The policy maintains an ordered list of cached items, access frequency counters, contextual relevance scores, pattern detection scores, reward scores, partitions based on access frequency, FIFO queue, last access time, region classification, prediction model for access patterns, mirrored list of recently accessed items, hidden list of recently evicted items, and historical access pattern log for each cached item.
metadata = {
    'access_frequency': {},  # {key: frequency}
    'contextual_relevance': {},  # {key: relevance_score}
    'pattern_detection': {},  # {key: pattern_score}
    'reward_scores': {},  # {key: reward_score}
    'partitions': {i: set() for i in range(REGION_COUNT)},  # {region: set of keys}
    'fifo_queue': [],  # list of keys in FIFO order
    'last_access_time': {},  # {key: last_access_time}
    'region_classification': {},  # {key: region}
    'prediction_model': {},  # {key: predicted_access_probability}
    'primary_list': [],  # list of keys in primary list
    'mirrored_list': [],  # list of keys in mirrored list
    'hidden_list': [],  # list of keys in hidden list
    'historical_access_log': {}  # {key: [access_times]}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first identifies the region with the least recent access. Within that region, it selects the object not present in both the primary and mirrored lists. If no such object exists, it uses the prediction model to evict the object with the lowest predicted access probability. If there is still a tie, it evaluates a composite score derived from the access frequency, contextual relevance, pattern detection, and reward scores. If there is still a tie, the object at the front of the FIFO queue is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    # Identify the region with the least recent access
    least_recent_region = min(metadata['partitions'], key=lambda r: min(metadata['last_access_time'][k] for k in metadata['partitions'][r] if k in metadata['last_access_time']))

    # Select the object not present in both the primary and mirrored lists
    candidates = [k for k in metadata['partitions'][least_recent_region] if k not in metadata['primary_list'] and k not in metadata['mirrored_list']]
    if candidates:
        candid_obj_key = candidates[0]
    else:
        # Use the prediction model to evict the object with the lowest predicted access probability
        candidates = list(metadata['partitions'][least_recent_region])
        candidates.sort(key=lambda k: metadata['prediction_model'].get(k, 0))
        if candidates:
            candid_obj_key = candidates[0]
        else:
            # Evaluate a composite score derived from the access frequency, contextual relevance, pattern detection, and reward scores
            candidates.sort(key=lambda k: (metadata['access_frequency'].get(k, 0) + metadata['contextual_relevance'].get(k, 0) + metadata['pattern_detection'].get(k, 0) + metadata['reward_scores'].get(k, 0)))
            if candidates:
                candid_obj_key = candidates[0]
            else:
                # Evict the object at the front of the FIFO queue
                candid_obj_key = metadata['fifo_queue'][0]
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    The policy updates the last access time, increments the access frequency, updates the prediction model with the new access pattern, moves the accessed item to the front of the primary and mirrored lists, updates the contextual relevance score, adjusts the pattern detection score, increases the reward score, and updates the historical access log for the item.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Update the last access time
    metadata['last_access_time'][key] = current_time

    # Increment the access frequency
    metadata['access_frequency'][key] = metadata['access_frequency'].get(key, 0) + 1

    # Update the prediction model with the new access pattern
    metadata['prediction_model'][key] = metadata['access_frequency'][key] / current_time

    # Move the accessed item to the front of the primary and mirrored lists
    if key in metadata['primary_list']:
        metadata['primary_list'].remove(key)
    metadata['primary_list'].insert(0, key)

    if key in metadata['mirrored_list']:
        metadata['mirrored_list'].remove(key)
    metadata['mirrored_list'].insert(0, key)

    # Update the contextual relevance score
    metadata['contextual_relevance'][key] = metadata['contextual_relevance'].get(key, 0) + 1

    # Adjust the pattern detection score
    metadata['pattern_detection'][key] = metadata['pattern_detection'].get(key, 0) + 1

    # Increase the reward score
    metadata['reward_scores'][key] = metadata['reward_scores'].get(key, 0) + 1

    # Update the historical access log for the item
    if key not in metadata['historical_access_log']:
        metadata['historical_access_log'][key] = []
    metadata['historical_access_log'][key].append(current_time)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    The policy assigns the new object to a region based on initial access patterns, sets its access frequency to 1, records the current time as the last access time, updates the prediction model to include the new object, adds the object to the front of the primary and mirrored lists, initializes the historical access log, places the object in the partition with the lowest access frequency, and adds the object to the rear of the FIFO queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    current_time = cache_snapshot.access_count

    # Assign the new object to a region based on initial access patterns
    region = min(metadata['partitions'], key=lambda r: len(metadata['partitions'][r]))
    metadata['region_classification'][key] = region

    # Set its access frequency to 1
    metadata['access_frequency'][key] = 1

    # Record the current time as the last access time
    metadata['last_access_time'][key] = current_time

    # Update the prediction model to include the new object
    metadata['prediction_model'][key] = 1 / current_time

    # Add the object to the front of the primary and mirrored lists
    metadata['primary_list'].insert(0, key)
    metadata['mirrored_list'].insert(0, key)

    # Initialize the historical access log
    metadata['historical_access_log'][key] = [current_time]

    # Place the object in the partition with the lowest access frequency
    metadata['partitions'][region].add(key)

    # Add the object to the rear of the FIFO queue
    metadata['fifo_queue'].append(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    The policy removes the evicted object's metadata, updates the region's statistics to reflect the eviction, adjusts the prediction model to account for the removal, removes the object from the primary and mirrored lists, adds it to the hidden list, retains the historical access log, removes the object from the FIFO queue, recalculates the composite scores for the remaining objects, updates the contextual relevance and pattern detection scores, adjusts the reward scores, and merges partitions if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key

    # Remove the evicted object's metadata
    if key in metadata['access_frequency']:
        del metadata['access_frequency'][key]
    if key in metadata['contextual_relevance']:
        del metadata['contextual_relevance'][key]
    if key in metadata['pattern_detection']:
        del metadata['pattern_detection'][key]
    if key in metadata['reward_scores']:
        del metadata['reward_scores'][key]
    if key in metadata['last_access_time']:
        del metadata['last_access_time'][key]
    if key in metadata['region_classification']:
        region = metadata['region_classification'][key]
        metadata['partitions'][region].remove(key)
        del metadata['region_classification'][key]
    if key in metadata['prediction_model']:
        del metadata['prediction_model'][key]

    # Remove the object from the primary and mirrored lists
    if key in metadata['primary_list']:
        metadata['primary_list'].remove(key)
    if key in metadata['mirrored_list']:
        metadata['mirrored_list'].remove(key)

    # Add it to the hidden list
    metadata['hidden_list'].append(key)

    # Retain the historical access log
    # (No action needed as we are not deleting it)

    # Remove the object from the FIFO queue
    if key in metadata['fifo_queue']:
        metadata['fifo_queue'].remove(key)

    # Recalculate the composite scores for the remaining objects
    # (No action needed as it will be recalculated during eviction)

    # Update the contextual relevance and pattern detection scores
    # (No action needed as it will be updated during access)

    # Adjust the reward scores
    # (No action needed as it will be updated during access)

    # Merge partitions if necessary
    # (No action needed as we are not implementing partition merging logic)