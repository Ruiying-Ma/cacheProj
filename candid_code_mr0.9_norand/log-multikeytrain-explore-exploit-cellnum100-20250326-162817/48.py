# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
SQ_CAPACITY = 100  # Example capacity for SQ
MQ_CAPACITY = 100  # Example capacity for MQ
GQ_CAPACITY = 100  # Example capacity for GQ

# Put the metadata specifically maintained by the policy below. The policy maintains two FIFO queues (SQ and MQ) for cache items, a ghost FIFO queue (GQ) for recently evicted items, access frequency for each cached object, a timestamp for last access, and a collaborative table for sharing cache contents and eviction decisions with other caches.
SQ = []
MQ = []
GQ = []
access_frequency = {}
last_access_timestamp = {}
collaborative_table = {}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    During eviction, if SQ exceeds its capacity, objects are moved from SQ to MQ until an object with frequency less than 2 is found or MQ is full. If MQ is full, the least frequently accessed item with the longest dormancy in MQ is evicted. Otherwise, the object with frequency less than 2 in SQ is evicted. Evicted objects are added to GQ.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    while len(SQ) > SQ_CAPACITY:
        item = SQ.pop(0)
        if access_frequency[item.key] < 2:
            candid_obj_key = item.key
            break
        else:
            if len(MQ) < MQ_CAPACITY:
                MQ.append(item)
            else:
                # Find the least frequently accessed item with the longest dormancy in MQ
                min_freq = min(access_frequency[obj.key] for obj in MQ)
                candidates = [obj for obj in MQ if access_frequency[obj.key] == min_freq]
                oldest = min(candidates, key=lambda x: last_access_timestamp[x.key])
                MQ.remove(oldest)
                candid_obj_key = oldest.key
                break
    if candid_obj_key is None:
        if len(MQ) > 0:
            min_freq = min(access_frequency[obj.key] for obj in MQ)
            candidates = [obj for obj in MQ if access_frequency[obj.key] == min_freq]
            oldest = min(candidates, key=lambda x: last_access_timestamp[x.key])
            MQ.remove(oldest)
            candid_obj_key = oldest.key
        else:
            item = SQ.pop(0)
            candid_obj_key = item.key

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the access frequency of the item is increased by 1 if it is less than 3, the item is moved higher in the hierarchy, and the last access timestamp is updated to the current time. The collaborative table is updated with the new access information.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    if access_frequency[obj.key] < 3:
        access_frequency[obj.key] += 1
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    if obj in SQ:
        SQ.remove(obj)
        MQ.append(obj)
    collaborative_table[obj.key] = {
        'frequency': access_frequency[obj.key],
        'last_access': last_access_timestamp[obj.key]
    }

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the object is placed in SQ with an initial frequency of 1 and the current time as the last access timestamp. If the object was in GQ, it is placed in MQ instead. The collaborative table is updated with the new cache content.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    if obj.key in GQ:
        GQ.remove(obj.key)
        MQ.append(obj)
    else:
        SQ.append(obj)
    access_frequency[obj.key] = 1
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    collaborative_table[obj.key] = {
        'frequency': access_frequency[obj.key],
        'last_access': last_access_timestamp[obj.key]
    }

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the item is added to GQ, its frequency is no longer tracked, and the collaborative table is updated to reflect the eviction decision. The last access timestamp is cleared.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    GQ.append(evicted_obj.key)
    if len(GQ) > GQ_CAPACITY:
        GQ.pop(0)
    del access_frequency[evicted_obj.key]
    del last_access_timestamp[evicted_obj.key]
    collaborative_table.pop(evicted_obj.key, None)