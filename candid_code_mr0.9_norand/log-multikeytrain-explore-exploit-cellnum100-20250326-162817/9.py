# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import deque
import heapq

# Put tunable constant parameters below

# Put the metadata specifically maintained by the policy below. The policy maintains a stack to track the order of insertion, a list to monitor access patterns and rhythms, and a priority queue to manage item priorities.
stack = deque()  # Stack to track the order of insertion
access_pattern = {}  # Dictionary to track access times
priority_queue = []  # Priority queue to manage item priorities

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first checks the stack to identify the most recently added item. It then cross-references this with the access pattern list and priority queue to ensure that the item is both the most recently added and has the lowest priority or irregular access rhythm.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    while stack:
        most_recent_key = stack.pop()
        if most_recent_key in cache_snapshot.cache:
            candid_obj_key = most_recent_key
            break
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the access pattern list to reflect the new access time and adjusts the rhythm tracking. The priority of the item is re-evaluated and updated in the priority queue if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    current_time = cache_snapshot.access_count
    access_pattern[obj.key] = current_time
    # Re-evaluate and update priority in the priority queue
    for i, (priority, key) in enumerate(priority_queue):
        if key == obj.key:
            priority_queue[i] = (current_time, key)
            heapq.heapify(priority_queue)
            break

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy pushes the object onto the stack, adds an entry to the access pattern list with the current time, and inserts the object into the priority queue with its initial priority.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    current_time = cache_snapshot.access_count
    stack.append(obj.key)
    access_pattern[obj.key] = current_time
    heapq.heappush(priority_queue, (current_time, obj.key))

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the evicted item from the stack, deletes its entry from the access pattern list, and removes it from the priority queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    if evicted_obj.key in stack:
        stack.remove(evicted_obj.key)
    if evicted_obj.key in access_pattern:
        del access_pattern[evicted_obj.key]
    for i, (priority, key) in enumerate(priority_queue):
        if key == evicted_obj.key:
            priority_queue.pop(i)
            heapq.heapify(priority_queue)
            break