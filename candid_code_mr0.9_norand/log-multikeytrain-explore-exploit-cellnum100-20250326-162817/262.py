# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import heapq
from collections import defaultdict, deque

# Put tunable constant parameters below
FREQUENCY_THRESHOLD = 5

# Put the metadata specifically maintained by the policy below. The policy maintains a circular pointer, access frequency, last access timestamp, dynamic weight, workload characteristic indicator, recency, hierarchical level, probabilistic eviction score, a priority queue, and a frequency distribution metadata.
metadata = {
    'pointer': 0,
    'access_frequency': defaultdict(int),
    'last_access_timestamp': {},
    'dynamic_weight': {},
    'workload_characteristic': 0,
    'recency': {},
    'hierarchical_level': defaultdict(int),
    'probabilistic_eviction_score': {},
    'priority_queue': [],
    'frequency_distribution': defaultdict(int),
    'cache_keys': deque()
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy starts from the current pointer position and moves cyclically, resetting frequencies to 0 until it finds an object with zero frequency. It then evaluates items at the lowest hierarchical level, selecting the item with the highest probabilistic eviction score. The item is then removed from the priority queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    cache_keys = metadata['cache_keys']
    pointer = metadata['pointer']
    
    while True:
        current_key = cache_keys[pointer]
        if metadata['access_frequency'][current_key] == 0:
            break
        metadata['access_frequency'][current_key] = 0
        pointer = (pointer + 1) % len(cache_keys)
    
    lowest_level = min(metadata['hierarchical_level'].values())
    candidates = [key for key in cache_keys if metadata['hierarchical_level'][key] == lowest_level]
    candid_obj_key = max(candidates, key=lambda k: metadata['probabilistic_eviction_score'][k])
    
    metadata['pointer'] = pointer
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a hit, the policy sets the object's frequency to 1, updates the last access timestamp, increments the frequency counter, recalculates the dynamic weight, updates recency, adjusts the hierarchical level if necessary, recalculates the probabilistic eviction score, updates its priority in the priority queue, and may promote it to a higher level if its frequency surpasses a threshold.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = 1
    metadata['last_access_timestamp'][key] = cache_snapshot.access_count
    metadata['dynamic_weight'][key] = 1 / (cache_snapshot.access_count - metadata['last_access_timestamp'][key] + 1)
    metadata['recency'][key] = cache_snapshot.access_count
    if metadata['access_frequency'][key] > FREQUENCY_THRESHOLD:
        metadata['hierarchical_level'][key] += 1
    metadata['probabilistic_eviction_score'][key] = metadata['dynamic_weight'][key] * metadata['recency'][key]
    heapq.heappush(metadata['priority_queue'], (-metadata['probabilistic_eviction_score'][key], key))

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy sets the frequency to 1, initializes the last access timestamp, sets the frequency counter to 1, calculates the initial dynamic weight, updates the workload characteristic indicator, initializes recency, assigns the object to the appropriate hierarchical level, calculates its initial probabilistic eviction score, adds it to the priority queue with an initial priority, and places it at the current pointer location.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    metadata['access_frequency'][key] = 1
    metadata['last_access_timestamp'][key] = cache_snapshot.access_count
    metadata['dynamic_weight'][key] = 1
    metadata['workload_characteristic'] += obj.size
    metadata['recency'][key] = cache_snapshot.access_count
    metadata['hierarchical_level'][key] = 0
    metadata['probabilistic_eviction_score'][key] = metadata['dynamic_weight'][key] * metadata['recency'][key]
    heapq.heappush(metadata['priority_queue'], (-metadata['probabilistic_eviction_score'][key], key))
    metadata['cache_keys'].append(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the metadata of the evicted object, adjusts the workload characteristic indicator based on the current cache state and access patterns, may adjust the hierarchical levels of remaining items if necessary to ensure the structure remains balanced, removes the item from the priority queue, and updates the frequency distribution metadata.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    key = evicted_obj.key
    del metadata['access_frequency'][key]
    del metadata['last_access_timestamp'][key]
    del metadata['dynamic_weight'][key]
    del metadata['recency'][key]
    del metadata['hierarchical_level'][key]
    del metadata['probabilistic_eviction_score'][key]
    metadata['workload_characteristic'] -= evicted_obj.size
    metadata['cache_keys'].remove(key)
    metadata['priority_queue'] = [item for item in metadata['priority_queue'] if item[1] != key]
    heapq.heapify(metadata['priority_queue'])