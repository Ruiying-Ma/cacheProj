# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import defaultdict, deque

# Put tunable constant parameters below
WINDOW_CACHE_SIZE = 10  # Size of the window cache (W)
DECAY_INTERVAL = 100  # Number of evictions after which CBF decays

# Put the metadata specifically maintained by the policy below. The policy maintains a priority level, frequency count, last access timestamp, Count Bloom Filter (CBF) for frequency estimation, access recency, group identifiers, historical access patterns, and layer-specific statistics. The cache is divided into a small window cache (W) using LRU and a larger main cache (M) with an adaptive eviction policy.
window_cache = deque()  # LRU cache for the window cache (W)
main_cache = {}  # Main cache (M)
frequency_count = defaultdict(int)  # Frequency count for objects
last_access_timestamp = {}  # Last access timestamp for objects
priority_level = defaultdict(int)  # Priority level for objects
cbf = defaultdict(int)  # Count Bloom Filter for frequency estimation
recency = {}  # Recency information for objects
group_metadata = defaultdict(set)  # Group identifiers for objects
historical_access_patterns = {}  # Historical access patterns
layer_statistics = {}  # Layer-specific statistics
eviction_count = 0  # Counter for the number of evictions

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy first attempts to evict from W using LRU. If W is empty, it evicts from M using the adaptive policy. If W is not empty, it compares the least recently used object from W with an object from M based on CBF frequency and priority level. The object with the lower combined score of frequency and priority is evicted. If M is full, the policy evicts the least frequently used item within the least recently used group.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global eviction_count
    candid_obj_key = None

    if window_cache:
        lru_window_obj = window_cache[0]
        lru_window_key = lru_window_obj.key
        lru_window_score = cbf[lru_window_key] + priority_level[lru_window_key]

        if main_cache:
            lru_main_key = min(main_cache, key=lambda k: (cbf[k], priority_level[k]))
            lru_main_score = cbf[lru_main_key] + priority_level[lru_main_key]

            if lru_window_score <= lru_main_score:
                candid_obj_key = lru_window_key
            else:
                candid_obj_key = lru_main_key
        else:
            candid_obj_key = lru_window_key
    else:
        if main_cache:
            lru_main_key = min(main_cache, key=lambda k: (cbf[k], priority_level[k]))
            candid_obj_key = lru_main_key

    eviction_count += 1
    if eviction_count % DECAY_INTERVAL == 0:
        for key in cbf:
            cbf[key] = max(0, cbf[key] - 1)

    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the frequency count, updates the last access timestamp, and adjusts the priority level based on the new frequency count and overall access patterns. It also updates the access frequency in CBF, recency, and group metadata for the hit item, and adjusts the historical access patterns and layer-specific statistics.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    key = obj.key
    frequency_count[key] += 1
    last_access_timestamp[key] = cache_snapshot.access_count
    priority_level[key] = frequency_count[key]  # Adjust priority based on frequency
    cbf[key] += 1
    recency[key] = cache_snapshot.access_count
    group_metadata[key].add('hit')
    historical_access_patterns[key] = cache_snapshot.access_count
    layer_statistics[key] = (frequency_count[key], recency[key])

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy adds it to W, initializes its frequency count to 1, sets its last access timestamp, assigns an initial priority level, and initializes its access frequency in CBF, recency, and group metadata. It updates the historical access patterns and layer-specific statistics to include the new object.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    key = obj.key
    if len(window_cache) >= WINDOW_CACHE_SIZE:
        window_cache.popleft()
    window_cache.append(obj)
    frequency_count[key] = 1
    last_access_timestamp[key] = cache_snapshot.access_count
    priority_level[key] = 1
    cbf[key] = 1
    recency[key] = cache_snapshot.access_count
    group_metadata[key].add('insert')
    historical_access_patterns[key] = cache_snapshot.access_count
    layer_statistics[key] = (frequency_count[key], recency[key])

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an object, the policy updates the overall access patterns, potentially adjusting the priority levels of remaining objects. It also updates the CBF by decaying every K evictions, adjusts the group metadata, and recalibrates the historical access patterns and layer-specific statistics to account for the eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    if evicted_key in window_cache:
        window_cache.remove(evicted_obj)
    if evicted_key in main_cache:
        del main_cache[evicted_key]
    del frequency_count[evicted_key]
    del last_access_timestamp[evicted_key]
    del priority_level[evicted_key]
    del cbf[evicted_key]
    del recency[evicted_key]
    del group_metadata[evicted_key]
    del historical_access_patterns[evicted_key]
    del layer_statistics[evicted_key]