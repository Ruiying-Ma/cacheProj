# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
import heapq
from collections import defaultdict, deque

# Put tunable constant parameters below
HALF_LIFE = 1000
INITIAL_PRIORITY_SCORE = 1
INITIAL_PRIORITY_LEVEL = 1

# Put the metadata specifically maintained by the policy below. The policy maintains a priority queue for each partition, access frequency, recency of access, cohesion score, decay timer, priority level, and overall access patterns. It also tracks the partition and cache level for each object.
metadata = {
    'access_frequency': defaultdict(int),
    'recency_timestamp': {},
    'cohesion_score': {},
    'decay_timer': {},
    'priority_score': {},
    'priority_level': {},
    'priority_queue': [],
    'partition_access': defaultdict(deque),
}

def calculate_combined_priority_score(obj_key):
    freq = metadata['access_frequency'][obj_key]
    recency = metadata['recency_timestamp'][obj_key]
    cohesion = metadata['cohesion_score'][obj_key]
    decay = metadata['decay_timer'][obj_key]
    priority = metadata['priority_score'][obj_key]
    combined_score = (1 / (freq + 1)) + (1 / (recency + 1)) + (1 / (cohesion + 1)) + (1 / (decay + 1)) + priority
    return combined_score

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy calculates a combined priority score for each object based on a weighted combination of low access frequency, low recency, low cohesion, expired decay timer, and priority score. It evicts the object with the lowest combined priority score from the partition with the least recent access.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_combined_score = float('inf')
    
    for obj_key in cache_snapshot.cache:
        combined_score = calculate_combined_priority_score(obj_key)
        if combined_score < min_combined_score:
            min_combined_score = combined_score
            candid_obj_key = obj_key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy increments the access frequency, updates the recency timestamp, recalculates the cohesion score, resets the decay timer, recalculates the priority score, and adjusts the object's position in the priority queue. It may also adjust the priority level and promote the object to a higher partition or cache level if warranted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    obj_key = obj.key
    metadata['access_frequency'][obj_key] += 1
    metadata['recency_timestamp'][obj_key] = cache_snapshot.access_count
    metadata['decay_timer'][obj_key] = HALF_LIFE
    metadata['priority_score'][obj_key] = calculate_combined_priority_score(obj_key)
    
    # Adjust the object's position in the priority queue
    heapq.heapify(metadata['priority_queue'])

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy initializes its access frequency to 1, sets the recency timestamp to the current time, calculates its initial cohesion score, sets its decay timer to a predefined half-life value, assigns an initial priority score and priority level, places it in the appropriate partition and cache level, and updates the priority queue.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    obj_key = obj.key
    metadata['access_frequency'][obj_key] = 1
    metadata['recency_timestamp'][obj_key] = cache_snapshot.access_count
    metadata['cohesion_score'][obj_key] = 1  # Initial cohesion score
    metadata['decay_timer'][obj_key] = HALF_LIFE
    metadata['priority_score'][obj_key] = INITIAL_PRIORITY_SCORE
    metadata['priority_level'][obj_key] = INITIAL_PRIORITY_LEVEL
    
    # Add to priority queue
    heapq.heappush(metadata['priority_queue'], (metadata['priority_score'][obj_key], obj_key))

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    Following an eviction, the policy removes the object from the priority queue, updates the partition and cache level metadata, recalculates the cohesion scores and priority scores of remaining objects if necessary, and updates overall access patterns to potentially adjust the priority levels of remaining objects.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    evicted_key = evicted_obj.key
    
    # Remove from priority queue
    metadata['priority_queue'] = [(score, key) for score, key in metadata['priority_queue'] if key != evicted_key]
    heapq.heapify(metadata['priority_queue'])
    
    # Remove metadata
    del metadata['access_frequency'][evicted_key]
    del metadata['recency_timestamp'][evicted_key]
    del metadata['cohesion_score'][evicted_key]
    del metadata['decay_timer'][evicted_key]
    del metadata['priority_score'][evicted_key]
    del metadata['priority_level'][evicted_key]
    
    # Recalculate cohesion scores and priority scores if necessary
    for obj_key in cache_snapshot.cache:
        metadata['cohesion_score'][obj_key] = 1  # Recalculate cohesion score
        metadata['priority_score'][obj_key] = calculate_combined_priority_score(obj_key)
    
    # Update priority queue
    heapq.heapify(metadata['priority_queue'])