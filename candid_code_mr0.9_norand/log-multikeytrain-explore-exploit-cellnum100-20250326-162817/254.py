# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.

# Put tunable constant parameters below
INITIAL_ENERGY = 1
ENERGY_INCREMENT = 1
ENERGY_DECAY = 0.9
ENERGY_THRESHOLD = 10

# Put the metadata specifically maintained by the policy below. The policy maintains a hierarchical structure with multiple levels, each level representing a different priority based on access frequency. Each object has an 'energy' score that increases with access and decays over time.
cache_metadata = {
    'levels': {},  # Dictionary to maintain levels, e.g., {0: {key: energy, ...}, 1: {key: energy, ...}, ...}
    'object_levels': {},  # Dictionary to track which level an object is in, e.g., {key: level, ...}
    'object_energy': {}  # Dictionary to track the energy of objects, e.g., {key: energy, ...}
}

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy evicts objects from the lowest level of the hierarchy first. Within a level, it chooses the object with the lowest energy score for eviction.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    # Your code below
    for level in sorted(cache_metadata['levels'].keys()):
        if cache_metadata['levels'][level]:
            # Find the object with the lowest energy in this level
            candid_obj_key = min(cache_metadata['levels'][level], key=cache_metadata['levels'][level].get)
            break
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the object's energy score is increased, and it may be moved to a higher level in the hierarchy if its energy surpasses a threshold. The access frequency is also updated.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Your code below
    obj_key = obj.key
    current_level = cache_metadata['object_levels'][obj_key]
    current_energy = cache_metadata['object_energy'][obj_key]
    
    # Increase the energy score
    new_energy = current_energy + ENERGY_INCREMENT
    cache_metadata['object_energy'][obj_key] = new_energy
    
    # Check if the object should be moved to a higher level
    if new_energy > ENERGY_THRESHOLD:
        new_level = current_level + 1
        cache_metadata['levels'][current_level].pop(obj_key)
        if new_level not in cache_metadata['levels']:
            cache_metadata['levels'][new_level] = {}
        cache_metadata['levels'][new_level][obj_key] = new_energy
        cache_metadata['object_levels'][obj_key] = new_level

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    Upon inserting a new object, it is placed in the lowest level of the hierarchy with an initial energy score. The hierarchy and energy scores of other objects are adjusted if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Your code below
    obj_key = obj.key
    initial_level = 0
    initial_energy = INITIAL_ENERGY
    
    # Place the new object in the lowest level with initial energy score
    if initial_level not in cache_metadata['levels']:
        cache_metadata['levels'][initial_level] = {}
    cache_metadata['levels'][initial_level][obj_key] = initial_energy
    cache_metadata['object_levels'][obj_key] = initial_level
    cache_metadata['object_energy'][obj_key] = initial_energy

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After eviction, the policy recalculates the energy scores and access frequencies of remaining objects, potentially moving them between levels to maintain the hierarchy.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Your code below
    evicted_key = evicted_obj.key
    evicted_level = cache_metadata['object_levels'].pop(evicted_key)
    cache_metadata['levels'][evicted_level].pop(evicted_key)
    cache_metadata['object_energy'].pop(evicted_key)
    
    # Decay the energy of remaining objects
    for level in cache_metadata['levels']:
        for key in cache_metadata['levels'][level]:
            cache_metadata['object_energy'][key] *= ENERGY_DECAY
            cache_metadata['levels'][level][key] = cache_metadata['object_energy'][key]
    
    # Recalculate levels if necessary
    for key in list(cache_metadata['object_levels'].keys()):
        current_level = cache_metadata['object_levels'][key]
        current_energy = cache_metadata['object_energy'][key]
        if current_energy > ENERGY_THRESHOLD:
            new_level = current_level + 1
            cache_metadata['levels'][current_level].pop(key)
            if new_level not in cache_metadata['levels']:
                cache_metadata['levels'][new_level] = {}
            cache_metadata['levels'][new_level][key] = current_energy
            cache_metadata['object_levels'][key] = new_level