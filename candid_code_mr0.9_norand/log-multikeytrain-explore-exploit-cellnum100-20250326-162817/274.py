# Import anything you need below. You must not use any randomness. For example, you cannot `import random`. Also, you cannot use any function in `numpy` that uses randomness, such as the functions in `numpy.random`.
from collections import OrderedDict

# Put tunable constant parameters below
# For example, you can define weights for the unique score calculation
FREQUENCY_WEIGHT = 1
RECENCY_WEIGHT = 1
SIZE_WEIGHT = 1

# Put the metadata specifically maintained by the policy below. The policy maintains a linked list to track access order, a frequency counter for each item, a timestamp of the last access, and a unique score based on access patterns and content importance.
access_order = OrderedDict()  # Linked list to track access order
frequency_counter = {}  # Frequency counter for each item
last_access_timestamp = {}  # Timestamp of the last access for each item
unique_scores = {}  # Unique score for each item

def calculate_unique_score(obj, current_time):
    frequency = frequency_counter.get(obj.key, 0)
    recency = current_time - last_access_timestamp.get(obj.key, 0)
    size = obj.size
    return (FREQUENCY_WEIGHT * frequency) + (RECENCY_WEIGHT * recency) + (SIZE_WEIGHT * size)

def evict(cache_snapshot, obj):
    '''
    This function defines how the policy chooses the eviction victim.
    The policy chooses the eviction victim by selecting the item with the lowest unique score, considering access frequency, recency, and data importance. If scores are tied, the least recently used item is evicted.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_score = float('inf')
    
    for key, cached_obj in cache_snapshot.cache.items():
        score = calculate_unique_score(cached_obj, cache_snapshot.access_count)
        if score < min_score or (score == min_score and key in access_order and access_order[key] < access_order[candid_obj_key]):
            min_score = score
            candid_obj_key = key
    
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the policy update the metadata it maintains immediately after a cache hit.
    Upon a cache hit, the policy updates the linked list to move the accessed item to the tail, increments its frequency counter, updates its last access timestamp, and recalculates its unique score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    # Move the accessed item to the tail
    if obj.key in access_order:
        del access_order[obj.key]
    access_order[obj.key] = cache_snapshot.access_count
    
    # Increment its frequency counter
    frequency_counter[obj.key] = frequency_counter.get(obj.key, 0) + 1
    
    # Update its last access timestamp
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    
    # Recalculate its unique score
    unique_scores[obj.key] = calculate_unique_score(obj, cache_snapshot.access_count)

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after inserting a new object into the cache.
    After inserting a new object, the policy adds it to the tail of the linked list, initializes its frequency counter, sets its last access timestamp to the current time, and calculates its initial unique score.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    # Add the new object to the tail of the linked list
    access_order[obj.key] = cache_snapshot.access_count
    
    # Initialize its frequency counter
    frequency_counter[obj.key] = 1
    
    # Set its last access timestamp to the current time
    last_access_timestamp[obj.key] = cache_snapshot.access_count
    
    # Calculate its initial unique score
    unique_scores[obj.key] = calculate_unique_score(obj, cache_snapshot.access_count)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the policy updates the metadata it maintains immediately after evicting the victim.
    After evicting an item, the policy removes it from the linked list, deletes its frequency counter and timestamp, and recalculates the unique scores of remaining items if necessary.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    # Remove the evicted item from the linked list
    if evicted_obj.key in access_order:
        del access_order[evicted_obj.key]
    
    # Delete its frequency counter and timestamp
    if evicted_obj.key in frequency_counter:
        del frequency_counter[evicted_obj.key]
    if evicted_obj.key in last_access_timestamp:
        del last_access_timestamp[evicted_obj.key]
    
    # Delete its unique score
    if evicted_obj.key in unique_scores:
        del unique_scores[evicted_obj.key]
    
    # Recalculate the unique scores of remaining items if necessary
    for key in cache_snapshot.cache:
        unique_scores[key] = calculate_unique_score(cache_snapshot.cache[key], cache_snapshot.access_count)